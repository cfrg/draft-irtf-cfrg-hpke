{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-07-25T11:41:38.648907+00:00",
  "repo": "cfrg/draft-irtf-cfrg-hpke",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "Pre-RGLC",
      "description": "",
      "color": "d4c5f9"
    },
    {
      "name": "editorial",
      "description": "Editorial",
      "color": "f48e75"
    }
  ],
  "issues": [
    {
      "number": 10,
      "id": "MDU6SXNzdWU1MTMzNzA1MDI=",
      "title": "Link of reference [SECG] broken",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/10",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi, the link of reference \u201c[SECG] Elliptic Curve Cryptography, Standards for Efficient Cryptography Group, ver. 2\u201d seems broken. Instead of http://www.secg.org/download/aid-780/sec1-v2.pdf the following seems to work: https://secg.org/sec1-v2.pdf",
      "createdAt": "2019-10-28T15:16:05Z",
      "updatedAt": "2019-11-04T16:45:14Z",
      "closedAt": "2019-11-04T16:45:14Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU1MTYzNDM3MzY=",
      "title": "Issues in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/12",
      "state": "CLOSED",
      "author": "kelrit",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Two issues I found in the test vectors:\r\n\r\n- kemID is incorrect. eg - for Curve25519, `kemID: 1` but it's specified as 2 in the draft.\r\n- Sequence numbers for generating nonces look off by one.\r\nFor DHKEM(Curve25519), HKDF-SHA256, AES-GCM-128, the initial nonce is `0d8e01f89fa5abab107f7fe9`, but the nonce used in the first encryption (sequence number 0) is `0d8e01f89fa5abab107f7fe8` - the initial one XOR 1.\r\nAs I understand the spec says it should be XOR 0.",
      "createdAt": "2019-11-01T20:58:13Z",
      "updatedAt": "2019-11-05T19:40:14Z",
      "closedAt": "2019-11-04T16:42:06Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @kelrit! I fixed this in #13.",
          "createdAt": "2019-11-04T16:17:38Z",
          "updatedAt": "2019-11-04T16:17:38Z"
        },
        {
          "author": "kelrit",
          "authorAssociation": "NONE",
          "body": "@chris-wood Off by one and kemID looks fixed but now it looks like the wrong algorithm is used - \r\nDHKEM(Curve25519) uses a 56 byte key (looks like Curve448?), DHKEM(P-256) appears to be a 25519 key, etc.",
          "createdAt": "2019-11-04T19:50:27Z",
          "updatedAt": "2019-11-04T19:50:27Z"
        },
        {
          "author": "kelrit",
          "authorAssociation": "NONE",
          "body": "Looks fixed with 4ae75616b42af5520cb88348e0ed5e456eee2815, thanks!",
          "createdAt": "2019-11-05T19:40:07Z",
          "updatedAt": "2019-11-05T19:40:14Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU1MTcyNzM5NTg=",
      "title": "Add an exporter",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/16",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It may be desirable to export a secret, as with the TLS exporter.  Adding such a feature would add a bit of complexity, and dilute the focus on PKE.",
      "createdAt": "2019-11-04T16:45:58Z",
      "updatedAt": "2020-01-20T16:26:12Z",
      "closedAt": "2020-01-20T16:26:12Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed by #27. @bifurcation, please re-open if that's not the case!",
          "createdAt": "2020-01-20T16:26:12Z",
          "updatedAt": "2020-01-20T16:26:12Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU1MTczMDg5OTQ=",
      "title": "KeySchedule notation issues",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/19",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current draft (looking at branch master):\r\n\r\ndef KeySchedule(mode, pkRm, zz, enc, info, psk, pskID, pkIm):\r\n  VerifyMode(mode, psk, pskID, pkI)\r\n\r\n  pkRm = Marshal(pkR)\r\npkRm is given as parameter to KeySchedule but is calculated from pkR inside (suggestion: remove the line calculating it)\r\npkI is passed to VerifyMode, should be pkIm.\r\n\r\nFrom @dwd and @blipp ",
      "createdAt": "2019-11-04T17:52:16Z",
      "updatedAt": "2020-01-23T17:21:15Z",
      "closedAt": "2020-01-23T17:21:15Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> pkRm is given as parameter to KeySchedule but is calculated from pkR inside (suggestion: remove the line calculating it)\r\n\r\nThis has since been fixed!\r\n\r\nThe other error still exists.",
          "createdAt": "2020-01-23T03:01:58Z",
          "updatedAt": "2020-01-23T03:01:58Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU1MjEwMzQ0NDQ=",
      "title": "Add negative test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/20",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The draft only has success test vectors. Negative ones would be good, too.",
      "createdAt": "2019-11-11T15:39:27Z",
      "updatedAt": "2020-10-17T15:38:44Z",
      "closedAt": "2020-10-17T15:38:44Z",
      "comments": []
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU1MjEyNTQ0MzU=",
      "title": "Inconsistent naming of mode AuthPSK",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/21",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Both the constant `mode_psk_auth` and function names like `SetupAuthPSKR` are used. That's inconsistent because the order of `psk` and `auth` is different. Suggestion: change the constant to be `mode_auth_psk`, because there are more function names that would need to be changed otherwise.",
      "createdAt": "2019-11-12T00:06:37Z",
      "updatedAt": "2020-01-23T17:20:23Z",
      "closedAt": "2020-01-23T17:20:23Z",
      "comments": []
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU1MjE2ODMzMzE=",
      "title": "Document security properties",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/22",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Pre-RGLC"
      ],
      "body": "For example, the base mode does not provide KCI resistance. ",
      "createdAt": "2019-11-12T17:11:33Z",
      "updatedAt": "2020-02-27T13:27:59Z",
      "closedAt": "2020-02-27T13:27:59Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "NONE",
          "body": "What would KCI mean in this setting? The sender is unauthenticated in the base case.\r\n",
          "createdAt": "2019-12-18T09:37:06Z",
          "updatedAt": "2019-12-18T09:37:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> What would KCI mean in this setting? The sender is unauthenticated in the base case.\r\n\r\nNot sure off-hand. We need to work on that! ",
          "createdAt": "2020-01-15T21:53:03Z",
          "updatedAt": "2020-01-15T21:53:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's park this until the analysis is done. We can fill out this section with better details at that point.",
          "createdAt": "2020-01-23T03:05:55Z",
          "updatedAt": "2020-01-23T03:05:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #44.",
          "createdAt": "2020-02-27T13:27:59Z",
          "updatedAt": "2020-02-27T13:27:59Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU1NTA0NTA4MzE=",
      "title": "Consider static DH oracles",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/28",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Do we need to be concerned about them? If receivers don't validate ephemeral keys (point on the curve, and in the right subgroup), what can go wrong?",
      "createdAt": "2020-01-15T21:53:46Z",
      "updatedAt": "2020-01-20T16:23:10Z",
      "closedAt": "2020-01-20T16:23:09Z",
      "comments": [
        {
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "body": "I don\u2019t believe this is relevant for HPKE. My understanding is that such attacks require an oracle for the static scalar multiplier, which is not prevent in the ECDH that HPKE performs.",
          "createdAt": "2020-01-16T02:51:55Z",
          "updatedAt": "2020-01-16T02:51:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that\u2019s correct \u2014 @blipp?",
          "createdAt": "2020-01-16T02:59:30Z",
          "updatedAt": "2020-01-16T02:59:30Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, that's my understanding as well, it's not relevant for HPKE.\r\n\r\nIf an initiator sends an HPKE message to an adversary-chosen public key, that's where the oracle would be \u2013 but it is not exposing the bare curve operation, it is wrapped into Extract and Expand.",
          "createdAt": "2020-01-20T16:17:32Z",
          "updatedAt": "2020-01-20T16:17:32Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! I'll close this and move the point validation question over to a separate issue (#30).",
          "createdAt": "2020-01-20T16:23:09Z",
          "updatedAt": "2020-01-20T16:23:09Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU1NTIzNjU5Nzg=",
      "title": "Clarify directionality of HPKE with multiple encryptions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/29",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "There's currently a single sequence number space that's incremented by 1 for each message encrypted. This implies that only the initiator can encrypt messages to the receiver, else we risk key/nonce re-use. We should be clear about this in the draft!",
      "createdAt": "2020-01-20T15:23:09Z",
      "updatedAt": "2020-01-24T15:36:44Z",
      "closedAt": "2020-01-24T15:36:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "To be clear, you could allow both initiator and receiver to send, e.g., if they used disjoint portions of the nonce space.  For example, in a lock-step protocol where each side replies to the other, you could safely share context, since you would never have collisions.  (In theory!)  In any case, thogh, you would need operational coordination to avoid collisions.\r\n",
          "createdAt": "2020-01-20T16:50:36Z",
          "updatedAt": "2020-01-20T16:51:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> In any case, thogh, you would need operational coordination to avoid collisions.\r\n\r\nYeah, absent discussion of this coordination, risk of collision seems high. ",
          "createdAt": "2020-01-20T16:52:55Z",
          "updatedAt": "2020-01-20T16:52:55Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU1NTIzOTg0NTA=",
      "title": "Point validation?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/30",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "If receivers don't validate ephemeral keys (point on the curve, and in the right subgroup), what can go wrong? An active and malicious initiator could, for example, use that to learn the responder's private key: https://safecurves.cr.yp.to/twist.html",
      "createdAt": "2020-01-20T16:22:38Z",
      "updatedAt": "2020-01-31T20:10:22Z",
      "closedAt": "2020-01-31T20:10:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #35.",
          "createdAt": "2020-01-31T20:10:22Z",
          "updatedAt": "2020-01-31T20:10:22Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU1Njg4MjcxMjk=",
      "title": "Length of PSKs in test vectors don't match with requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/41",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The PSKs used in the test vectors currently are of length 6 bytes but should be 32 bytes for HKDF-SHA256 and 64 bytes for HKDF-SHA512.",
      "createdAt": "2020-02-21T09:10:33Z",
      "updatedAt": "2020-02-28T14:35:28Z",
      "closedAt": "2020-02-28T14:35:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Heh, yeah. The psk currently used is:\r\n\r\n```\r\n[]byte(\"mellon\")\r\n```\r\n\r\nNot the best!",
          "createdAt": "2020-02-21T16:21:45Z",
          "updatedAt": "2020-02-21T16:21:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #45.",
          "createdAt": "2020-02-28T14:35:28Z",
          "updatedAt": "2020-02-28T14:35:28Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU1Njg4Mjg2ODU=",
      "title": "Nenc and Npk for P512 are inconsistent within the draft",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/42",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Section \u201cDH-Based KEM\u201d:\r\n\r\n```\r\n* P-521: The X-coordinate of the point, encoded as a 66-octet\r\n  big-endian integer\r\n```\r\n\r\nIn \u201cAlgorithm Identifiers\u201d > \u201cKey Encapsulation Mechanisms\u201d:\r\n\r\n```\r\n| Value  | KEM               | Nenc | Npk | Reference      |\r\n|:-------|:------------------|:-----|:----|:---------------|\r\n| 0x0012 | DHKEM(P-521)      | 65   | 65  | {{NISTCurves}} |\r\n```",
      "createdAt": "2020-02-21T09:13:44Z",
      "updatedAt": "2020-02-27T13:28:47Z",
      "closedAt": "2020-02-27T13:28:46Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #44 ",
          "createdAt": "2020-02-27T13:28:46Z",
          "updatedAt": "2020-02-27T13:28:46Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU1Njk1MDI5Njc=",
      "title": "Add CCM ciphersuites",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/43",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "... for use in ECHO.\r\n\r\nAES-GCM-128: https://tools.ietf.org/html/rfc5116\r\nAES-CCM-128 (8-byte IV): https://tools.ietf.org/html/rfc6655\r\n\r\nWe should reference where these AEADs are defined, too (5116 for GCM, 8439 for ChaCha20Poly1305).",
      "createdAt": "2020-02-23T14:24:22Z",
      "updatedAt": "2020-02-25T22:00:42Z",
      "closedAt": "2020-02-25T22:00:42Z",
      "comments": []
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU1NzI3OTA4MzI=",
      "title": "Add domain separation for expanded secrets",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/46",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently have none!",
      "createdAt": "2020-02-28T14:29:29Z",
      "updatedAt": "2020-03-20T14:36:31Z",
      "closedAt": "2020-03-20T14:36:31Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #47.",
          "createdAt": "2020-03-20T14:36:31Z",
          "updatedAt": "2020-03-20T14:36:31Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWU1NzgxNjY4NzU=",
      "title": "Mismatch on psk length for SHA256",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/52",
      "state": "CLOSED",
      "author": "R1kM",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the length of psk in the test vectors is the same for SHA256 and SHA512. As far as I can tell, psk should only contain 32 bytes for SHA256 instead of 64.\r\nAdditionally, psk, pskID and pkS are not needed in the Base setup (https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#base-setup-information for instance)",
      "createdAt": "2020-03-09T20:21:10Z",
      "updatedAt": "2020-05-07T12:20:49Z",
      "closedAt": "2020-05-07T12:20:48Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> At the moment, the length of psk in the test vectors is the same for SHA256 and SHA512. As far as I can tell, psk should only contain 32 bytes for SHA256 instead of 64.\r\n\r\nThe length of the PSK is not required to match the KDF. I hope we clarified that in the current version: https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-authentication-using-a-pre-\r\n\r\n> Additionally, psk, pskID and pkS are not needed in the Base setup (https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#base-setup-information for instance)\r\n\r\nGood catch! I'll use this issue to track removing them from those modes. ",
          "createdAt": "2020-04-10T21:05:09Z",
          "updatedAt": "2020-04-10T21:05:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed now. Closing!",
          "createdAt": "2020-05-07T12:20:48Z",
          "updatedAt": "2020-05-07T12:20:48Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU1ODAxNjQyNzU=",
      "title": "Mismatch on zz length for P-256",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/53",
      "state": "CLOSED",
      "author": "R1kM",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`zz`, as computed by `Decap`, is indicated to have length `Npk` https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#dh-based-kem.\r\nThis does not match the length of the test vector provided for P-256 https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#base-setup-information-2",
      "createdAt": "2020-03-12T19:15:52Z",
      "updatedAt": "2020-04-10T21:01:13Z",
      "closedAt": "2020-04-10T21:01:13Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "`zz` has length `Nzz`, which is the \"length in bytes of a shared secret produced by\" a KEM, and is equal to 32 for P-256: https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-key-encapsulation-mechanism\r\n\r\nThe length in the test vector referenced is 32B (unless I'm misreading), so I'm closing this as resolved. Please re-open if I made a mistake!",
          "createdAt": "2020-04-10T21:01:13Z",
          "updatedAt": "2020-04-10T21:01:13Z"
        }
      ]
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU2MTM2MTU3NDA=",
      "title": "Updated test vectors do not match the spec",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/66",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While updating labels for draft-03, I noticed that the test vectors added in 5bc57ba5753f6e76d6350e532c1ca069ac8b228c seem to be incorrect, matching an implementation that:\r\n\r\n1) Uses the label \"info_hash\" to extract `info_hash`, when draft-03 specifies \"info\".\r\n2) Uses the label \"psk\" to extract `psk`, when \"psk_hash\" is specified.  \r\n\r\nWith the \"_hash\" suffix swapped as above, my implementation generates matching outputs. ",
      "createdAt": "2020-05-06T21:11:13Z",
      "updatedAt": "2020-05-08T19:28:37Z",
      "closedAt": "2020-05-08T19:28:37Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Will fix -- thanks!",
          "createdAt": "2020-05-06T23:47:16Z",
          "updatedAt": "2020-05-06T23:47:16Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU2MTM2Mjk2MjI=",
      "title": "Ambiguous Nzz definition, possible wrong value for P-521",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/67",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Table 7.1 specifies an Nzz value of 64 for _DHKEM(P-521, HKDF-SHA512)_. The test vectors are using a value of 66, which seems right given:\r\n\r\n> Nzz: The length in bytes of a shared secret produced by the algorithm.\r\n\r\n(in context of KEM identifiers, not KDF).\r\n\r\nBut, 4.1 also states:\r\n\r\n> For the variants of DHKEM defined in this document, Ndh is equal to Npk, and the output length of the KDF's Extract function is Nzz bytes.\r\n\r\nWe should clarify whether Nzz is based on the ECDH or HKDF-Extract output length, and fix the test vectors if necessary.\r\n",
      "createdAt": "2020-05-06T21:38:37Z",
      "updatedAt": "2020-05-08T19:28:30Z",
      "closedAt": "2020-05-08T19:28:30Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch. It should be 66. I think we fat fingered the calculation :-)\r\n\r\n   (512 + 7) >> 3 = 64\r\n\r\nThanks!",
          "createdAt": "2020-05-06T23:59:36Z",
          "updatedAt": "2020-05-06T23:59:36Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The values for `Nzz` were chosen to be the same as the output length of the hash function underlying the KDF used in the variants of DHKEM. In `DHKEM(P-521, HKDF-SHA512)`, the KDF is `HKDF-SHA512` with the hash function `SHA512`, which has output length 64 bytes.\r\n\r\nThus, as one of the possibilities mentioned by @kjacobs-moz , `Nzz` is based on the HKDF-Extract output length. That is because HKDF-Extract is exactly _one_ call to HMAC and returns its result; HMAC's output length is the output length of the underlying hash function. HKDF-Expand has variable output length, that is why it would not make sense to define Nzz via HKDF-Expand's output length, but rather we need to define HKDF-Expand's output length by Nzz.\r\n\r\nWhile a P-521 DH shared secret might justify, from a security level point of view, a KEM shared secret a bit longer than 64 bytes, I believe it is beneficial to keep it at 64 bytes because then HKDF-Expand is exactly _one_ call to HMAC. With 66 bytes, or 65 bytes, we would need an entire second call to HMAC, only to gain one byte. Also, because the KeySchedule continues with SHA512 as well, we do not benefit from the slightly higher security level, I think.\r\n\r\nTo conclude, I believe we should keep the 64 as it is.\r\n\r\nHaving written this, I admit that it took me a bit to understand what we meant with the sentence \u201cand the output length of the KDF's Extract function is Nzz bytes\u201d. While it is clearly true for the specified variants of DHKEM, it is a confusing formulation. Maybe we can come up with something better. (Edited to add: I just made a proposal in the discussion of #68.)",
          "createdAt": "2020-05-07T06:56:06Z",
          "updatedAt": "2020-05-07T07:11:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hah! We all misunderstood that sentence. It didn't occur to me that the intention was to make `Nzz` match the size of HKDF-Extract based on text. Your proposal in #68 clears that up. I'll fix the code, update that PR, and send over new test vectors for folks to try. ",
          "createdAt": "2020-05-07T12:02:31Z",
          "updatedAt": "2020-05-07T12:02:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #68!",
          "createdAt": "2020-05-07T12:19:55Z",
          "updatedAt": "2020-05-07T12:19:55Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU2MTM2OTc3MjE=",
      "title": "Unnecessary return value in Decap(), AuthDecap()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/69",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The spec definition of `Decap()` includes taking `enc` as a parameter, and returning it unmodified: \r\n\r\n```\r\n   def Decap(enc, skR):\r\n     pkE = Unmarshal(enc)\r\n     dh = DH(skR, pkE)\r\n\r\n     pkRm = Marshal(pk(skR))\r\n     kemContext = concat(enc, pkRm)\r\n\r\n     zz = ExtractAndExpand(dh, kemContext)\r\n     return zz, enc\r\n```\r\n\r\nOnly `return zz` is needed. The same applies to AuthDecap. ",
      "createdAt": "2020-05-07T00:44:17Z",
      "updatedAt": "2020-05-08T19:28:23Z",
      "closedAt": "2020-05-08T19:28:23Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good catch, thanks! @chris-wood , do you want to incorporate this into #68 ?",
          "createdAt": "2020-05-07T07:01:01Z",
          "updatedAt": "2020-05-07T07:01:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, will do!",
          "createdAt": "2020-05-07T12:18:19Z",
          "updatedAt": "2020-05-07T12:18:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Added to #68.",
          "createdAt": "2020-05-07T12:19:40Z",
          "updatedAt": "2020-05-07T12:19:40Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU2MTUyMzI3ODQ=",
      "title": "pkSm does nothing in KeySchedule",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/71",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I was looking through a code coverage map of my implementation and realized that `default_pkSm` is never actually used anywhere. `KeySchedule` takes in a `pkSm` and uses it to sanity-check the given `mode`, and then uses it nowhere in the key schedule itself. Should `pkSm` be removed as an argument?",
      "createdAt": "2020-05-09T18:17:57Z",
      "updatedAt": "2020-05-20T14:29:13Z",
      "closedAt": "2020-05-20T14:29:13Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It's there primarily to help distinguish the mode, so I think we ought to keep it. That said, it might encourage implementations to pass it when not needed. \r\n\r\nIf you were to remove it, how would you specify the mode check?",
          "createdAt": "2020-05-12T12:56:43Z",
          "updatedAt": "2020-05-12T12:56:43Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, if you want to keep it in I don't have any strong suggestions to make it more elegant. FWIW I found it more ergonomic to implement `mode` as an enum that contains precisely the things it needs to\r\n\r\n```rust\r\nenum OpModeR<Dh: DiffieHellman, Kd: Kdf> {\r\n    Base,\r\n    Psk(PskBundle<Kd>),\r\n    Auth(Dh::PublicKey),\r\n    AuthPsk(Dh::PublicKey, PskBundle<Kd>),\r\n}\r\n```",
          "createdAt": "2020-05-12T16:14:25Z",
          "updatedAt": "2020-05-12T16:14:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, I would suspect most folks to implement it this way. \r\n\r\n@bifurcation, this seems editorial. Do you have a preference here?",
          "createdAt": "2020-05-15T14:54:22Z",
          "updatedAt": "2020-05-15T14:54:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think `pkSm` can be removed.  The only thing it signals is that you're in an authenticated mode, which the `mode` argument already indicates.  You could then also simplify `VerifyMode` to something like:\r\n\r\n```\r\ndef VerifyPSKInputs(mode, psk, pskID):\r\n  got_psk = (psk != default_psk)\r\n  if got_psk != (pskID != default_pskID):\r\n    raise Exception(\"Inconsistent PSK inputs\")\r\n\r\n  if got_psk and (mode in [mode_base, mode_auth]):\r\n    raise Exception(\"PSK input provided when not needed\")\r\n  if not got_psk and (mode in [mode_psk, mode_auth_psk]):\r\n    raise Exception(\"Missing required PSK input\")\r\n```\r\n\r\nI agree that most languages will have more elegant constructs (inlcuding python), but the spec needs to be language agnostic.",
          "createdAt": "2020-05-17T20:15:24Z",
          "updatedAt": "2020-05-17T20:15:24Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWU2MTYxMTI1NjI=",
      "title": "Contents of a context aren't well-defined",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/72",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This is just an editorial comment. The spec doesn't seem to define the contents of a \"context\" very clearly. Section 5 says:\r\n> A \"context\" encodes the AEAD algorithm and key in use, and manages the nonces used so that the same nonce is not used with multiple plaintexts.\r\n\r\nBut it also has an exporter secret. Then section 5.1 says:\r\n> return Context(key, nonce, exporter_secret)\r\n\r\nBut we haven't defined the `Context` function yet. I'm guessing the intent is that `Context` produces some sort of record type with those field names? But that wouldn't initialize `Context.seq` used later in 5.2. (Confusingly, this `Context` is distinct from the `context` variable which contains an `HPKEContext` structure. Maybe the latter could be renamed?)\r\n\r\nThen 5.2 lists out the contents of a \"context' more explicitly, including the first mention of a sequence number. But it omits the exporter secret again. (Should \"The sender's context MUST be used for encryption only. Similarly, the recipient's context MUST be used for decryption only.\" be rephrased? One could read that as saying export is also not okay.)\r\n\r\nThen 5.3 mentions a context having an \"exporter secret\", but this is actually the only instance of that phrase in the document.",
      "createdAt": "2020-05-11T19:05:28Z",
      "updatedAt": "2020-05-27T21:44:54Z",
      "closedAt": "2020-05-27T21:44:53Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with `Context` being somewhat confusing. I propose to rename it to `AEADContext` and clearly define the attributes (key, nonce, exporter, secret).",
          "createdAt": "2020-05-14T16:21:06Z",
          "updatedAt": "2020-05-14T16:21:06Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "NONE",
          "body": "The \"context\" does seem to be related to the entire HPKE exchange from how it's constructed. Since AEADs already mean something, AEADContext would probably result in APIs calling it `HPKE_AEAD_CONTEXT` with nothing actually exposed as `HPKE_CONTEXT`. Seems renaming the existing HPKEContext would work better.",
          "createdAt": "2020-05-14T17:14:49Z",
          "updatedAt": "2020-05-14T17:14:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:44:53Z",
          "updatedAt": "2020-05-27T21:44:53Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWU2MTg3ODMzODc=",
      "title": "Outdated reference",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/74",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In \"DH-Based KEM\" the paragraph \r\n\r\n> The GenerateKeyPair, Marshal, and Unmarshal functions are the same as for the underlying DH group. The Marshal functions for the curves referenced in {#ciphersuites} are as follows:\r\n\r\nreferences the #ciphersuites section that no longer seems to exist.",
      "createdAt": "2020-05-15T08:12:10Z",
      "updatedAt": "2020-05-19T15:35:35Z",
      "closedAt": "2020-05-19T15:35:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed a change directly to master to fix this. Thanks!",
          "createdAt": "2020-05-19T15:35:35Z",
          "updatedAt": "2020-05-19T15:35:35Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWU2MTkwMTU0MjM=",
      "title": "Shared secret size for P-256",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/75",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's currently 32 bytes, i.e., just the x-coordinate of the point. But Npk suggests it should be a fully-encoded public key. Which do we prefer?\r\n\r\ncc @blipp @bifurcation \r\n\r\n(Thanks to Michael Scott for raising this!)",
      "createdAt": "2020-05-15T14:37:46Z",
      "updatedAt": "2020-05-19T15:35:57Z",
      "closedAt": "2020-05-19T15:35:57Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "No opinion.  If 65 bytes is more consistent with other modes, that's fine.  ",
          "createdAt": "2020-05-17T20:04:47Z",
          "updatedAt": "2020-05-17T20:04:47Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's use the encoded public keys, then, and update the test vectors!",
          "createdAt": "2020-05-18T13:47:36Z",
          "updatedAt": "2020-05-18T13:47:36Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that `dh` should be understood as being a marshalled curve point that was returned by `DH` (if the marshal is done internally in `DH` or afterwards depends on the implementation I guess) \u2013 at least that's what I had in mind when working on my pull requests to the draft. Should we clarify it in the text?\r\n\r\nEdited to add: I should clarify that in the authenticated modes, `dh` is a concatenation of two marshalled curve points.",
          "createdAt": "2020-05-19T13:31:58Z",
          "updatedAt": "2020-05-19T13:33:38Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I added pull request #80 in an attempt to clarify some occurrences of Ndh and Nzz.",
          "createdAt": "2020-05-19T14:53:54Z",
          "updatedAt": "2020-05-19T14:53:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #78 and #80. Closing.",
          "createdAt": "2020-05-19T15:35:57Z",
          "updatedAt": "2020-05-19T15:35:57Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWU2MTkwMTgyMTQ=",
      "title": "ExtractAndExpand input parameters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/76",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Michael Scott:\r\n\r\n> A minor observation. In ExtractAndExpand the salt parameter is zero(Nh).\r\n>\r\n> In fact this is the same as using zero(0), as HMAC internally pads this up to a blocksize of zeros.\r\n>\r\n> So for example if using SHA512 and Nh=64, the hash blocksize is 128, and zero(0) gets padded up to 128 zeros, as does zero(64) . In fact the parameter to zero(.) is irrelevant.\r\n\r\nWe might consider `zero(2*Nh)` or `zero(0)`. What do you think, @blipp?",
      "createdAt": "2020-05-15T14:40:16Z",
      "updatedAt": "2020-05-20T15:08:03Z",
      "closedAt": "2020-05-20T15:08:03Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The observation is only true for HKDF, not necessarily for other KDFs.  For similar reasons, we shouldn't do `zero(2*Nh)`.\r\n\r\nThat said, it doesn't really seem like the salt is adding anything, so I would be fine with `zero(0)` or `\"\"` or however we want to write it.",
          "createdAt": "2020-05-17T20:22:12Z",
          "updatedAt": "2020-05-17T20:22:12Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with using something like `zero(0)` or `\"\"` to make clear that we want to \u201cnot provide\u201d the salt value, like [RFC 5869 (HKDF)](https://hyp.is/PvmompnREeq4Ddvtm_Is0w/tools.ietf.org/html/rfc5869) formulates it:\r\n\r\n```\r\n2.2.  Step 1: Extract\r\n\r\n[\u2026]\r\n\r\n   Inputs:\r\n      salt     optional salt value (a non-secret random value);\r\n               if not provided, it is set to a string of HashLen zeros.\r\n      IKM      input keying material\r\n```\r\n\r\nI think `zero(0)` would be good, because we use this as the default pskID, too.",
          "createdAt": "2020-05-19T13:13:57Z",
          "updatedAt": "2020-05-19T13:13:57Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWU2MTkwOTU0MjY=",
      "title": "Caveat in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/77",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The plaintext is always the same, but the nonces and AADs differ by just one bit, which is hard to spot and easily missed.",
      "createdAt": "2020-05-15T16:26:54Z",
      "updatedAt": "2020-05-23T23:44:57Z",
      "closedAt": "2020-05-23T23:44:57Z",
      "comments": []
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU2MjE0ODc1NzI=",
      "title": "Ambiguity about Secret Export",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/83",
      "state": "CLOSED",
      "author": "ocheron",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "Section 5.3 explains secrets are exported with the KDF Expand function but the included code in the same section now calls LabeledExpand with a \"sec\" label.\r\n\r\nThe JSON test vectors contain sample results for the export function, but they match an unlabeled implementation with Expand and not LabeledExpand.",
      "createdAt": "2020-05-20T06:09:46Z",
      "updatedAt": "2020-05-28T17:39:15Z",
      "closedAt": "2020-05-27T21:44:44Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch! We missed updating the `Export` code and test vectors. ",
          "createdAt": "2020-05-24T00:30:03Z",
          "updatedAt": "2020-05-24T00:30:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:44:44Z",
          "updatedAt": "2020-05-27T21:44:44Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "Thank you, now all vectors pass with expected definitions.\r\nText will be clear enough, I just wasn't sure the direction you wanted.",
          "createdAt": "2020-05-28T17:39:15Z",
          "updatedAt": "2020-05-28T17:39:15Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU2MjE4NDMxMzQ=",
      "title": "Guidance for future KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/84",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nAs guidance for future revisions, we would recommend adding a section about the issues that need to be considered when adding support for other KEMs. There will presumably be industry interest in including post-quantum KEMs (as anticipated in Sec. 8.1), and there may also be interest in including RSA-based KEMs, for legacy support.  The technical subtleties in adding such mechanisms include:\r\n\r\n- Assumptions about the relationship between the private key and the public key and the definition of the \"pk()\" function.  For instance, GenerateKeyPair, listed as part of a KEM in Section 4, doesn't really need to be part of one (it's not part of RSA-KEM).\r\n\r\n- Assumptions about the length of the public key.  It may not always be a fixed value, \"Npk\", for a KEM with a given set of parameters.  The other (and unrelated) \"hybrid\" draft, draft-ietf-tls-hybrid-design, Section 3.2 ,makes accommodation for public keys associated with a given set of parameters to vary in size.",
      "createdAt": "2020-05-20T15:11:11Z",
      "updatedAt": "2020-10-22T17:19:35Z",
      "closedAt": "2020-10-22T17:19:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #131.",
          "createdAt": "2020-10-22T17:19:34Z",
          "updatedAt": "2020-10-22T17:19:34Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU2MjE4NDM0MDU=",
      "title": "Clarify DH-only KEMs in the abstract ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/85",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nThe draft only specifies a Diffie-Hellman-based KEM (Section 4.1). To set expectations for the implementer, we recommend stating this limitation in the abstract, e.g., by adding \"based on elliptic curve Diffie-Hellman key agreement\" at the end of the last sentence of the abstract.",
      "createdAt": "2020-05-20T15:11:31Z",
      "updatedAt": "2020-05-27T21:41:45Z",
      "closedAt": "2020-05-27T21:41:45Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:41:45Z",
          "updatedAt": "2020-05-27T21:41:45Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWU2MjE4NDM4ODk=",
      "title": "Clarify \"hybrid\" in the introduction",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/86",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nAsymmetric and symmetric algorithms have been combined since the 1980s, e.g., in Privacy-Enhanced Mail [RFC1113], so a hybrid approach (in the sense of combining the two) can by now be considered the \"tradition\" of public-key cryptography.  We would therefore suggest replacing the first sentence with the following:\r\n\r\nEncryption schemes that combine asymmetric and symmetric algorithms have been specified and practiced since the early days of public-key cryptography (e.g., [RFC1113]).  Combining the two brings the \"best of both worlds\":  the key management advantages of asymmetric cryptography and the performance benefits of symmetric cryptography.  However, the traditional combination has been \"encrypt the symmetric key with the public key.\"  \"Hybrid\" public-key encryption schemes (HPKE), specified here, take a different combination, \"generate the symmetric key and its encapsulation with the public key.\" .",
      "createdAt": "2020-05-20T15:12:09Z",
      "updatedAt": "2020-05-27T21:43:18Z",
      "closedAt": "2020-05-27T21:43:18Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:43:18Z",
          "updatedAt": "2020-05-27T21:43:18Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU2MjE4NDQwODM=",
      "title": "Clarify \"formally verified\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/87",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nShould \"formally verified\" be \"proven secure under standard cryptographic assumptions\"?  Or is the intent indeed to enable tools that check correctness of an implementation?",
      "createdAt": "2020-05-20T15:12:25Z",
      "updatedAt": "2020-05-27T21:42:11Z",
      "closedAt": "2020-05-27T21:42:10Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:42:10Z",
          "updatedAt": "2020-05-27T21:42:10Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU2MjE4NDQ0NjU=",
      "title": "Clarify unsigned property of encode_big_endian",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/88",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 3:  Definition of encode_big_endian:  Add \"unsigned\" before \"integer\" if this is the intent (so that the set of encodable n-byte integers clearly includes 0 through 2^{8n}-1).",
      "createdAt": "2020-05-20T15:12:55Z",
      "updatedAt": "2020-05-27T21:42:18Z",
      "closedAt": "2020-05-27T21:42:17Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:42:17Z",
          "updatedAt": "2020-05-27T21:42:17Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU2MjE4NDUyNTc=",
      "title": "Clarify additional key material in authenticated modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/89",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 5:\r\n \"we include two authenticated variants .\":  We would also suggest mentioning that these variants also contribute additional keying material to the encryption operation.  See also discussion in Section 8.1.\r\n\r\nAfter the sentence, \"the constructions described here presume .\", mention that the recipient also needs a way to determine which of its public keys was used for the encapsulation operation (if the recipient has more than one public key).  Also add a reference to Section 9 which addresses the corresponding issues for message encoding.",
      "createdAt": "2020-05-20T15:13:56Z",
      "updatedAt": "2020-05-27T21:44:08Z",
      "closedAt": "2020-05-27T21:44:07Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:44:07Z",
          "updatedAt": "2020-05-27T21:44:07Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU2MjE4NDU4NTA=",
      "title": "Include mode as KeySchedule input",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/90",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 5.1:\r\n\r\n \"mode\" should also be listed as a key schedule input.",
      "createdAt": "2020-05-20T15:14:41Z",
      "updatedAt": "2020-05-27T21:43:10Z",
      "closedAt": "2020-05-27T21:43:10Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:43:10Z",
          "updatedAt": "2020-05-27T21:43:10Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU2MjE4NDcyMTI=",
      "title": "Fix some nits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/91",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\n \"assumed that the sender\" --> \"assured that the sender\"\r\n\r\nSection 8.2:\r\n\r\n\"KEM public key pkR\" --> \"KEM public key \"pkR\"\"\r\n\r\n\"ciphertext enc\" --> \"encapsulated key enc\" (two occurrences).  \"Ciphertext\" is used elsewhere in the draft to refer to the AEAD output.\r\n\r\nSection 8.3:  There is a non-normative (lower-case) \"should\" in the first sentence.  (Contrasting against a normative/upper-case \"SHOULD\" in the first sentence of 8.4.)  Should this \"should\" be \"SHOULD\"?\r\n\r\nSection 8.7:  There are missing quotes around \"(enc2, ciphertext2, enc, ciphertext)\".",
      "createdAt": "2020-05-20T15:16:28Z",
      "updatedAt": "2020-05-27T21:42:03Z",
      "closedAt": "2020-05-27T21:42:03Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:42:03Z",
          "updatedAt": "2020-05-27T21:42:03Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWU2MjE4NDc0MjI=",
      "title": "Harmonize label values",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/92",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nThe \"label\" argument to LabeledExtract is being used in some cases to identify the output, in one case to identify the input, and in one case to identify the intent.  We suggest harmonizing on the former, and also consistently suffixing the output variable name with \"_hash\" when the purpose of the extraction is to produce a hash of the input.  This would result in the following statements being updated:\r\n\r\ninfo_hash = LabeledExtract(zero(Nh), \"info_hash\", info) // new label\r\n\r\npsk_hash = LabeledExtract(zero(Nh), \"psk_hash\", psk) // new output name\r\n\r\nsecret = LabeledExtract(psk_hash, \"secret\", zz) // new input name and label",
      "createdAt": "2020-05-20T15:16:46Z",
      "updatedAt": "2020-05-27T21:41:57Z",
      "closedAt": "2020-05-27T21:41:56Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:41:56Z",
          "updatedAt": "2020-05-27T21:41:56Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWU2MjE4NDgwNTQ=",
      "title": "Avoid confusing normative language",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/93",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 5.1.3: The lower-case \"must\" in \"the sender must be the other\" might be confused with normative \"MUST\".  Suggest using a different word or changing to the normative form.",
      "createdAt": "2020-05-20T15:17:30Z",
      "updatedAt": "2020-05-27T21:41:22Z",
      "closedAt": "2020-05-27T21:41:22Z",
      "comments": []
    },
    {
      "number": 94,
      "id": "MDU6SXNzdWU2MjE4NDg4MTU=",
      "title": "Clarify pseudocode and define undefined operands",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/94",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 5.2.:\r\n\r\nThe symbol \"<<\" isn't defined, but assuming it means \"shift left by a specified number of bits\", the number of bits to shift should be \"8*Nn\" rather than \"Nn\".\r\n\r\nDoes \"overflow\" in the third paragraph refer to the same condition as \"wrap\" in the fifth paragraph?  If so, the text should be combined and a single term used for consistency.  If not, the differences between the two requirements should be explained.  We would also suggest adding a note indicating that the reference code assumes the sequence number is the same length as the nonce.\r\n\r\nThe use of \"Nonce\" (capitalized) as a function and \"nonce\" (lower case) as a value may be confusing.  We suggest instead that the function be named \"ComputeNonce\" or similar.\r\n\r\nOn a similar object-oriented programming note, it should be stated that the underlying \"Seal\" and \"Open\" functions are the ones determined by the  \"aead_id\" property.",
      "createdAt": "2020-05-20T15:18:29Z",
      "updatedAt": "2020-05-27T21:41:15Z",
      "closedAt": "2020-05-27T21:41:15Z",
      "comments": []
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWU2MjE4NDk0MDQ=",
      "title": "Fix some references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/95",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\n[ANSI]:  Add \"X9.63\" to title.\r\n\r\n[BNT19] and other references as needed:  Add authors' names.\r\n\r\n[MAEA10]:  Use \"authoritative\" URI for long-term stability: https://ieeexplore.ieee.org/abstract/document/5604194/.",
      "createdAt": "2020-05-20T15:19:13Z",
      "updatedAt": "2020-05-27T21:41:51Z",
      "closedAt": "2020-05-27T21:41:50Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:41:50Z",
          "updatedAt": "2020-05-27T21:41:50Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWU2MjE4NTA2MjY=",
      "title": "Clarify test vector labels",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/96",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nAppendix:  \"pkR\", \"pkS\" values are given.  These are presumably the same as the marshalled versions \"pkRm\", \"pkSm\", this should be stated for completeness.  (In contrast, both \"pKE\" and the equivalent \"enc\" are shown.)",
      "createdAt": "2020-05-20T15:20:50Z",
      "updatedAt": "2020-05-27T21:42:48Z",
      "closedAt": "2020-05-27T21:42:47Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #101.",
          "createdAt": "2020-05-27T21:42:47Z",
          "updatedAt": "2020-05-27T21:42:47Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWU2MjE4NTA5NjI=",
      "title": "Cite Shoup for identity misbinding prevention in 8.2",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/97",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\n \"avoid identity mis-binding issues\":  Perhaps also note that including the public key and the encapsulated key as inputs to key derivation can help with the security proof.  [Shoup] makes this observation in Section 15.6.1.\r\n\r\n[Shoup]  @article{shoup2001proposal,\r\n  title={A proposal for an ISO standard for public key encryption (version 2.1)},\r\n  author={Shoup, Victor},\r\n  journal={IACR e-Print Archive},\r\n  volume={112},\r\n  year={2001}\r\n}\r\n",
      "createdAt": "2020-05-20T15:21:19Z",
      "updatedAt": "2020-05-27T21:41:08Z",
      "closedAt": "2020-05-27T21:41:08Z",
      "comments": []
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWU2MjE4NTEzNjU=",
      "title": "Add some color to post quantum proof discussion",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/98",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From https://mailarchive.ietf.org/arch/msg/cfrg/ZcTCJkilzCDshxsIj7MwKHNlNuM/\r\n\r\nSection 8.1:  \"A full proof of post-quantum security .\".  Although we understand that a full proof of post-quantum security may not be achievable within the timeline of this draft's publication, we would nevertheless recommend some additional discussion on what might be desirable to prove.  In the draft, the PSK is employed as an authentication factor, so presumably the proof being contemplated would be that authentication in the modes involving PSKs remains secure against a quantum computer.  A stronger property would be more attractive:  that encryption in the PSK modes remains secure against a quantum computer, whether the KEM itself is post-quantum or not.  If the authors consider this property plausible, then it should be mentioned here as a goal for security analysis.  If not, then the reasons for not targeting this property should also be given.\r\n\r\n",
      "createdAt": "2020-05-20T15:21:50Z",
      "updatedAt": "2020-06-26T21:41:23Z",
      "closedAt": "2020-06-26T21:41:22Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These are some excellent points!\r\n\r\n### PSK is also strengthening confidentiality\r\nIndeed we are only talking about authentication with respect to the PSK:\r\n* [Creating the Encryption Context](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#creating-the-encryption-context)\r\n```\r\nIf the psk and pskID arguments are provided, then the recipient is\r\nassured that the sender held the PSK.\r\n```\r\n* [Authentication using a Pre-Shared Key](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#authentication-using-a-pre-shared-key-mode-psk) and [Authentication using both a PSK and an Asymmetric Key](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#authentication-using-both-a-psk-and-an-asymmetric-key-mode-auth-psk)\r\n```\r\nThis variant extends the base mechanism by allowing the recipient to\r\nauthenticate that the sender possessed a given pre-shared key (PSK).\r\n```\r\n\r\nThe analysis I did in CryptoVerif shows that confidentiality remains if the KEM keys are compromised (or if the KEM keys are not compromised but the PSK is compromised). So we should indeed add this as a desired security property, with pretty much the same reasoning as employed by WireGuard, see [Section 5.2 in the WireGuard whitepaper](https://hyp.is/eMrNnKHTEeqR-TeuWEsFDA/www.wireguard.com/papers/wireguard.pdf).\r\n\r\n### Authentication provided by PSK in quantum setting\r\nIn the same way, the analysis shows that authentication remains if KEM keys are compromised, or if the PSK is compromised but not the KEM keys.\r\n\r\nSo, in a way, this is just about discussing desired security properties in different compromise cases, where certain compromise cases are especially relevant because of quantum adversaries.\r\n\r\n### Minor nit\r\nBy the way, in [Security Properties](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#security-properties-sec-properties), we should add that the PSK mode is also providing sender authentication.\r\n```\r\nSender authentication: Proof of sender origin for Auth and AuthPSK modes\r\n```\r\nLater, in [Metadata Protection](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#metadata-protection), PSK mode is correctly listed as authenticated mode.\r\n```\r\nThe authenticated modes of HPKE (PSK, Auth, AuthPSK) require [\u2026]\r\n```\r\n\r\nI'll try to find time to draft a pull request.",
          "createdAt": "2020-05-29T17:50:19Z",
          "updatedAt": "2020-05-29T17:50:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #119.",
          "createdAt": "2020-06-26T21:41:22Z",
          "updatedAt": "2020-06-26T21:41:22Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWU2MjIwNzk1ODM=",
      "title": "Inconsistent use of X25519 vs Curve25519",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/100",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The HPKE draft refers to \"Curve25519\" and \"DHKEM(Curve25519, HKDF-SHA256)\" throughout the draft, but then section 8.8 mentions DHKEM-X25519.\r\n\r\nI believe X25519 is correct here. RFC7748 defines \"curve25519\" as a particular Montgomery curve. It then defines \"X25519\" as a Diffie-Hellman primitive on top of curve25519, with particular encodings and everything else. HPKE is using the Diffie-Hellman primitive, so it should use X25519. As a bonus, it's shorter and \"DHKEM(Curve25519, HKDF-SHA256)\" is already a mouthful. :-)",
      "createdAt": "2020-05-20T20:56:34Z",
      "updatedAt": "2020-06-03T15:35:56Z",
      "closedAt": "2020-05-27T21:40:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, we mean X25519 -- thanks for pointing this out!",
          "createdAt": "2020-05-23T14:13:01Z",
          "updatedAt": "2020-05-23T14:13:01Z"
        },
        {
          "author": "dvorak42",
          "authorAssociation": "NONE",
          "body": "Looks like the section labels for the test vectors didn't get updated? (They still read DHKEM(Curve25519...))",
          "createdAt": "2020-06-03T13:56:24Z",
          "updatedAt": "2020-06-03T13:56:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dvorak42 doh! I missed that. Thanks for pointing it out. I'll update the labels in a future change.",
          "createdAt": "2020-06-03T15:35:56Z",
          "updatedAt": "2020-06-03T15:35:56Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWU2Mjc4ODcxNDc=",
      "title": "Limits on Inputs to LabeledExtract and LabeledExpand",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/102",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm trying to remove all allocation from my implementation, and there's really only 1 snag I'm hitting: LabeledExtract and LabeledExpand do a `concat` operation before passing to their respective HKDF functions, and there isn't always an upper bound on the size of the concatenated result. Specifically, there's\r\n```\r\nKeySchedule(info, psk, pskID):\r\n    LabeledExtract(..., info)\r\n    LabeledExtract(..., psk)\r\n    LabeledExtract(..., pskID)\r\nContext.Export(exporter_context):\r\n    LabeledExpand(..., exporter_context, ...)\r\n```\r\n\r\nIf there were a (reasonably small) upper bound on the sizes of `info`, `psk`, `pskID`, and `exporter_context`, then it would be trivial to implement HPKE without allocation.\r\n\r\nI've thought about \"streaming\" the input into the above functions, instead of sending a concatenated bytestring. This could theoretically work for HKDF-Extract with SHA256, since it's an MD hash, but this doesn't work generically. Also the definition of HKDF-Expand does not admit a way to stream in the `info` string.",
      "createdAt": "2020-05-31T04:08:40Z",
      "updatedAt": "2020-06-17T23:39:03Z",
      "closedAt": "2020-06-17T23:39:02Z",
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A side effect of this would be that the `Psk` and `PskBundle` (containing a PSK and PSK ID) types in the Rust implementation would not need to allocate and also not need cumbersome lifetime specifiers, since they could just maintain a fixed-size buffer of their contents.",
          "createdAt": "2020-05-31T04:39:12Z",
          "updatedAt": "2020-05-31T04:39:45Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "What would be \"reasonably small\" here? TLS allows 16-bit PSK identities and exported contexts, for example. ",
          "createdAt": "2020-05-31T13:26:21Z",
          "updatedAt": "2020-05-31T13:26:21Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If `pskID` were 2 bytes (or an integer that we explicitly encode) and everything else were at most size `Nh`, that would be sufficient",
          "createdAt": "2020-05-31T16:48:27Z",
          "updatedAt": "2020-05-31T16:48:27Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Adding the following just so that we remember that in case we introduce limits: If in the end the PSK's size is limited to smth strictly smaller than `Nb` (block size of underlying hash function), we could get rid of the hashing step for the PSK.",
          "createdAt": "2020-06-02T13:26:59Z",
          "updatedAt": "2020-06-02T13:26:59Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Update: this change may not be necessary. It shouldn't be hard to get HKDF-Expand and HKDF-Extract to work this way without allocating.\r\n\r\nWaiting on https://github.com/RustCrypto/KDFs/pull/34",
          "createdAt": "2020-06-07T21:14:30Z",
          "updatedAt": "2020-06-07T21:14:30Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "KDF PR got merged. This is no longer an issue.",
          "createdAt": "2020-06-17T23:39:02Z",
          "updatedAt": "2020-06-17T23:39:02Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWU2MzAxNTg0NzY=",
      "title": "Typo for Single-Shot and clarification on AEAD binding to Context.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/103",
      "state": "CLOSED",
      "author": "dvorak42",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In section 5.1, might be useful to have return KeySchedule/Context take in the AEAD, to make it clear that a Context is bound to a particular AEAD.\r\nIn section 6, Seal<MODE> calls Setup<MODE>I instead of Setup<MODE>S.\r\n\r\n",
      "createdAt": "2020-06-03T16:49:56Z",
      "updatedAt": "2020-06-18T21:32:50Z",
      "closedAt": "2020-06-18T21:32:50Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In section 5.1, might be useful to have return KeySchedule/Context take in the AEAD, to make it clear that a Context is bound to a particular AEAD.\r\n\r\nI think this is worth thinking about. I am not sure how to address it in the spec, yet.\r\n\r\nTo give an example of an implementation: In the work-in-progress F* implementation, all fields of the encryption_context are actually parametrized with the entire ciphersuite, see https://github.com/project-everest/hacl-star/blob/_blipp_hpke/specs/Spec.Agile.HPKE.fsti#L278. This way it is not possible to use the context with another ciphersuite.\r\n\r\nTo add to @dvorak42's comment, the context is also bound to a particular KDF (for the Export interface).\r\n\r\n**Edited to add**: Just noticed that https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#encryption-and-decryption-hpke-dem already contains \u201cthe AEAD algorithm in use\u201d\r\n\r\n> Each of the setup procedures above produces a context object that stores the required state:\r\n>\r\n> -   The AEAD algorithm in use\r\n> -   The key to be used with the AEAD algorithm\r\n> -   A base nonce value\r\n> -   A sequence number (initially 0)\r\n> -   An exporter secret (see {{hpke-export}})\r\n\r\n\u201cThe KDF algorithm in use\u201d could be added here (as second element).\r\n\r\nAnd then, as @dvorak42 suggests, it's just not explicitly mentioned in the code in the return statement of KeySchedule.",
          "createdAt": "2020-06-17T22:04:39Z",
          "updatedAt": "2020-06-17T22:19:29Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112. Please re-open if that's not the case!",
          "createdAt": "2020-06-18T21:32:50Z",
          "updatedAt": "2020-06-18T21:32:50Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWU2MzAyOTU5NzE=",
      "title": "Use I2OSP instead of encode_big_endian",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/104",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See https://tools.ietf.org/html/rfc8017.",
      "createdAt": "2020-06-03T20:15:55Z",
      "updatedAt": "2020-06-18T21:32:35Z",
      "closedAt": "2020-06-18T21:32:35Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:32:35Z",
          "updatedAt": "2020-06-18T21:32:35Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWU2MzAyOTc1ODY=",
      "title": "Clarify KEM shared secret for AuthEncap/Decap",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/105",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> - Section 4: the definitions of AuthEncap and AuthDecap contain words to the\r\n>   effect, 'the KEM shared secret key is known only to the holder of the\r\n>   private key \"skS\".' It would be more accurate to say , 'the KEM shared\r\n>   secret key was generated by the holder of the private key \"skS\"'.",
      "createdAt": "2020-06-03T20:18:05Z",
      "updatedAt": "2020-06-18T21:33:01Z",
      "closedAt": "2020-06-18T21:33:01Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:33:01Z",
          "updatedAt": "2020-06-18T21:33:01Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "MDU6SXNzdWU2MzAyOTgzNjM=",
      "title": "Note that DHKEM's Unmarshal function can fail",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/106",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-03T20:19:08Z",
      "updatedAt": "2020-06-18T21:33:17Z",
      "closedAt": "2020-06-18T21:33:17Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:33:17Z",
          "updatedAt": "2020-06-18T21:33:17Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU2MzAzMDU4NjM=",
      "title": "Nits from Riad",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/107",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> - Section 5.1.3: it would be nice to include a reference or citation for\r\n>   unknown key share attacks.\r\n>\r\n> - Section 5.2: is there a reason to put the word \"amortize\" in quotes? \r\n>\r\n> - Section 7.1.2: it might be worth mentioning here that [keyagreement] also\r\n>   includes checking that the public key is not the identity point.\r\n>\r\n> - Section 7.1.2: is there a reason to recommend either checking for a nonzero \r\n>   scalar or checking for a non-identity DH output? Checking the latter covers\r\n>   the former and also covers the check from my prior comment. Moreover, it is\r\n>   not clear to me that checking the scalar is useful for the recipient, since\r\n>   this is essentially just checking that their long-term secret is nonzero.\r\n>\r\n> - Section 8.1: the sentence \"In particular, the KDFs and DH groups...\" might\r\n>   want to clarify that this statement is true only when these primitives are\r\n>   used as specified. The concern is that HKDF is only indifferentiable under\r\n>   some restrictions on salt length (for reasons noted in Section 8.3).",
      "createdAt": "2020-06-03T20:31:19Z",
      "updatedAt": "2020-06-18T21:32:07Z",
      "closedAt": "2020-06-18T21:32:07Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:32:07Z",
          "updatedAt": "2020-06-18T21:32:07Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU2MzAzMTIyODI=",
      "title": "Bind DHKEM labels to the group",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/108",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> - Section 4.1: this may be paranoia, but it would be slightly nicer to include\r\n>   the DH group name in the label arguments of LabeledExtract and LabeledExpand\r\n>   to ensure that invocations from different DHKEM instantiations are orthogonal.",
      "createdAt": "2020-06-03T20:42:17Z",
      "updatedAt": "2020-06-18T21:31:57Z",
      "closedAt": "2020-06-18T21:31:57Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:31:57Z",
          "updatedAt": "2020-06-18T21:31:57Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "MDU6SXNzdWU2MzAzNTM4MTA=",
      "title": "Add acknowledgements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/109",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Benjamin Lipp, David Benjamin, Benjamin Beurdouche, Riad Wahby, Kevin Jacobs, Michael Rosenberg, Michael Scott, Raphael Robert, and probably more!",
      "createdAt": "2020-06-03T21:45:15Z",
      "updatedAt": "2020-06-18T21:32:26Z",
      "closedAt": "2020-06-18T21:32:26Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:32:26Z",
          "updatedAt": "2020-06-18T21:32:26Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWU2MzY0MzI4NDY=",
      "title": "Clarify decryption failure cases",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/110",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The only way an endpoint notices that decryption fails is if AEAD decryption fails. This doesn't seem to be a problem, though we should probably note it for clarity's sake.",
      "createdAt": "2020-06-10T17:42:34Z",
      "updatedAt": "2020-06-18T21:33:09Z",
      "closedAt": "2020-06-18T21:33:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #112.",
          "createdAt": "2020-06-18T21:33:09Z",
          "updatedAt": "2020-06-18T21:33:09Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "MDU6SXNzdWU2Mzk1ODk4Mzg=",
      "title": "Unclear if last sequence number can be used to encrypt/decrypt messages",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/111",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft currently says the following about the sequence number:\r\n\r\n* `Implementations [\u2026] MUST return an error if the sequence number overflows`\r\n* `If a Seal or Open operation would cause the seq field to overflow, then the implementation MUST return an error.`\r\n\r\nHowever, it is not clear to me how exactly the implementation should behave when the last sequence number is reached:\r\n\r\n* `Context.Seal` will first create the ciphertext, which is ok. Next, `self.IncrementSeq` will return an Error. Should `Context.Seal` then fail, too? The second point above kind of suggests it. So, if it should fail, then this also means that the last sequence number effectively cannot be used. If it should not fail, then it is unclear how the next `Context.Seal` will know that it really cannot encrypt anymore.\r\n\r\n* The situation for `Context.Open` is similar.\r\n\r\nSo, maybe we should just clarify that if `Context.IncrementSeq` fails, then `Context.Seal` and `Context.Open` also fail, *without* returning `ct` or `pt`, and note that this effectively means that the last sequence number cannot be used?\r\n\r\n```\r\ndef Context.IncrementSeq():\r\n  if self.seq >= (1 << (8*Nn)) - 1:\r\n    return NonceOverflowError\r\n  self.seq += 1\r\n\r\ndef Context.Seal(aad, pt):\r\n  ct = Seal(self.key, self.ComputeNonce(self.seq), aad, pt)\r\n  self.IncrementSeq()\r\n  return ct\r\n\r\ndef Context.Open(aad, ct):\r\n  pt = Open(self.key, self.ComputeNonce(self.seq), aad, ct)\r\n  if pt == OpenError:\r\n    return OpenError\r\n  self.IncrementSeq()\r\n  return pt\r\n```",
      "createdAt": "2020-06-16T11:29:32Z",
      "updatedAt": "2020-06-18T21:31:43Z",
      "closedAt": "2020-06-18T21:31:43Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This should be fixed in #112. Please re-open if that's not the case!",
          "createdAt": "2020-06-18T21:31:43Z",
          "updatedAt": "2020-06-18T21:31:43Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWU2NDAwMTU2MTU=",
      "title": "Clarify KEM errors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/113",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [],
      "body": "We raise errors when AEAD functions fail due (OpenError and NonceOverflowError), but do nothing similar for KEM failures. What happens when `DH()` fails? Should we raise an explicit error? Or should we add text which says something like, \"implementations MUST raise errors when <these fallible> functions fail\"? I'd lean towards being explicit, but that may may the pseudocode messy.\r\n\r\ncc @blipp",
      "createdAt": "2020-06-16T22:35:49Z",
      "updatedAt": "2020-06-18T21:31:29Z",
      "closedAt": "2020-06-18T21:31:28Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #112.",
          "createdAt": "2020-06-18T21:31:28Z",
          "updatedAt": "2020-06-18T21:31:28Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWU2NDAwMTYyMjM=",
      "title": "Document use cases for different HPKE modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/114",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "From JP's review, it might be helpful if the different modes had some text describing scenarios or use cases where they make sense. @bifurcation, what do you think?\r\n\r\ncc @blipp ",
      "createdAt": "2020-06-16T22:37:28Z",
      "updatedAt": "2020-10-17T15:39:40Z",
      "closedAt": "2020-10-17T15:39:40Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing given lack of interest. ",
          "createdAt": "2020-10-17T15:39:40Z",
          "updatedAt": "2020-10-17T15:39:40Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "MDU6SXNzdWU2NDAwMTY2MjY=",
      "title": "Reference 2006/265",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/115",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "[The paper](https://eprint.iacr.org/2006/265.pdf) presents conditions for secure KEM/DEM constructions. We should absolutely cite it as related work.",
      "createdAt": "2020-06-16T22:38:31Z",
      "updatedAt": "2020-10-23T18:06:00Z",
      "closedAt": "2020-10-23T18:06:00Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @blipp, to see if this has been covered by the to-be-published analysis.",
          "createdAt": "2020-10-17T15:40:52Z",
          "updatedAt": "2020-10-17T15:40:52Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just suggested a citation in pull request https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/131",
          "createdAt": "2020-10-21T16:28:17Z",
          "updatedAt": "2020-10-21T16:28:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, that works! Closing for now.",
          "createdAt": "2020-10-23T18:06:00Z",
          "updatedAt": "2020-10-23T18:06:00Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWU2NDc1MzI4ODY=",
      "title": "DeriveKeyPair dependency in Encap is unnecessary",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/128",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "#79 added a `DeriveKeyPair` operation, which is a reasonable thing to want for protocols that need it. In doing so, it removed `GenerateKeyPair` and replaced the ephemeral DH keys in `Encap` with `DeriveKeyPair(random())`.\r\n\r\nThis seems unnecessary. It's true that having both `DeriveKeyPair` and `GenerateKeyPair` is a larger definition of KEM in HPKE, but, realistically, everyone has a `GenerateKeyPair` in their existing KEM-like APIs, while `DeriveKeyPair` is the more niche operation. After all, we've managed to use DH thus far *somehow*. :-) From the context of HPKE's use in ECH in TLS, I'm not sure `DeriveKeyPair` would be needed at all. `DeriveKeyPair(random())` is also going to result in many more hash calls than a typical `GenerateKeyPair` implementation.",
      "createdAt": "2020-06-29T17:06:08Z",
      "updatedAt": "2020-06-29T17:58:27Z",
      "closedAt": "2020-06-29T17:58:27Z",
      "comments": []
    },
    {
      "number": 136,
      "id": "MDU6SXNzdWU2NjMyNDc3NDE=",
      "title": "AES-GCM-128 => AES-128-GCM?",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/136",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I think everything I've seen uses AES-128-GCM instead of AES-GCM-128. In particular, it's probably good to match RFC5116's terminology. Was there a particular reason HPKE went with AES-GCM-128?",
      "createdAt": "2020-07-21T19:16:13Z",
      "updatedAt": "2020-07-23T19:07:34Z",
      "closedAt": "2020-07-23T19:07:34Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Was there a particular reason HPKE went with AES-GCM-128?\r\n\r\nNope :-) Seems like it was just oversight. We can switch it over. ",
          "createdAt": "2020-07-21T19:18:33Z",
          "updatedAt": "2020-07-21T19:18:33Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed directly on master.",
          "createdAt": "2020-07-23T19:07:34Z",
          "updatedAt": "2020-07-23T19:07:34Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "MDU6SXNzdWU2NjMyNzc3MTg=",
      "title": "Replace RFCXXXX with draft version strings",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/137",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "... and then replace with the final RFC number when done!",
      "createdAt": "2020-07-21T20:10:55Z",
      "updatedAt": "2020-07-27T13:27:11Z",
      "closedAt": "2020-07-27T13:27:11Z",
      "comments": []
    },
    {
      "number": 139,
      "id": "MDU6SXNzdWU2NjgxNjM5MzY=",
      "title": "Consider renaming zz",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/139",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Every time I see \"zz\" I get confused. :-) How about \"kem_secret\", \"shared_secret\", or just \"secret\"?",
      "createdAt": "2020-07-29T21:15:57Z",
      "updatedAt": "2020-07-30T23:40:30Z",
      "closedAt": "2020-07-30T23:40:30Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems reasonable. ",
          "createdAt": "2020-07-30T12:51:28Z",
          "updatedAt": "2020-07-30T12:51:28Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWU2Nzk1NzcyNDM=",
      "title": "List the NIST curve orders inline",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/141",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The text (for DeriveKeyPair) is currently ambiguous. Let's just include the orders for each curve, which would be the following:\r\n\r\n- P256: 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\r\n- P384: 0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973\r\n- P521: 0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409",
      "createdAt": "2020-08-15T13:42:55Z",
      "updatedAt": "2020-10-23T18:05:42Z",
      "closedAt": "2020-10-23T18:05:42Z",
      "comments": []
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU2Nzk1Nzc3NTk=",
      "title": "Consider removing \"Designated-Verifier Signature\" section",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/142",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Stephen suggested removing this [on the list](https://mailarchive.ietf.org/arch/msg/cfrg/7zhOHPFkCyZC00xLZnsEBT3o6ZU/), because\r\n\r\n> it might muddy the definition of \"signature\" for some people and doesn't seem to add much as-is.\r\n\r\nThis is a reasonable criticism. It does seem somewhat out of place and, as written, I'm not even sure it's correct (considering KCI issues for the Auth variants). \r\n\r\n@bifurcation, what do you think? Can we axe this?",
      "createdAt": "2020-08-15T13:47:00Z",
      "updatedAt": "2020-09-23T15:44:59Z",
      "closedAt": "2020-09-23T15:44:59Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > it might muddy the definition of \"signature\" for some people and doesn't seem to add much as-is.\r\n> \r\n> This is a reasonable criticism. It does seem somewhat out of place and, as written, I'm not even sure it's correct (considering KCI issues for the Auth variants).\r\n\r\nIt is right that due to the KCI issue of DHKEM, this kind of \u201csignature\u201d does not guarantee that it was produced by the sender, if the recipient's static key is compromised. So maybe it is indeed a stretch to call it a signature.",
          "createdAt": "2020-08-24T13:46:02Z",
          "updatedAt": "2020-08-24T13:46:02Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp do you know if this proposal has been analyzed? If not, I'm going to toss up a PR removing it. ",
          "createdAt": "2020-08-24T13:49:27Z",
          "updatedAt": "2020-08-24T13:49:27Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chris-wood I did not analyze it, and I do not know of someone who did.",
          "createdAt": "2020-08-24T14:00:57Z",
          "updatedAt": "2020-08-24T14:00:57Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "MDU6SXNzdWU2Nzk1Nzc5MTE=",
      "title": "Remove superfluous space after \"HPKE-05\" in constant labels",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/143",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was raised by Stephen [on the list](https://mailarchive.ietf.org/arch/msg/cfrg/7zhOHPFkCyZC00xLZnsEBT3o6ZU/).",
      "createdAt": "2020-08-15T13:48:07Z",
      "updatedAt": "2020-10-23T18:05:37Z",
      "closedAt": "2020-10-23T18:05:37Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it is a good idea to remove the space. It is inconsistent to have a space there but not between all the other labels we use. We need to take care to update Section \u201cInput Length Restrictions {#kdf-input-length}\u201d appropriately (increase limits by one).",
          "createdAt": "2020-08-24T13:48:28Z",
          "updatedAt": "2020-08-24T13:48:28Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWU2Nzk1NzkwMDk=",
      "title": "Address Stephen's nits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/144",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From [his feedback on the list](https://mailarchive.ietf.org/arch/msg/cfrg/7zhOHPFkCyZC00xLZnsEBT3o6ZU/):\r\n\r\n1. p4: PGP and fiveG don't depend on HPKE, whereas msl and esni do. Maybe worth saying that.\r\n2. p5: I2OSP and OS2IP aren't expanded here - be no harm to do so\r\n3. p6: Open as the opposite of Seal, doesn't seem like the best choice - there are too many functions called open() in too many contexts. Unseal would be better IMO.\r\n4. p5: DeriveKeyPair was added after discussion in github (and maybe on the MLS list) but I don't recall any disussion of that on the CFRG list at all. Was there any? Adding this seems fine to me if MLS wants it and the definition is also almost fine (see above) so this is just a process nit.\r\n5. p5 & elsewhere: \"fixed-length\" is used in various places where it's not quite true - the various lengths are fixed only after you pick a ciphersuite - so people's code has to support different sizes (if they support >1 suite)\r\n\r\nMy take on each of these is:\r\n\r\n1. We can clarify this.\r\n2. These seem fairly common in folded form and are quite a mouthful when expanded, so I'm inclined to keep these as is.\r\n3. Open and seal seem fairly common, at least in APIs I'm familiar with (BoringSSL/OpenSSL, libsodium, NaCL, etc), so I'm inclined to keep this as is.\r\n4. I disagree about this being a process nit. The document is still an active RG document, so everything is subject to change. I'm not sure why discussion would be needed before or after it lands in the document?\r\n5. Similar to other stacks I'm familiar with, I assume memory would statically allocated for each of these fixed-length values (on the stack) based on the maximum size supported. The specific ciphersuite/length would then use however much of that memory is needed. So this seems fine to keep, though perhaps clarifying might help? I'm not sure what that would look like right now, but I'll give it some thought.",
      "createdAt": "2020-08-15T13:55:50Z",
      "updatedAt": "2020-10-23T18:04:48Z",
      "closedAt": "2020-10-23T18:04:48Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1. I agree.\r\n2. Maybe a middle ground would be to specify the parameters of the two functions? `I2OSP(int, len)` and `OS2IP(str)`. At least for I2OSP this is usefull to recall the order of the parameters.\r\n3. I haven't seen Open and Seal before, but my experience with crypto libraries is limited anyway, so I abstain.\r\n4. I am not sure how the process is supposed to be. I haven't seen many detailed discussions about decisions like this one on the full CFRG list since I am subscribed, so it seems not unusual to have these discussions off-list?\r\n5. I do not have enough experience to comment.",
          "createdAt": "2020-08-24T13:56:40Z",
          "updatedAt": "2020-08-24T13:56:40Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWU2Nzk1Nzk1MDc=",
      "title": "Add recommended column to the IANA registry table",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/145",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[Stephen writes](https://mailarchive.ietf.org/arch/msg/cfrg/7zhOHPFkCyZC00xLZnsEBT3o6ZU/):\r\n\r\n> The thing to ponder relates to the IANA considerations.\r\n> Why not add a \"recommended\" column a la TLS.  The RG can\r\n> hand over responsibility to some DEs appointed by the IESG\r\n> and call for the same setup as TLS.  (I.e. other than\r\n> the initial values recommended == yes requires IETF\r\n> standards track, otherwise spec required.) If we don't\r\n> do that then applications using HPKE will always each\r\n> need to say which suites are MUSTs, leading to IMO mostly\r\n> pointless variation and possibly worsening interop if\r\n> libraries implement disjoint sets of suites.\r\n\r\nThis seems reasonable, though I don't have a sense for how problematic the lack of a \"recommended\" column will be in the long term. @bifurcation, what do you think?",
      "createdAt": "2020-08-15T13:59:23Z",
      "updatedAt": "2020-10-18T17:37:16Z",
      "closedAt": "2020-10-18T17:37:16Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is probably the wrong level for making those recommendations.  The countervailing risk to the one Stephen points out is that if we *do* define a \"recommended\" column here, then it's likely to conflict with similar recommendations at different points in the stack.  MLS already has a \"recommended\" column on its ciphersuites registry, which specifies HPKE algorithms among other things.   So just as we don't specify mandatory algorithms here, we shouldn't track recommendation status.  \r\n\r\nIn other words, all that stuff is designed to help ensure that implementations of TLS/MLS/etc. have cipher overlap, which is not what this document does.  We don't do anything about cipher selection / negotiation, and shouldn't.  The goal of this document is just to describe a construction that is secure if the underlying primitives are.",
          "createdAt": "2020-10-18T17:35:50Z",
          "updatedAt": "2020-10-18T17:35:50Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "MDU6SXNzdWU2ODAyNjE2MTA=",
      "title": "suite_id length is wrong",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/146",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "In 7.2.1, this should be 10, not 9, to match the length of the following byte array is 10:\r\n\r\n~~~\r\nsuite_id = concat(\r\n  \"HPKE\",\r\n  I2OSP(kem_id, 2),\r\n  I2OSP(kdf_id, 2),\r\n  I2OSP(aead_id, 2)\r\n)\r\n~~~",
      "createdAt": "2020-08-17T14:03:58Z",
      "updatedAt": "2020-10-23T18:05:32Z",
      "closedAt": "2020-10-23T18:05:32Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are right, good catch. I guess the 9 is still from when it was `\"DEM\"` and not `\"HPKE\"`.",
          "createdAt": "2020-08-24T13:59:12Z",
          "updatedAt": "2020-08-24T13:59:12Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "MDU6SXNzdWU2ODAyNjI3MDQ=",
      "title": "Clarify seedE and seedR in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/147",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "These values are not well-defined, and they probably should be.",
      "createdAt": "2020-08-17T14:05:35Z",
      "updatedAt": "2020-10-23T18:05:26Z",
      "closedAt": "2020-10-23T18:05:26Z",
      "comments": []
    },
    {
      "number": 152,
      "id": "MDU6SXNzdWU2OTY3ODAxODM=",
      "title": "Address cjpatton's feedback",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/152",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Abstract                                           \r\n                                                   \r\n\"for any combination of\" -> \"for several combinations of\"\r\n                                                   \r\nSection 4                                          \r\n                                                   \r\n\"random(Nsk)\" is used but \"random()\" isn't defined yet.  \r\n                                                   \r\n\"not passed as parameter\" -> \"not passed as a parameter\" \r\n                                                   \r\nSection 5                                          \r\n                                                   \r\n\"the holder of the private key corresponding to `pkR`\" -> \"the holder of `skR`\" \r\n                                                   \r\nIn various places, e.g., 'KeySchedule()' in Section 5.1, value \"\" is used as the\r\nsalt for KDF extraction. I'm wondering if implementations might misinterpret    \r\nthis. I read \"\" as 'the empty string', but the correct interpretation might be  \r\n'nil', i.e., 'None' in Python or 'NULL' in C. The HKDF spec defines the salt as \r\nfollows: 'optional salt value (a non-secret random value); if not provided, it  \r\nis set to a string of HashLen zeros.' I think the intention is to interpret \"\"  \r\nas 'nil', i.e., no salt, but the empty string is certainly a valid salt for\r\nHKDF, since the extraction function is well-defined on this input. A 0-length\r\nsalt might not be safe choice in terms of security, however.\r\n                                                   \r\nSection 5.2                                        \r\n                                                   \r\nI think the HPKE uses the term \"nonce\" incorrectly, since it's not a \"Number\r\nthat's used ONCE\". In fact, it's used every time the \"Seal()\" or \"Open()\"\r\noperation is run. What's called a \"nonce\" here is usually called the\r\n\"initialization vector\" elsewhere: in TLS 1.3 for example, the \"nonce\" is the\r\ninitialization vector XORed with a sequence number.    \r\n\r\n(Edit: from the list, consider renaming this to \"iv\")",
      "createdAt": "2020-09-09T12:40:54Z",
      "updatedAt": "2020-10-23T18:04:07Z",
      "closedAt": "2020-10-23T18:04:07Z",
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding the point about `\"\"` appearing with `LabeledExtract` as a salt: this is correct, and equivalent to providing a nil salt or no salt when such an API is available.\r\n\r\n[`HKDF-Extract(salt, IKM)`](https://tools.ietf.org/html/rfc5869#section-2.2) is defined to be `HMAC-Hash(salt, IKM)`. In turn, [`HMAC-Hash(K, text)`](https://tools.ietf.org/html/rfc2104#section-2) is defined to be `H(K XOR opad, H(K' XOR ipad, text))`, where `H` is the underlying hash function and `K'` is the value of `K` **padded with zeros until it is the length of a digest**. HashLen many zeros is also (not-coincidentally) the default value of `salt` in `HKDF-Extract` if none is specified.\r\n\r\nThus, `salt = \"\"` is equivalent to `salt = nil` is equivalent to `salt = [0x0, 0x0, ..., 0x0]` HashLen many times. So at least _technically_ this is not an issue. However, I think it's still fair to ask though whether it's clearer to the reader to use `nil` instead of `\"\"`.",
          "createdAt": "2020-09-11T22:37:00Z",
          "updatedAt": "2020-09-11T22:37:00Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "MDU6SXNzdWU2OTk4MzAwMDQ=",
      "title": "No official byte representation of private keys",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/153",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, there is no `Serialize/Deserialize` function defined for KEM private keys. The primary reason someone might want this is if they were migrating from one HPKE library to another, and wanted to keep their long-term private keys the same. Currently, a user would have to dig into both implementations to find their internal representation and figure out how to convert between the two manually. The fact that go-hpke and rust-hpke have (I think) the same byte representation of secret keys is good, but it would be better if this were guaranteed by the spec.\r\n\r\nI propose `SerializeSk/DeserializeSk` functions (not married to those names) that do what you'd expect, with the small addition that `DeserializeSk` should reject secret keys that are equivalent to 0.\r\n\r\n**Addendum**\r\n\r\nI also think that `SerializeSk` should canonicalize secret keys. For P-curves, this would mean reducing modulo the curve order, and for X25519/X448 this would mean clamping the keys.\r\n\r\nThe reason I think we should do this is because users might want to save their secret keys using some storage mechanism of their choosing. They might have some expectations of secret key identity (e.g., as a key in a table or an item in a set), and it would be a lot more effort to scream \"equivalent keys are not identical!\" all across our docs than to just make sure that equivalent keys actually are identical.",
      "createdAt": "2020-09-11T22:50:31Z",
      "updatedAt": "2020-10-23T18:04:38Z",
      "closedAt": "2020-10-23T18:04:38Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This came up again recently. Our solution was to pass around the DeriveKeyPair seed `ikm`, rather than the private keys themselves, though that incurs some cost. ",
          "createdAt": "2020-10-17T15:42:56Z",
          "updatedAt": "2020-10-17T15:42:56Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This seems like a reasonable workaround, but I think it's too user-hostile for general use.\r\n\r\nIf a user used `GenerateKeyPair()` or threw away their `DeriveKeyPair()` IKM, and they want to migrate their long-term key to a new implementation, they're simply out of luck with no recourse. So it would be incumbent upon the user to keep their IKM around even if they had no current plans to migrate.\r\n\r\nOf course, we could require that secret keys also retain their seed IKM, but the actual problem here is assuming that IKM is safe to store indefinitely. Since there's no assumption on the pseudorandomness of the IKM (it just needs enough entropy), there might be some sensitive information in there which could be related to other secrets elsewhere (e.g., the IKM is a password that's partially or fully reused for some other service). Since `DeriveKeyPair()` uses a KDF, this isn't a problem if you store just the resulting secret key.\r\n\r\nThus, I think it makes it easier to Do The Right Thing if secret keys are serializable and we can throw away IKMs as soon as we KDF them.",
          "createdAt": "2020-10-17T19:54:25Z",
          "updatedAt": "2020-10-17T19:54:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don\u2019t disagree with the overall ask to standardize private key serialization, but I do disagree with the general claim that using the seed is hostile. Since one can always derive the key from the seed, there\u2019s no real difference between passing around seeds or the resulting keys. (Assuming the seeds are random, as they are in the case referenced above. If they have sensitive information like passwords, then I agree that there\u2019s a difference.)",
          "createdAt": "2020-10-17T20:27:10Z",
          "updatedAt": "2020-10-17T20:27:10Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #165.",
          "createdAt": "2020-10-23T18:04:38Z",
          "updatedAt": "2020-10-23T18:04:38Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWU3MDY2ODEyNjU=",
      "title": "Include DeriveKeyPair output in test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/154",
      "state": "CLOSED",
      "author": "kjacobs-moz",
      "authorAssociation": "NONE",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Currently, there are two ways to generate a keypair for HPKE: `DeriveKeyPair` and `GenerateKeyPair`. The former is unnecessary when HPKE is used only for ECH. For libraries that choose to not implement or export `DeriveKeyPair`, it would be useful to have its output captured in the test vectors. ",
      "createdAt": "2020-09-22T20:45:44Z",
      "updatedAt": "2020-11-05T01:08:02Z",
      "closedAt": "2020-11-05T01:08:02Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kjacobs-moz I think this is resolved now that the ikm and resulting public keys are included in the test vectors. Can we close this?",
          "createdAt": "2020-11-05T01:06:30Z",
          "updatedAt": "2020-11-05T01:06:30Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "NONE",
          "body": "Yes, thanks!",
          "createdAt": "2020-11-05T01:08:02Z",
          "updatedAt": "2020-11-05T01:08:02Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "MDU6SXNzdWU3MDc0MzEwNDg=",
      "title": "Restrict low-entropy PSKs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/155",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "See https://mailarchive.ietf.org/arch/msg/cfrg/mxBzZq85ijSMNMUwyI3gA3B0U4U/.",
      "createdAt": "2020-09-23T14:45:10Z",
      "updatedAt": "2020-09-30T23:03:05Z",
      "closedAt": "2020-09-30T23:03:05Z",
      "comments": []
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWU3MDc0MzM1ODg=",
      "title": "Add one-shot Export API",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/156",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See title.",
      "createdAt": "2020-09-23T14:48:08Z",
      "updatedAt": "2020-09-23T14:49:18Z",
      "closedAt": "2020-09-23T14:49:18Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Dup of #157 ",
          "createdAt": "2020-09-23T14:49:18Z",
          "updatedAt": "2020-09-23T14:49:18Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "MDU6SXNzdWU3MDc0MzQzMTM=",
      "title": "One-shot API for export",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/157",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We have one-shot APIs for Seal and Open, it would be nice to have these for the exporter as well.  It seems like the right shape would be something like:\r\n\r\n```\r\ndef SendExport<MODE>(pkR, info, exporter_context, L, ...):\r\n  enc, ctx = Setup<MODE>S(pkR, info, ...)\r\n  exported = ctx.Export(exporter_context, L)\r\n  return enc, exported\r\n\r\ndef ReceiveExport<MODE>(enc, skR, info, exporter_context, L, ...):\r\n  ctx = Setup<MODE>R(enc, skR, info, ...)\r\n  return ctx.Export(exporter_context, L)\r\n```\r\n\r\nIn a way this is just an \"enhanced KEM\", where the enhancements are:\r\n\r\n* The transaction metadata (pkR, info, etc.) are hashed into the key\r\n* The Export function can produce arbitrary-length output",
      "createdAt": "2020-09-23T14:48:57Z",
      "updatedAt": "2020-09-25T14:39:34Z",
      "closedAt": "2020-09-25T14:39:34Z",
      "comments": []
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWU3MDkzMDkyMzk=",
      "title": "Wire format of HPKE context",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/161",
      "state": "CLOSED",
      "author": "cjpatton",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft does not specify how the HPKE context (cipher suite, exporter secret, key, nonce, sequence number, etc.) is represented on the wire. There are use cases for HPKE in which it is desirable to transmit the context over a secure channel. For example, Cloudflare's prototype implementation of the Encrypted ClientHello (ECH) extension for TLS will offload KEM operations to an RPC server (https://github.com/cloudflare/go/pull/30).\r\n\r\nI'm not requesting a change to the spec at this point ... I just wanted to bring up the use case and ask what people think. I'm not sure, but it might make sense to standardize the encoding. One proposal is here: https://github.com/cisco/go-hpke/blob/master/hpke.go#L197. In addition to the above parameters, this format encodes the \"role\" of the context's user, i.e., whether they are the sender or receiver.",
      "createdAt": "2020-09-25T22:02:27Z",
      "updatedAt": "2020-10-17T15:38:17Z",
      "closedAt": "2020-10-17T15:38:17Z",
      "comments": [
        {
          "author": "Lekensteyn",
          "authorAssociation": "NONE",
          "body": "There are many serialization formats possible (protobuf, DER, JSON, TLS syntax, ...). The \"Context\" type seems to refer to an implementation detail rather than an interchange format. If that is the case, then I don't think that a specific format has to be dicatated.",
          "createdAt": "2020-09-29T14:36:19Z",
          "updatedAt": "2020-09-29T14:36:19Z"
        },
        {
          "author": "cjpatton",
          "authorAssociation": "NONE",
          "body": "I'm fine with that resolution.",
          "createdAt": "2020-09-29T15:40:56Z",
          "updatedAt": "2020-09-29T15:40:56Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine with that resolution, too. Given this hasn't been requested until now, and how far along we are in the process, I'm closing this.",
          "createdAt": "2020-10-17T15:38:17Z",
          "updatedAt": "2020-10-17T15:38:17Z"
        }
      ]
    },
    {
      "number": 170,
      "id": "MDU6SXNzdWU3MzY1Mjg3MTI=",
      "title": "List known implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/170",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I started a list of implementations here:\r\n\r\n   https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/README.md\r\n\r\nWe should fill this out with other known implementations.\r\n\r\ncc @kjacobs-moz, @davidben, @dmcardle, @raphaelrobert, @nymble, @danielhavir, @armfazh, @fredericjacobs, @mcarrickscott",
      "createdAt": "2020-11-05T01:10:01Z",
      "updatedAt": "2020-12-16T14:19:23Z",
      "closedAt": "2020-12-16T14:19:23Z",
      "comments": [
        {
          "author": "danharkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please add hpke-wrap to list of implementations:\r\n\r\nhttps://github.com/danharkins/hpke-wrap",
          "createdAt": "2020-11-19T00:28:53Z",
          "updatedAt": "2020-11-19T00:29:15Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@danharkins, can you please submit a PR with the change? (See #171 and #172 above for examples.)",
          "createdAt": "2020-11-19T00:44:22Z",
          "updatedAt": "2020-11-19T00:44:22Z"
        },
        {
          "author": "danharkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n \u00a0 I can't create a branch. Would it be possible to give me permissions on\nthe repository?\n\n \u00a0 regards,\n\n \u00a0 Dan.\n\nOn 11/18/20 4:44 PM, Christopher Wood wrote:\n>\n> @danharkins <https://github.com/danharkins>, can you please submit a \n> PR with the change? (See #171 \n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/171> and #172 \n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/172> above for \n> examples.)\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/170#issuecomment-730049171>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/ABZLRMVPTX56Y4EUPUMPVK3SQRS7HANCNFSM4TKXMA2Q>.\n>\n\n-- \n\"The object of life is not to be on the side of the majority, but to\nescape finding oneself in the ranks of the insane.\" -- Marcus Aurelius\n\n",
          "createdAt": "2020-11-19T06:12:37Z",
          "updatedAt": "2020-11-19T06:12:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "You can fork the repository and create a branch on your own copy. \n\nOn Wed, Nov 18, 2020, at 10:12 PM, Dan Harkins wrote:\n> \n> \n> \n>   I can't create a branch. Would it be possible to give me permissions on\n> the repository?\n> \n>   regards,\n> \n>   Dan.\n> \n> On 11/18/20 4:44 PM, Christopher Wood wrote:\n> >\n> > @danharkins <https://github.com/danharkins>, can you please submit a \n> > PR with the change? (See #171 \n> > <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/171> and #172 \n> > <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/172> above for \n> > examples.)\n> >\n> > \u2014\n> > You are receiving this because you were mentioned.\n> > Reply to this email directly, view it on GitHub \n> > <https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/170#issuecomment-730049171>, \n> > or unsubscribe \n> > <https://github.com/notifications/unsubscribe-auth/ABZLRMVPTX56Y4EUPUMPVK3SQRS7HANCNFSM4TKXMA2Q>.\n> >\n> \n> -- \n> \"The object of life is not to be on the side of the majority, but to\n> escape finding oneself in the ranks of the insane.\" -- Marcus Aurelius\n> \n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/170#issuecomment-730153529>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAQSJEGNMPCX3Y2LWWIBE6LSQSZOFANCNFSM4TKXMA2Q>.\n>\n",
          "createdAt": "2020-11-19T11:30:57Z",
          "updatedAt": "2020-11-19T11:30:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "We have a good list now. Closing.",
          "createdAt": "2020-12-16T14:19:23Z",
          "updatedAt": "2020-12-16T14:19:23Z"
        }
      ]
    },
    {
      "number": 176,
      "id": "MDU6SXNzdWU3NDgzMjM0NTI=",
      "title": "Add (back?) DeserializePublicKey()",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/176",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is absent from the KEM interface, though implicit throughout the document. Since we list DeserializePrivateKey separately, we might as well add this to the KEM interface, too. ",
      "createdAt": "2020-11-22T19:12:57Z",
      "updatedAt": "2020-12-02T14:29:26Z",
      "closedAt": "2020-12-02T14:29:26Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't see an issue with adding it. For the record, it is only mentioned once in the document, https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#serializepublickey-and-deserializepublickey.",
          "createdAt": "2020-11-23T09:26:44Z",
          "updatedAt": "2020-11-23T09:26:44Z"
        }
      ]
    },
    {
      "number": 185,
      "id": "MDU6SXNzdWU3NTk1NDg3OTc=",
      "title": "AEAD ID for unsupported AEADs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/185",
      "state": "CLOSED",
      "author": "jedisct1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "HPKE currently defines only 3 possible AEADs to be used with.\r\n\r\nHowever, HPKE could be very useful as a generic key exchange mechanism, to be used with other AEADs or with anything requiring a shared secret.\r\n\r\nWas `0x00` as an AEAD ID reserved for that use case? Or has another approach that would possibly provide domain separation between AEADs been discussed?",
      "createdAt": "2020-12-08T15:38:33Z",
      "updatedAt": "2020-12-15T03:20:13Z",
      "closedAt": "2020-12-14T21:26:00Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For other AEADs, an AEAD ID can be registered with IANA, see  https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#authenticated-encryption-with-associated-data-aead-functions-aead-ids and https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#iana-considerations-iana. The reserved `0x00` should not be used. @chris-wood might be able to detail how to get IDs assigned by IANA. I assume IDs can only be registered as soon as the RFC is published, and thus IANA is aware of this namespace.\r\n",
          "createdAt": "2020-12-08T15:47:05Z",
          "updatedAt": "2020-12-08T15:47:05Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@jedisct1 can you please elaborate on the request? Do you basically want a range of IDs for experimental use?",
          "createdAt": "2020-12-08T23:50:03Z",
          "updatedAt": "2020-12-08T23:50:03Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Chris,\r\n\r\nHPKE combines a key exchange mechanism with encryption.\r\n\r\nHowever, it could be useful in a broader range of applications and protocols if it could be used only for key exchange, delegating the encryption part to applications.\r\n\r\nHaving standardized suites (which include an AEAD) is a no brainer for ensuring interoperability between application solely depending on HPKE for hybrid key encryption.\r\n\r\nBut it is a limitation for other protocols that already use more than HPKE. Actual examples:\r\n\r\n- Permutation-based AEADs using a rolling state (such as Xoodyak) don\u2019t fit in the HPKE model that increments a nonce after each message. However, they could still benefit from HPKE to absorb keying material.\r\n- Existing high-level protocols and APIs for stream encryption (taking care of rekeying, and out of band signalisation) could leverage HPKE as a key exchange mechanism.\r\n- In the context of a crypto library or a standard library, users will expect such a mechanism to be compatible with anything a uniform shared secret could be useful for. Including AEADs that can be better suited than AES depending on the context.\r\n\r\nA protocol will not have any interoperability issues if the key exchange mechanism and the AEAD (or anything else) are defined separately.\r\n\r\nRegistering new IANA identifiers is not a practical option for most cases. Higher-level protocols (especially application-specific ones) don\u2019t have their place in a global namespace. And even at a primitive level, while using AEGIS or GIFT-COFB as an AEAD could be justified by application requirements, having these in the IANA database would probably be unwanted.\r\n\r\nApplications will inevitably either use custom versions of HPKE, or mix and match NOISE and HPKE just to fit the set of AEADs and encryption operations currently supported by HPKE. \r\n\r\nSo, in order to encourage reusability and make HPKE also useful beyond the current encryption API, my proposal would be to reserve an AEAD identifier for protocol-defined use of the shared key, nonce, or exporter secret. Such identifier might be followed by a label in order to provide domain separation.\r\n",
          "createdAt": "2020-12-09T14:49:57Z",
          "updatedAt": "2020-12-09T16:18:39Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the detailed description. If I understand right, these are examples that do not use HPKE's encryption API. Instead, they are only interested in using key material (key, nonce) exchanged by HPKE, for external use?\r\n\r\nApplications should not use the `key` and `nonce` values computed by HPKE for such external uses. They should use [the secret export API](https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#secret-export) to generate them. This API allows domain separation of different uses with the `exporter_context` parameter. If an application needs multiple values (for example a key and a nonce), one exporter secret of sufficient length can be cut into two.\r\n\r\nI see that at least one question remains open, and that is: if the user only uses the secret export API and never the encryption API, which `aead_id` should be used in the `suite_id`? That's a good question. The single-shot secret export API was added only recently and this is certainly a question that has not been addressed so far. Thanks for pointing it out.\r\n\r\nAs a workaround, you could just use any valid AEAD ID supported by you HPKE implementation, and it does not matter which one (of course all parties involved in your protocol need to know which one). I agree for such use cases this ID seems superfluous and its arbitrary choice is error prone.\r\n\r\n@chris-wood @bifurcation Do you have an idea how to address this? Allowing the use of `0x00` if an application does not use the encryption API?",
          "createdAt": "2020-12-09T15:52:16Z",
          "updatedAt": "2020-12-09T15:52:29Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Besides improving clarity, if only the `exporter_context` is available for that use case, having a dedicated ID would have a performance advantage: the key and base nonce don't have to be computed.",
          "createdAt": "2020-12-09T16:18:12Z",
          "updatedAt": "2020-12-09T16:18:20Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp your suggestion (use any AEAD except `0x00`) would be my recommendation. Applications that just want to use HPKE to derive a shared secret can use the Export API to key other AEADs that don't fit into the HPKE AEAD API. \r\n\r\n@jedisct1, would that work for your use case (and libsodium)? I agree that adding a note which says implementations that don't use the encryption API, but only use the Export interface, can skip deriving the key and base nonce.",
          "createdAt": "2020-12-10T15:43:39Z",
          "updatedAt": "2020-12-10T15:43:39Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Wouldn't a non-`0x00` dedicated ID (maybe `0xffff`) be an option, if only to make the intent clear rather than use an ID that doesn't match the actual use?",
          "createdAt": "2020-12-10T15:54:16Z",
          "updatedAt": "2020-12-10T15:54:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Wouldn't a non-0x00 dedicated ID (maybe 0xffff) be an option, if only to make the intent clear rather than use an ID that doesn't match the actual use?\r\n\r\nWe could reserve `0xFFFF` for such cases, yeah. I don't see any harm in that. :)",
          "createdAt": "2020-12-10T15:56:04Z",
          "updatedAt": "2020-12-10T15:56:04Z"
        },
        {
          "author": "danharkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also want to add some AEAD algorithms and if you check out my hpke-wrap implementation you can see I'm already poaching a couple values (that will, of course, change) and how I intend on using them. The IANA registry says \"specification required\" so that means writing an I-D indicating how the algorithm is used (for my case they don't require a nonce/sequence number) once the HPKE I-D becomes an RFC. Until then, might I suggest reserving a value for \"experimental\" and have IANA assign those when it assigns 0-3.",
          "createdAt": "2020-12-10T23:30:54Z",
          "updatedAt": "2020-12-10T23:30:54Z"
        },
        {
          "author": "danharkins",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n \u00a0 \"export-only\"? Please tell me you meant \"experimental\".\n\n \u00a0 Dan.\n\nOn 12/14/20 1:26 PM, Richard Barnes wrote:\n>\n> Closed #185 <https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/185> \n> via #193 <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/193>.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/185#event-4111409301>, \n> or unsubscribe \n> <https://github.com/notifications/unsubscribe-auth/ABZLRMX2M3NW4F3JWDBR6X3SUZ7HRANCNFSM4USENY7A>.\n>\n\n-- \n\"The object of life is not to be on the side of the majority, but to\nescape finding oneself in the ranks of the insane.\" -- Marcus Aurelius\n\n",
          "createdAt": "2020-12-15T03:20:13Z",
          "updatedAt": "2020-12-15T03:20:13Z"
        }
      ]
    },
    {
      "number": 187,
      "id": "MDU6SXNzdWU3NjA1OTgyMjY=",
      "title": "Emphasize the fact that messages must never be encrypted by the recipient",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/187",
      "state": "CLOSED",
      "author": "jedisct1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reading the document doesn't make it clear that the sender should only encrypt, and the recipient should only decrypt. Or that they must take turns and decrypt everything from the other party before encrypting a new message. That seems to be dangerous.\r\n\r\nThe proposed API doesn't prevent this, which can lead users to thinking that HPKE is safe to use for two-way communications.\r\n\r\nThat would be catastrophic as nonces would be reused.\r\n\r\nMaybe the document should insist a little bit on this ?\r\n\r\nOr, if we want to safely allow communications both ways, we can add a function to derive two AEAD keys, for each direction (the `ENCRYPT` and `DECRYPT` functions can keep the current API, if they know whether a party was the initiator or the responder).\r\n",
      "createdAt": "2020-12-09T19:12:59Z",
      "updatedAt": "2020-12-14T21:45:48Z",
      "closedAt": "2020-12-14T21:45:48Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Reading the document doesn't make it clear that the sender should only encrypt, and the recipient should only decrypt. Or that they must take turns and decrypt everything from the other party before encrypting a new message. That seems to be dangerous.\r\n\r\nIs this text not sufficiently clear?\r\n\r\n~~~\r\nEncryption is unidirectional from sender to recipient. Each encryption or decryption operation increments the sequence number for the context in use. The sender's context MUST NOT be used for decryption. Similarly, the recipient's context MUST NOT be used for encryption.\r\n~~~\r\n\r\n> The proposed API doesn't prevent this, which can lead users to thinking that HPKE is safe to use for two-way communications.\r\n\r\nThat's true. Perhaps we could refactor the interface into a Sender and Receiver role, with `Seal` and `Open` on each role, respectively, to make this clear. I'll play with this and see if I can make it clear.\r\n\r\n> Or, if we want to safely allow communications both ways, we can add a function to derive two AEAD keys, for each direction (the ENCRYPT and DECRYPT functions can keep the current API, if they know whether a party was the initiator or the responder).\r\n\r\nThat's probably too much of a change at this point. (It's been discussed at length in the past.) The typical pattern for applications that need to encrypt a response back to the sender is to `Export` an encryption key and nonce, and then `Seal` up the response. (Perhaps we should add text with this suggestion to the document?)",
          "createdAt": "2020-12-10T15:48:39Z",
          "updatedAt": "2020-12-10T15:48:39Z"
        },
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text is easy to overlook. The confusion mainly comes from the API design:\r\n\r\nthe sender and the recipient share the same `Context` structure. A literal implementation of the documented API results in something where the recipient can encrypt.\r\n\r\n> The typical pattern for applications that need to encrypt a response back to the sender is to Export an encryption key and nonce, and then Seal up the response. (Perhaps we should add text with this suggestion to the document?)\r\n\r\nThat would be a very useful addition. HPKE being documented as \"unidirectional\" may lead applications to doing a second full key exchange to send a response back (which would obviously be fine, but quite inefficient).",
          "createdAt": "2020-12-10T16:17:10Z",
          "updatedAt": "2020-12-10T16:17:10Z"
        }
      ]
    },
    {
      "number": 189,
      "id": "MDU6SXNzdWU3NjE3MTkyNjE=",
      "title": "Compact representation for NIST curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/189",
      "state": "CLOSED",
      "author": "danharkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "OK, so I brought this up on the CFRG list and there were 2 people voicing some qualified support and no real opposition but then the topic just kind of died. I made a PR to show exactly what changes this would involve in the draft and it's been hanging there (by the way, the changes specified in the PR do not have all the test vector changes, but I will be happy to supply all of them if you agree to accept this PR but if you're going to reject this then there's no point). So allow me to raise this as an issue in the hope it elicits some discussion.\r\n\r\nThe NIST curves can be exchanged using \"compact representation\" per RFC 6090. That means just sending the x-coordinate. You don't even need to send a sign bit because the sign is not necessary since we're just doing Diffie-Hellman. This has the benefit of making Npk be the same as Nsk and Nsecret, just like the Bernstein curves. This makes the interface be a bit more uniform and cuts down on extraneous formatting (pre-pending with a 04, for instance). \r\n\r\nIn my implementation supporting compact representation I just do the equation of the curve and take the square root to get a y-coordinate (again, sign is irrelevant) in order to do the group operation. On the CFRG list Mike Hamburg mentioned that it's possible to do the x-only Montgomery ladder so even recovering y is not strictly necessary. \r\n\r\nI understand that there's no requirement on how one sends blobs of bits from one party to another and it's possible to do HPKE, get enc in the form of 04..x..y and then rip out x and send it to the other party who would, presumably reconstruct the 04..x..<either y> in order to pass it into HPKE but that's just horrible. The 04..x..y thing is a SECG-defined representation but there's really no reason to abide by that, especially when the 04 and the y-coordinate aren't needed.\r\n\r\nPlease consider accepting this PR. I'll be happy to finish the test vectors if you do.\r\n",
      "createdAt": "2020-12-10T23:45:51Z",
      "updatedAt": "2021-03-08T13:57:59Z",
      "closedAt": "2021-03-08T13:57:59Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@danharkins I think we can now close this after the conclusion on the mailing list. Please re-open if you disagree!",
          "createdAt": "2021-03-08T13:57:59Z",
          "updatedAt": "2021-03-08T13:57:59Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWU3OTMxMDg2MDE=",
      "title": "Prohibit the use of asymmetric keys with multiple KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/202",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is going to be commonplace that a key pair will be used with multiple KDF or AEAD algorithms.  See ECH for an example.  \r\n\r\nThe design would seem to be robust against use in this way as the KEM ID is integrated into the label construction.  However, it would make usage much less prone to mistakes if the asymmetric key pairs were not usable with other KEMs.\r\n\r\nThis is not a design change, but a request to add text saying \"MUST NOT\" which would make writing specifications that depend on HPKE easier.\r\n\r\n",
      "createdAt": "2021-01-25T07:17:30Z",
      "updatedAt": "2021-04-13T16:38:02Z",
      "closedAt": "2021-04-13T16:37:54Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@martinthomson can you please propose text?",
          "createdAt": "2021-02-16T16:52:35Z",
          "updatedAt": "2021-02-16T16:52:35Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #215.",
          "createdAt": "2021-04-13T16:38:02Z",
          "updatedAt": "2021-04-13T16:38:02Z"
        }
      ]
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWU4MDgxOTc3MjU=",
      "title": "x448 test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/206",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I wrote an implementation and when I was attempting to verify using the test vectors json file here I am receiving failures because it looks like the x448 key values for skEm are not clamped in the json file. All the tests pass for x25519 values because those keys are clamped. I'm assuming the clamped version would be correct?",
      "createdAt": "2021-02-15T05:49:05Z",
      "updatedAt": "2021-02-15T05:53:53Z",
      "closedAt": "2021-02-15T05:53:53Z",
      "comments": [
        {
          "author": "tomleavy",
          "authorAssociation": "NONE",
          "body": "never mind, seems both are not clamped and are consistent",
          "createdAt": "2021-02-15T05:53:53Z",
          "updatedAt": "2021-02-15T05:53:53Z"
        }
      ]
    },
    {
      "number": 207,
      "id": "MDU6SXNzdWU4MDgyMzA3OTQ=",
      "title": "Test vector issue with P256",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/207",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "One of the test vectors contains a pkRm value of `04dc8b502e23e9bd533918ad19238aa39e334f5fac3114875fcf3be3a67f003fa5215d39a8bb0d42e2a883a0b7f3cea08bf73aaa3b3e057ab6db766e75d2a141e3`\r\n\r\nWhen I pass that value to openssl to the `EC_POINT_oct2point` function specifying the P256 curve I get an error saying `point is not on curve`\r\n\r\nI have tested the code against test vector points from other P256 related test vectors and they have all been ok",
      "createdAt": "2021-02-15T06:40:35Z",
      "updatedAt": "2021-02-16T03:57:33Z",
      "closedAt": "2021-02-15T19:10:03Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Please see #208 for a final set of test vectors. Given that these have been verified by other implementations, I'd be surprised if this were an issue with the vector. Closing this for now. Please comment over in that PR if the problem remains!",
          "createdAt": "2021-02-15T19:10:03Z",
          "updatedAt": "2021-02-15T19:10:03Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "NONE",
          "body": "Turns out I was using SECP256K1 instead of  X9_62_PRIME256V1 inside OpenSSL. All working now, thanks!",
          "createdAt": "2021-02-16T03:57:33Z",
          "updatedAt": "2021-02-16T03:57:33Z"
        }
      ]
    },
    {
      "number": 218,
      "id": "MDU6SXNzdWU4NjgxOTk4MTQ=",
      "title": "Improve test vector field descriptions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/218",
      "state": "CLOSED",
      "author": "kaduk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The test vectors include (for example) fields like \"ikmE\", \"ikmR\", and \"ikmS\", whereas the main body of the document only uses the unadorned \"ikm\".  Some modest description of what the variant fields are holding seems like it would improve the usability of the test vectors.",
      "createdAt": "2021-04-26T21:01:33Z",
      "updatedAt": "2021-05-26T17:22:19Z",
      "closedAt": "2021-05-26T17:22:19Z",
      "comments": [
        {
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "body": "Agreed that the naming of the test vectors is a bit cryptic and would benefit from being better aligned with the spec. Also the meaning of some letters for the encoded version would be welcome since I don't think it is spelled out in the spec.",
          "createdAt": "2021-04-27T10:50:26Z",
          "updatedAt": "2021-04-27T10:50:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks Ben! We'll clean this up in the next version. ",
          "createdAt": "2021-04-27T12:22:24Z",
          "updatedAt": "2021-04-27T12:22:24Z"
        }
      ]
    },
    {
      "number": 219,
      "id": "MDU6SXNzdWU4ODQ3MTA3MTM=",
      "title": "Recipient vs. receiver inconsistency",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/219",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The draft uses \"recipient\" everywhere except for one place in section 3:\r\n\r\n> (skX, pkX): A Key Encapsulation Mechanism (KEM) key pair used in role X, where X is one of S, R, or E as sender, receiver, and ephemeral, respectively; skX is the private key and pkX is the public key.\r\n\r\nI probably would have gone with \"receiver\" as the analog of sender, though I don't know what the existing discussion or precedents are. (I don't believe either term appears in KDF labels, so this doesn't change the primitive itself.)\r\n\r\n(CC @agl)",
      "createdAt": "2021-05-10T17:33:37Z",
      "updatedAt": "2021-05-24T13:31:52Z",
      "closedAt": "2021-05-24T13:31:52Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @davidben! We'll fix this in the next version.",
          "createdAt": "2021-05-10T18:19:08Z",
          "updatedAt": "2021-05-10T18:19:08Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "MDU6SXNzdWU4OTcxNDg1NTY=",
      "title": "KEM failures and API considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/221",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This issue tracks two related questions:\r\n\r\n1. How should HPKE deal with implicit KEM failures? Should it raise errors early on (during context creation) or only when trying to decrypt data?\r\n2. Not all KEMs have an immediate \"is this key valid\" check, such as those based on lattices. How should the spec accommodate those?\r\n\r\nCurrently, context creation is fallible, which would need to change if the answer to both (1) and (2) is \"only fail during the AEAD operation\" (I think).\r\n\r\ncc @davidben, @martinthomson, @jedisct1, @bifurcation, @rozbb (please feel free to tag other implementers!)",
      "createdAt": "2021-05-20T17:12:18Z",
      "updatedAt": "2021-05-26T17:21:37Z",
      "closedAt": "2021-05-26T17:21:37Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "NONE",
          "body": "As discussed privately, my intuition is that dealing with implicit KEM failures only at decryption time might be simpler for applications anyway at the cost of the decryption attempt. Plus it sounds like current security proofs handle only perfectly correct KEMs outside of the DHKEM variant atm (@blipp can correct me if I am wrong).",
          "createdAt": "2021-05-20T17:39:27Z",
          "updatedAt": "2021-05-20T17:39:27Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are there any KEMs which have explicit Decap failures? We have the X25519 zero-check, but plenty of people think it's not necessary, so I could imagine removing it. I just glanced at Kyber, Frodo, SIKE, NTRU, McElice, and SABER, and all of them return a non-null value on Decaps (notably, the last 3 do have failure conditions, but they output something pseudorandom when that condition is reached).\r\n\r\nAs for implicit failures, this is something that we have plenty of already. For example, X25519AuthDecap currently produces the wrong symmetric key if given the wrong sender pubkey, and this is only detectable at the AEAD stage. We could theoretically push the error to the Decap stage by including a test payload with every encapped key. This would perhaps let users catch Auth/PSK errors more easily, and also detect implicit failures due to (extremely low probability) correctness errors like in FrodoKEM. The downside is that this would increase the size of encapsulated keys by 112-150%.",
          "createdAt": "2021-05-20T17:49:14Z",
          "updatedAt": "2021-05-20T17:49:14Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As an implementor, I don't think moving the failure makes sense. I suppose an implementation could move it if it *really* wanted to, but it doesn't seem like a good idea. (While the spec does specify operations, how exactly that manifests in your programming language is necessarily an implementation question. There are many considerations around the type system, how you want to represent HPKE ciphers, naming, etc.)\r\n\r\nFirst, I don't think the X25519 zero-check is that controversial. TLS mandates it, so I expect any TLS-adjacent implementation to use it. It should stay. HPKE also supports P-256, where both point-at-infinity and point-on-curve checks are quite well-established. (And necessary! Missing the point-on-curve check has the usual implications with uncompressed coordinates. Even with compressed coordinates, not every compressed input successfully finds a square root. Missing the point-at-infinity check means the output secret is not even defined.)\r\n\r\nSecond, Encap and Decap can fail for every KEM. Even ignoring failures inside the KEM, most of our programming languages do not have sufficiently strong type systems to reject keys and enc values of the wrong length at the type level. Even where they are strong enough, that's just shifting the check to the caller. At the end of the day, your protocol probably sends a variable-length string somewhere. Or the KEM may need to serialize something in a way that doesn't span the whole `[N]byte` space.\r\n\r\nFinally, you'd need to shift the failure to not just decryption, but also encryption (if the recipient public key is wrong) and export. Those do not have as natural of error cases as decryption, so shifting the error seems more error-prone.",
          "createdAt": "2021-05-20T18:03:02Z",
          "updatedAt": "2021-05-20T18:05:17Z"
        }
      ]
    },
    {
      "number": 226,
      "id": "MDU6SXNzdWU5MDk5MDMxOTA=",
      "title": "Guidance on how to use info and aad",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/226",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Should the spec include some guidance (not sure how detailed or for what audience) on when to use the `info` parameter to `Setup*` and when to use `aad` to `Seal` and `Open`? In particular, for protocols that only need the single-shot mode, both seem to serve roughly the same purpose. (Though they do work very differently internally...)\r\n\r\nOne difference I can see is you're better off sticking your label string into `info` since other protocols might not be single-shot. (Is it worth a suggestion to incorporate a label string into `info`.) @chris-wood also points out that processing `aad` with your AEAD's universal hash function is likely faster than processing `info` with your KDF. So there's probably some benefit to keeping bulk data in the `aad` side of things. But I also expect this is negligible compared to the KEM. :-)\r\n\r\n Beyond that, I'm not sure. `aad` is per-encryption and `info` is per-context, but what \"feels\" per-encryption vs per-context is a little hazy for single-shot uses.\r\n\r\n(CC @csharrison)",
      "createdAt": "2021-06-02T21:33:41Z",
      "updatedAt": "2021-07-07T15:49:15Z",
      "closedAt": "2021-07-07T15:49:15Z",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This discussion over at MLS seems related https://github.com/mlswg/mls-protocol/issues/470.",
          "createdAt": "2021-06-02T21:41:44Z",
          "updatedAt": "2021-06-02T21:41:44Z"
        }
      ]
    },
    {
      "number": 238,
      "id": "MDU6SXNzdWU5NzU2NTcyMTE=",
      "title": "Authentication Tag Length",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/238",
      "state": "CLOSED",
      "author": "jsalowey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While working on a Java HPKE implementation I noticed that the spec did not provide guidance for the AEAD authentication tag length.  ",
      "createdAt": "2021-08-20T14:22:11Z",
      "updatedAt": "2021-08-29T12:55:43Z",
      "closedAt": "2021-08-29T12:55:43Z",
      "comments": [
        {
          "author": "mouse07410",
          "authorAssociation": "NONE",
          "body": "I concur, and agree with your choice of the Auth tag length. ",
          "createdAt": "2021-08-23T19:13:58Z",
          "updatedAt": "2021-08-23T19:13:58Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg5MDcyNTg2",
      "title": "Comments from @dwd (and one thing I found)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/1",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-06-18T01:17:07Z",
      "updatedAt": "2019-07-02T16:48:34Z",
      "closedAt": "2019-07-02T16:48:34Z",
      "mergedAt": "2019-07-02T16:48:34Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2OTk3NDIw",
          "commit": {
            "abbreviatedOid": "1f394fe"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-02T16:05:51Z",
          "updatedAt": "2019-07-02T16:08:26Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n- `pk(skX)`: The public key corresponding to private key `skX`\r\n```",
              "createdAt": "2019-07-02T16:05:51Z",
              "updatedAt": "2019-07-02T16:46:46Z"
            },
            {
              "originalPosition": 17,
              "body": "Why is this needed?",
              "createdAt": "2019-07-02T16:06:28Z",
              "updatedAt": "2019-07-02T16:46:46Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n  context = concat(ciphersuite, mode,\r\n```",
              "createdAt": "2019-07-02T16:07:53Z",
              "updatedAt": "2019-07-02T16:46:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MDE5MDI2",
          "commit": {
            "abbreviatedOid": "1f394fe"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T16:46:01Z",
          "updatedAt": "2019-07-02T16:46:02Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "You mean the \"empty value\" part?  I thought it was needed for #2, but on further reflection, it need not be. ",
              "createdAt": "2019-07-02T16:46:01Z",
              "updatedAt": "2019-07-02T16:46:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MDE5OTE1",
          "commit": {
            "abbreviatedOid": "7a9cf49"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-02T16:47:49Z",
          "updatedAt": "2019-07-02T16:47:49Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\ud83d\udc4d I'd remove it if not used.",
              "createdAt": "2019-07-02T16:47:49Z",
              "updatedAt": "2019-07-02T16:47:49Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "39d01357849740a03daddfc980b8b65977c18b95",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "cridland",
      "headRefOid": "7a9cf49502d6d5e69067192a17b39c6915ebaef5",
      "mergeCommit": {
        "oid": "4f950e2a3b02da24e6296962f637f9767eac8d72"
      }
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzNDUzNDgx",
      "title": "Consolidate the key schedule",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/2",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Prior versions had a lot of repetitive logic in the `SetupX` functions.  This PR consolidates that logic into a single `KeySchedule` method with some optional inputs to reflect variation among the modes.  As a side effect, it's now trivial to add a mode where the initiator is authenticated to hold *both* a PSK and a private key.\r\n\r\nNB: Based on top of #1, so this will read better once that is landed.",
      "createdAt": "2019-07-01T18:39:33Z",
      "updatedAt": "2019-07-04T01:04:45Z",
      "closedAt": "2019-07-04T01:04:45Z",
      "mergedAt": "2019-07-04T01:04:44Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NzgzMzA5",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-04T00:15:48Z",
          "updatedAt": "2019-07-04T00:27:54Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nmechanism for translating the protocol inputs into an\r\n```",
              "createdAt": "2019-07-04T00:15:48Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nencryption context.  The key schedule inputs are as follows:\r\n```",
              "createdAt": "2019-07-04T00:16:06Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 43,
              "body": "Can one supply a `pskID` but not a `psk`?",
              "createdAt": "2019-07-04T00:19:09Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nIf any of the optional values is absent (e.g., set to `None`\r\n```",
              "createdAt": "2019-07-04T00:19:09Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 51,
              "body": "This seems to suggest that the key and nonce are outputs, but they're just put in the context. Perhaps we replace \"produced\" with \"computed\"?",
              "createdAt": "2019-07-04T00:19:09Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nin a Python implementation), then it is treated as\r\n```",
              "createdAt": "2019-07-04T00:19:09Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 65,
              "body": "nit: can we rename `salt` to `psk`? I had to go down to see its invocation to learn that salt is really the psk here.",
              "createdAt": "2019-07-04T00:19:48Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 61,
              "body": "nit: instead of `default`, perhaps `empty`? And perhaps replace `salt` with `psk`?",
              "createdAt": "2019-07-04T00:21:07Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 84,
              "body": "We don't include `len(pkIm)`?",
              "createdAt": "2019-07-04T00:21:54Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 84,
              "body": "Question: if `Nenc` is fixed for the cipher suite, do we need to encode the length here? (This doesn't seem like it'd match the TLS struct below, since `opaque enc[Nenc];` is a fixed-length array. ",
              "createdAt": "2019-07-04T00:25:16Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 80,
              "body": "nit: either this should be `salt`, or the `salt` parameter to `KeySchedule` should be `psk`, right?",
              "createdAt": "2019-07-04T00:25:54Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 65,
              "body": "(I recognize we use `salt` since it's more natural for `Extract`, though `psk` I think being clear about the nature of the value is probably better here.",
              "createdAt": "2019-07-04T00:26:43Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            },
            {
              "originalPosition": 31,
              "body": "I might rename this to Encryption Context, and then the function `KeySchedule` to `EncryptionContext`, respectively. That seems to better match what's happening here. ",
              "createdAt": "2019-07-04T00:27:51Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg4MTQw",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T00:48:04Z",
          "updatedAt": "2019-07-04T00:48:04Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Actually, this whole section needs rewriting after the update.",
              "createdAt": "2019-07-04T00:48:04Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg4Nzgy",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T00:52:15Z",
          "updatedAt": "2019-07-04T00:52:15Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "`pkIm` has fixed length `Npk`.",
              "createdAt": "2019-07-04T00:52:15Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg4ODQx",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T00:52:40Z",
          "updatedAt": "2019-07-04T00:52:40Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Don't like that; \"empty\" implies there's nothing there, whereas here clearly there is.",
              "createdAt": "2019-07-04T00:52:40Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg4OTMz",
          "commit": {
            "abbreviatedOid": "42bfa9f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-04T00:53:17Z",
          "updatedAt": "2019-07-04T00:53:17Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Good point.  Removed this length, and the length for `pkRm`, which is unnecessary for similar reasons.",
              "createdAt": "2019-07-04T00:53:17Z",
              "updatedAt": "2019-07-04T01:04:21Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4f950e2a3b02da24e6296962f637f9767eac8d72",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "omni",
      "headRefOid": "4e53ac17d073a7f31f05760b912a05217c3f9401",
      "mergeCommit": {
        "oid": "8a33ffe1dd68b57e8e56503714698d1faa625098"
      }
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzNDYyMDYz",
      "title": "Use individual algorithm identifiers as opposed to a suite ",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/3",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This has been the trend, e.g., with TLS 1.3, and there's no inherent need to conjoin these choices here, except for \"level matching\".\r\n\r\nNB: Based on top of #1 and #2, so this will read better once they're landed",
      "createdAt": "2019-07-01T19:08:10Z",
      "updatedAt": "2019-07-04T01:31:27Z",
      "closedAt": "2019-07-04T01:31:27Z",
      "mergedAt": "2019-07-04T01:31:27Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzg1Njkx",
          "commit": {
            "abbreviatedOid": "0ee0c5b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-04T00:31:49Z",
          "updatedAt": "2019-07-04T00:31:49Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8a33ffe1dd68b57e8e56503714698d1faa625098",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "no-suite",
      "headRefOid": "ab3d8e35e9ca772381fc69a09cac0cf730a0701d",
      "mergeCommit": {
        "oid": "01dcb8c9aa17059d73c84b1a3ffbbb38a8b163c7"
      }
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEzMzc5ODE1",
      "title": "Apply updates from the list",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/4",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@bifurcation please have a look!\r\n\r\ncc @FredericJacobs, too.",
      "createdAt": "2019-09-02T23:23:49Z",
      "updatedAt": "2019-09-15T17:04:12Z",
      "closedAt": "2019-09-06T20:07:56Z",
      "mergedAt": "2019-09-06T20:07:56Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzNTMyMTkx",
          "commit": {
            "abbreviatedOid": "905e4c7"
          },
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-04T10:53:11Z",
          "updatedAt": "2019-09-04T10:53:11Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0NDExMjU5",
          "commit": {
            "abbreviatedOid": "905e4c7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Minor comments, no need to re-review.",
          "createdAt": "2019-09-05T17:09:32Z",
          "updatedAt": "2019-09-05T17:18:59Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "It seems like this could be made fixed-length, of length Nh:\r\n\r\n```\r\nopaque info_hash[Nh];\r\n```\r\n\r\nAnd likewise, drop the `len(info_hash)` above.",
              "createdAt": "2019-09-05T17:09:32Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            },
            {
              "originalPosition": 79,
              "body": "Nit: s/which/that/",
              "createdAt": "2019-09-05T17:09:59Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            },
            {
              "originalPosition": 79,
              "body": "It might be good to specify what they need to encode, namely:\r\n\r\n* The encapsulated value `enc`\r\n* Ciphertext value(s), in order if multiple\r\n* Any info values that are not implicit",
              "createdAt": "2019-09-05T17:11:10Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            },
            {
              "originalPosition": 50,
              "body": "Also, we now have only one variable-length field in the context, `pskID`.  Maybe we should hash that as well?  Maybe that's a follow-on.",
              "createdAt": "2019-09-05T17:18:40Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg0NDQyNTkw",
          "commit": {
            "abbreviatedOid": "905e4c7"
          },
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-05T18:03:38Z",
          "updatedAt": "2019-09-05T18:03:38Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "That's probably a good idea to get rid of variable-size fields.",
              "createdAt": "2019-09-05T18:03:38Z",
              "updatedAt": "2019-09-06T20:04:31Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "01dcb8c9aa17059d73c84b1a3ffbbb38a8b163c7",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/edits",
      "headRefOid": "b000857533b34b2befa3c6f7afa4e2033e6e89b4",
      "mergeCommit": {
        "oid": "15f9a03034d0ff33c87b66bedcc09a1d68d4b582"
      }
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE1NzA5NDg0",
      "title": "Add single-shot APIs.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/5",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Many applications may not need to use an encryption context for more than one message.\r\nThe current separation therefore adds complexity to clients which do not wrap\r\nthe Setup+Seal pattern in a single function. This change adds such a helper wrapper.",
      "createdAt": "2019-09-09T20:47:38Z",
      "updatedAt": "2019-09-14T13:57:27Z",
      "closedAt": "2019-09-14T13:57:27Z",
      "mergedAt": "2019-09-14T13:57:27Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1ODAxOTcx",
          "commit": {
            "abbreviatedOid": "87b3d39"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-09-09T21:43:45Z",
          "updatedAt": "2019-09-09T22:34:34Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "You're going to need to fence these with `~~~` and make the lines shorter, or else they're not going to render well.",
              "createdAt": "2019-09-09T21:43:45Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 53,
              "body": "The `HPKE` at the front of these seems unnecessary, given that's what the whole document is about.",
              "createdAt": "2019-09-09T21:44:40Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 53,
              "body": "The order of parameters seems unaesthetic to me.  My preference would be to go in the order you're going to use them: pkR, info, aad, pt.\r\n\r\nSo for example `SealBase(pkR, info, aad, pt) = ContextSeal(SetupBaseI(pkR, info), aad, pt)",
              "createdAt": "2019-09-09T21:47:15Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 48,
              "body": "I would still like this better if we just left it in a form that someone could fill in in the obvious way:\r\n\r\n```\r\ndef SealMODE(pkR, info, aad, pt, ...):\r\n  enc, ctx = SetupIMODE(pkR, info, ...)\r\n  ct = ctx.sesal(aad, pt)\r\n  return enc, ct\r\n```\r\n\r\nYou can actually [implement things exactly this way](https://gist.github.com/bifurcation/4bb8a0444d5abe41fbe8a816a282b0fb) in C++: \r\n\r\n```\r\ntemplate<Mode M, typename... Args>\r\ntuple<EncapsulatedKey, EncryptionContext>\r\nsetupI(const PublicKey& pkR, const Bytes& info, const Args&... args);\r\n\r\n// ... instantiations ...\r\n\r\ntemplate<Mode M, typename... Args>\r\ntuple<EncapsulatedKey, Bytes>\r\nseal(const PublicKey& pkR,\r\n     const Bytes& info,\r\n     const Bytes& aad,\r\n     const Bytes& pt,\r\n     const Args&... args)\r\n{\r\n  auto [enc, ctx] = setupI<M>(pkR, info, args...);\r\n  auto ct = ctx.seal(aad, pt);\r\n  return { enc, ct };\r\n}\r\n```",
              "createdAt": "2019-09-09T22:34:02Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1ODM1MjQ3",
          "commit": {
            "abbreviatedOid": "87b3d39"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T23:23:38Z",
          "updatedAt": "2019-09-09T23:23:38Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": ":+1: agreed! With the template change, this should be fixed.",
              "createdAt": "2019-09-09T23:23:38Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1ODM1NDEw",
          "commit": {
            "abbreviatedOid": "87b3d39"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-09T23:24:13Z",
          "updatedAt": "2019-09-09T23:24:13Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Good idea! I refactored it a bit based on this suggestion. Please have a look.",
              "createdAt": "2019-09-09T23:24:13Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg3MTUwNjkx",
          "commit": {
            "abbreviatedOid": "31b2ef9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-12T01:17:35Z",
          "updatedAt": "2019-09-12T01:20:01Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Nice, I like the angle brackets",
              "createdAt": "2019-09-12T01:17:35Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 40,
              "body": "WLOG seems unnecessary.  I would just eliminate this sentence and end the prior sentence with a colon.",
              "createdAt": "2019-09-12T01:18:10Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 54,
              "body": "Maybe `The optional parameters indicated by \"...\"`",
              "createdAt": "2019-09-12T01:18:56Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 58,
              "body": "Don't you mean `SealAuthPSK`?",
              "createdAt": "2019-09-12T01:19:16Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            },
            {
              "originalPosition": 58,
              "body": "s/Using such a template/Thus/\r\ns/might be/would be/",
              "createdAt": "2019-09-12T01:19:56Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg3MTU5MTEz",
          "commit": {
            "abbreviatedOid": "31b2ef9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-12T01:58:48Z",
          "updatedAt": "2019-09-12T01:58:49Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Works for me!",
              "createdAt": "2019-09-12T01:58:49Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg3MTU5MjIy",
          "commit": {
            "abbreviatedOid": "31b2ef9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-12T01:59:19Z",
          "updatedAt": "2019-09-12T01:59:19Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "> Don't you mean SealAuthPSK?\r\n \r\nOops, yeah. Will fix.",
              "createdAt": "2019-09-12T01:59:19Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg4MTgzODQw",
          "commit": {
            "abbreviatedOid": "567f63b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-13T18:33:32Z",
          "updatedAt": "2019-09-13T18:33:32Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "We should make sure that the templates actually expand here.  Based on the AuthPSK example above, it looks like there are at least two issues:\r\n\r\n* `SetupR<MODE>` vs. `Setup<MODE>R`\r\n* Parameter order (standard parameters first)",
              "createdAt": "2019-09-13T18:33:32Z",
              "updatedAt": "2019-09-13T21:36:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg4MjYzMTk4",
          "commit": {
            "abbreviatedOid": "6cd4833"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-13T21:37:43Z",
          "updatedAt": "2019-09-13T21:37:43Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Great catch! Should be fixed now. ",
              "createdAt": "2019-09-13T21:37:43Z",
              "updatedAt": "2019-09-13T21:37:43Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "15f9a03034d0ff33c87b66bedcc09a1d68d4b582",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/single-shot",
      "headRefOid": "6cd4833fafb0b88760673c3c2d2c8540f5bf4113",
      "mergeCommit": {
        "oid": "71f398052e3c67811096b626350d676a7c5a7d15"
      }
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE3NjU1MjMy",
      "title": "Editorial fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/6",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, apply a couple editorial fixes.\r\n\r\ncc @bifurcation ",
      "createdAt": "2019-09-15T17:15:43Z",
      "updatedAt": "2019-09-18T22:20:20Z",
      "closedAt": "2019-09-18T22:20:19Z",
      "mergedAt": "2019-09-18T22:20:19Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "71f398052e3c67811096b626350d676a7c5a7d15",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/edits",
      "headRefOid": "716a96603cdfb04da950c3cb1073b4e6a96a860f",
      "mergeCommit": {
        "oid": "4df6d6a5b1b3068add9b6f650fb47dd963d33189"
      }
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMzQ0MDUy",
      "title": "Clarify pkI/pkIm usage",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/7",
      "state": "CLOSED",
      "author": "dwd",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-01T15:43:57Z",
      "updatedAt": "2019-11-04T17:50:37Z",
      "closedAt": "2019-11-04T17:02:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is incorporated by the current draft, so we can close it. @dwd please re-open if you disagree!",
          "createdAt": "2019-11-04T17:02:40Z",
          "updatedAt": "2019-11-04T17:02:53Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe the issue is not yet resolved; so either this pull-request should be re-opened or a new one created:\r\n\r\nIn the current draft (looking at branch master):\r\n```\r\ndef KeySchedule(mode, pkRm, zz, enc, info, psk, pskID, pkIm):\r\n  VerifyMode(mode, psk, pskID, pkI)\r\n\r\n  pkRm = Marshal(pkR)\r\n```\r\n- `pkRm` is given as parameter to `KeySchedule` but is calculated from `pkR` inside (suggestion: remove the line calculating it)\r\n- `pkI` is passed to `VerifyMode`, should be `pkIm`.\r\n\r\nThe explanations of `pkIm` and `pkRm` suggested by @dwd could also be interesting, because at the moment they are only defined implicitly.",
          "createdAt": "2019-11-04T17:50:37Z",
          "updatedAt": "2019-11-04T17:50:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1MzEzNTU5",
          "commit": {
            "abbreviatedOid": "d8e0c50"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-22T15:44:32Z",
          "updatedAt": "2019-10-22T15:45:12Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Should we pass in `pkRm` instead?",
              "createdAt": "2019-10-22T15:44:33Z",
              "updatedAt": "2019-10-22T15:45:12Z"
            },
            {
              "originalPosition": 4,
              "body": "This is not currently an input, and if it were, then we should not send `pkR`.",
              "createdAt": "2019-10-22T15:44:59Z",
              "updatedAt": "2019-10-22T15:45:12Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4df6d6a5b1b3068add9b6f650fb47dd963d33189",
      "headRepository": "dwd/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "d8e0c5076432bf34d50d8ee90b774c30bf2a00c4",
      "mergeCommit": null
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxMDcwNjQx",
      "title": "Add missing mode parameters",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/8",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In Sections 6.3, 6.4, and 6.5 is seems like KeySchedule's mode parameter is missing.",
      "createdAt": "2019-10-22T15:53:26Z",
      "updatedAt": "2019-10-30T22:46:07Z",
      "closedAt": "2019-10-30T22:46:07Z",
      "mergedAt": "2019-10-30T22:46:07Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTU5Nzkx",
          "commit": {
            "abbreviatedOid": "48560c7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:29:35Z",
          "updatedAt": "2019-10-30T22:29:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTY1NDkw",
          "commit": {
            "abbreviatedOid": "48560c7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:45:41Z",
          "updatedAt": "2019-10-30T22:45:41Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4df6d6a5b1b3068add9b6f650fb47dd963d33189",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_modes",
      "headRefOid": "48560c7eca9002ad7d394e4889939857e6d5eafe",
      "mergeCommit": {
        "oid": "6c1357e79f70c4965cdd0538bdaf5b6b105b3864"
      }
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxMzQ2NDY3",
      "title": "Add test vectors and remove lingering TODOs.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/9",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The script I used for formatting the JSON vectors is here: https://gist.github.com/chris-wood/e4309b89491ea9483062eb95c4ca5dd7",
      "createdAt": "2019-10-23T05:27:53Z",
      "updatedAt": "2019-10-23T23:13:58Z",
      "closedAt": "2019-10-23T23:13:57Z",
      "mergedAt": "2019-10-23T23:13:57Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1ODkzOTkw",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T13:34:58Z",
          "updatedAt": "2019-10-23T14:17:43Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "That URL doesn't actually exist :)\r\n\r\nIf you're going to add such a link, please add the file in the same PR.  And even then, the URL should be something like `https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/vectors.json`.\r\n\r\nNit: I would prefer `test-vectors.json`",
              "createdAt": "2019-10-23T13:34:58Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            },
            {
              "originalPosition": 23,
              "body": "Might be clearer if we had some hierarchy here: \r\n\r\n```\r\n## DHKEM(P-256), HKDF-SHA256, AES-GCM-128\r\n### Base\r\n### PSK\r\n### Auth\r\n### AuthPSK\r\n## DHKEM(Curve25519), HKDF-SHA256, ChaCha20Poly1305\r\n### [[ As above ]]\r\n## DHKEM(P-521), HKDF-SHA256, AES-GCM-256\r\n### [[ As above ]]\r\n```\r\n\r\nNote also: Suggest doing GCM with P-256 and ChaCHa with X25519, so that we get a fully non-NIST suite (except SHA).\r\n",
              "createdAt": "2019-10-23T13:36:49Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            },
            {
              "originalPosition": 33,
              "body": "I have a slight preference for just putting JSON in here.  Is there a particular reason to prefer this format?  Maybe the wrapping is easier?  For wrapping JSON, I would propose just pretending it as JS, e.g.,\r\n\r\n```\r\n{\r\n  \"zz: \"4a75c8fdba6bc5ae73a014071085931b814266dab50cf54cfacef1275294b9007ad5\" +\r\n       \"c9fdec1128c62bdbfa41eb604ff9488cda8fc3ef9c99015a7b61e730347e\"\r\n}\r\n```\r\n\r\nIf you end up writing a tool to do JSON wrapping, we should make sure to put that somewhere it can be reused.",
              "createdAt": "2019-10-23T13:40:38Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            },
            {
              "originalPosition": 61,
              "body": "What we're really testing here is the nonce updating logic.  So:\r\n* Doing a different pattern might better exercise the relevant code, e.g., seq=0,1,2,4,...\r\n* You should output the nonce here",
              "createdAt": "2019-10-23T13:47:00Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE1MDky",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T21:54:45Z",
          "updatedAt": "2019-10-23T21:54:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "That works for me. I'll add the file to this PR.",
              "createdAt": "2019-10-23T21:54:45Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE1MjU0",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T21:55:05Z",
          "updatedAt": "2019-10-23T21:55:06Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I'll shuffle things around to do that, yeah.",
              "createdAt": "2019-10-23T21:55:05Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjE3MjQ2",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T21:59:45Z",
          "updatedAt": "2019-10-23T21:59:45Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Mainly, the formatting seemed cleaner and the additional pointer to the JSON format could help those which want to ingest them with minimal effort. (In contrast, if we did the quirky JSON wrapping in the document, without a JSON link, then folks would have to reconstruct it themselves.)",
              "createdAt": "2019-10-23T21:59:45Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjMxMDE0",
          "commit": {
            "abbreviatedOid": "c326749"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T22:36:06Z",
          "updatedAt": "2019-10-23T22:36:06Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Done!",
              "createdAt": "2019-10-23T22:36:06Z",
              "updatedAt": "2019-10-23T22:39:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2MjQzNTAy",
          "commit": {
            "abbreviatedOid": "99453d6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-23T23:13:50Z",
          "updatedAt": "2019-10-23T23:13:50Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4df6d6a5b1b3068add9b6f650fb47dd963d33189",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/test-vectors",
      "headRefOid": "99453d674292253633ddffdb2749bcade0a177ee",
      "mergeCommit": {
        "oid": "62cb35ee763163a0aca16590bc6c002d6e3b4b03"
      }
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0MTQzMDQw",
      "title": "Fix parameters in Single-Shot APIs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/11",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`OpenAuthPSK` was missing parameters, and the call to `SetupAuthPSKR` used `skI` instead of `pkI`.",
      "createdAt": "2019-10-30T10:15:22Z",
      "updatedAt": "2019-10-30T22:44:25Z",
      "closedAt": "2019-10-30T22:44:25Z",
      "mergedAt": "2019-10-30T22:44:25Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTU5NjMw",
          "commit": {
            "abbreviatedOid": "c113b97"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:29:06Z",
          "updatedAt": "2019-10-30T22:29:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTY0OTQ4",
          "commit": {
            "abbreviatedOid": "c113b97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:44:19Z",
          "updatedAt": "2019-10-30T22:44:19Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "62cb35ee763163a0aca16590bc6c002d6e3b4b03",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_singleshot",
      "headRefOid": "c113b97c44de4225de5c6074a7f493f195cfb730",
      "mergeCommit": {
        "oid": "e866ebafed825b23170a82a449b7e552fe258536"
      }
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MzU2NjY4",
      "title": "Fix test vectors. Remove some options to cut down on text.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/13",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-04T16:06:39Z",
      "updatedAt": "2019-11-04T16:41:33Z",
      "closedAt": "2019-11-04T16:41:33Z",
      "mergedAt": "2019-11-04T16:41:33Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjAyNzUz",
          "commit": {
            "abbreviatedOid": "2220a95"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T16:41:28Z",
          "updatedAt": "2019-11-04T16:41:28Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "6c1357e79f70c4965cdd0538bdaf5b6b105b3864",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/vectors-take-2",
      "headRefOid": "2220a95748d47ed084c9543d323c427aef01f98a",
      "mergeCommit": {
        "oid": "c5d76bf2fae5656eaf89833b4e6149e04c31d790"
      }
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MzcxODg3",
      "title": "Security Considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/14",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-04T16:38:12Z",
      "updatedAt": "2019-11-04T17:22:19Z",
      "closedAt": "2019-11-04T17:22:19Z",
      "mergedAt": "2019-11-04T17:22:19Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA2NTI5",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T16:46:43Z",
          "updatedAt": "2019-11-04T16:46:44Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "I wonder if this should be replaced with a more general \"use cases\" section in the document?",
              "createdAt": "2019-11-04T16:46:44Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA2Nzg4",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T16:47:05Z",
          "updatedAt": "2019-11-04T16:47:05Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "```suggestion\r\nThis scheme is re-uses the authentication scheme of the underlying\r\n```",
              "createdAt": "2019-11-04T16:47:05Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA2OTA0",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T16:47:14Z",
          "updatedAt": "2019-11-04T16:47:15Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "```suggestion\r\nAEAD algorithm, while using the KEM to establish a one-time authentication\r\n```",
              "createdAt": "2019-11-04T16:47:15Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA3MjM5",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T16:47:42Z",
          "updatedAt": "2019-11-04T16:47:43Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "I'd drop the last sentence.",
              "createdAt": "2019-11-04T16:47:42Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjA3NDA1",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T16:47:55Z",
          "updatedAt": "2019-11-04T16:47:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjI4Mjcw",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T17:19:22Z",
          "updatedAt": "2019-11-04T17:19:22Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "No, I think this is correct as-is -- e.g., with AES-GCM, we're not really using AES, we're using GMAC.",
              "createdAt": "2019-11-04T17:19:22Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjI4NDIw",
          "commit": {
            "abbreviatedOid": "ab84319"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T17:19:35Z",
          "updatedAt": "2019-11-04T17:19:35Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Maybe, but I'm inclined to just do this for now.",
              "createdAt": "2019-11-04T17:19:35Z",
              "updatedAt": "2019-11-04T17:20:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjI5NDA1",
          "commit": {
            "abbreviatedOid": "0fa0658"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T17:21:15Z",
          "updatedAt": "2019-11-04T17:21:16Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "I get that, but the suggestion doesn't change that fact? It's purely editorial.",
              "createdAt": "2019-11-04T17:21:16Z",
              "updatedAt": "2019-11-04T17:21:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjI5NTM4",
          "commit": {
            "abbreviatedOid": "0fa0658"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-04T17:21:25Z",
          "updatedAt": "2019-11-04T17:21:26Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Yep, just food for thought in the future.",
              "createdAt": "2019-11-04T17:21:25Z",
              "updatedAt": "2019-11-04T17:21:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjMwMDIy",
          "commit": {
            "abbreviatedOid": "0fa0658"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T17:22:13Z",
          "updatedAt": "2019-11-04T17:22:13Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "6c1357e79f70c4965cdd0538bdaf5b6b105b3864",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "security-considerations",
      "headRefOid": "0fa0658f0b81e718d207472c44c20dae0d06cc06",
      "mergeCommit": {
        "oid": "6d0a4b16b085d967d7c3ecb2d6bb8b0a4aef8057"
      }
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2Mzc0OTQ0",
      "title": "Fix broken SECG link found by @blipp",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/15",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #10 ",
      "createdAt": "2019-11-04T16:44:45Z",
      "updatedAt": "2019-11-04T16:45:14Z",
      "closedAt": "2019-11-04T16:45:14Z",
      "mergedAt": "2019-11-04T16:45:14Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c5d76bf2fae5656eaf89833b4e6149e04c31d790",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "ref-fix",
      "headRefOid": "26336b03cc61a6f898c502be39033866f20fb364",
      "mergeCommit": {
        "oid": "e65f76e92a7f5de2a081ade0f0a5f462b34c9a97"
      }
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2Mzc5ODU4",
      "title": "IANA Considerations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/17",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-04T16:55:27Z",
      "updatedAt": "2019-11-04T16:59:57Z",
      "closedAt": "2019-11-04T16:59:57Z",
      "mergedAt": "2019-11-04T16:59:57Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjE1OTMx",
          "commit": {
            "abbreviatedOid": "7e60a62"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T16:59:52Z",
          "updatedAt": "2019-11-04T16:59:52Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "e65f76e92a7f5de2a081ade0f0a5f462b34c9a97",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "iana",
      "headRefOid": "7e60a629b852c4de298e8b590275250cb2e5fae8",
      "mergeCommit": {
        "oid": "813fa48de8e15d472e3e418d3b50040d9848ec2f"
      }
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MzgzMDE2",
      "title": "Remove references to the encryption context.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/18",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-04T17:02:18Z",
      "updatedAt": "2019-11-04T17:30:04Z",
      "closedAt": "2019-11-04T17:30:04Z",
      "mergedAt": "2019-11-04T17:30:04Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExMjM0OTAx",
          "commit": {
            "abbreviatedOid": "edda2fa"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T17:29:58Z",
          "updatedAt": "2019-11-04T17:29:58Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "813fa48de8e15d472e3e418d3b50040d9848ec2f",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/no-more-encryption-context",
      "headRefOid": "edda2fabdec311da45c4746e1d81d41543021163",
      "mergeCommit": {
        "oid": "f7173b56308a8f9244acdf54d9bd5e1cea9cda62"
      }
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ2NDAxMDky",
      "title": "Mattson comments",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/23",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-27T19:46:50Z",
      "updatedAt": "2020-01-23T17:16:35Z",
      "closedAt": "2020-01-23T17:16:35Z",
      "mergedAt": "2020-01-23T17:16:35Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0OTY4NTM2",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Typos.\r\n\r\nI tend to agree with others about reducing the number of primitives.",
          "createdAt": "2019-12-01T22:35:55Z",
          "updatedAt": "2019-12-01T22:37:06Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n  Context.Open function in the same order they were generated by Context.Seal\r\n```",
              "createdAt": "2019-12-01T22:35:55Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            },
            {
              "originalPosition": 123,
              "body": "What is an \"ompon\"?",
              "createdAt": "2019-12-01T22:36:09Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\n## External Requirements / Non-Goals\r\n```",
              "createdAt": "2019-12-01T22:36:21Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0OTc4NTYy",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "knarz",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-02T00:51:13Z",
          "updatedAt": "2019-12-02T00:51:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "s/usign/using/",
              "createdAt": "2019-12-02T00:51:13Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2NDQ5MDkw",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-03T21:08:12Z",
          "updatedAt": "2019-12-03T21:10:15Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nencrypted using that key.  This type of public key encryption has many\r\n```",
              "createdAt": "2019-12-03T21:08:13Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            },
            {
              "originalPosition": 138,
              "body": "The ciphertext also leaks if the public key is compromised before the ciphertext is created, so perhaps:\r\n\r\n```\r\n* Forward secrecy - HPKE ciphertexts are not forward-secure.  A given ciphertext\r\n   can be decrypted if the recipient's public encryption key is compromised.\r\n```",
              "createdAt": "2019-12-03T21:10:11Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MzkzOTE0",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T15:44:13Z",
          "updatedAt": "2020-01-20T15:44:14Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "In `mode_auth_psk`, the recipient's public key _and_ the psk need to be compromised. Suggestion:\r\n\r\n```\r\n* Forward secrecy - HPKE ciphertexts are not forward-secure. In mode_base\r\n  and mode_auth, a given ciphertext can be decrypted if the recipient's public\r\n  encryption key is compromised. In mode_psk and mode_auth_psk, a given\r\n  ciphertext can be decrypted if the recipient's public encryption key and the\r\n  psk are compromised.\r\n```",
              "createdAt": "2020-01-20T15:44:14Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NDE5MTM0",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T16:24:00Z",
          "updatedAt": "2020-01-20T16:24:00Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Good suggestion!",
              "createdAt": "2020-01-20T16:24:00Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTU4NjU4",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T22:36:55Z",
          "updatedAt": "2020-01-20T22:36:56Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Note that this confuses post-compromise security and forward secrecy.  See the recent discussion on the lake list on this point.  In short, a PSK mode could have FS, but cannot have PCS.",
              "createdAt": "2020-01-20T22:36:56Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTYxNzgw",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T22:49:09Z",
          "updatedAt": "2020-01-20T22:49:09Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "Hmm, I don't think this is true. (I agree with the claim about achieving FS by hash-racheting the PSK.). @blipp's text simply says that if the private key material is compromised, bad things happen. It doesn't rule out FS should that keying material be updated. I think the text is fine as is.",
              "createdAt": "2020-01-20T22:49:09Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1OTQ2NDc1",
          "commit": {
            "abbreviatedOid": "004d15b"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-21T15:04:35Z",
          "updatedAt": "2020-01-21T15:04:36Z",
          "comments": [
            {
              "originalPosition": 138,
              "body": "I am not on the lake list, so I don't know what was discussed there (just mentioning such that you can read the following with a grain of salt).\r\n\r\nIn `mode_psk` and `mode_auth_psk`, it's right that if _only one_ of (psk, skR) gets compromised after encrypting the plaintext, the plaintext stays secret. That's some weird kind of forward secrecy assuming that skR and psk are stored sufficiently separated (weird because new ciphertexts are still created with the same key material, there is no key update, no transition to a new epoch, etc). I have a proof for this property within my analysis. I think it's a good idea to mention this in the security considerations section, but maybe it's already implicit with my previous text suggestion.\r\n\r\nA protocol building upon HPKE could try to add better properties, but I am not sure if this would be out of scope of this draft?",
              "createdAt": "2020-01-21T15:04:36Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MDM1MTE3",
          "commit": {
            "abbreviatedOid": "201c2af"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T02:56:47Z",
          "updatedAt": "2020-01-23T02:56:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDY2NjQ2",
          "commit": {
            "abbreviatedOid": "201c2af"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T17:10:38Z",
          "updatedAt": "2020-01-23T17:11:13Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "Nit: \"PSK\" (caps)",
              "createdAt": "2020-01-23T17:10:38Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDcwMjI4",
          "commit": {
            "abbreviatedOid": "201c2af"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T17:16:04Z",
          "updatedAt": "2020-01-23T17:16:05Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "```suggestion\r\n  PSK are compromised.\r\n```",
              "createdAt": "2020-01-23T17:16:04Z",
              "updatedAt": "2020-01-23T17:16:11Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0788c5536297926ccc17009cfd24eb9adb9a3bd0",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "mattson",
      "headRefOid": "08deb84f57fe2673f4213d4a5822dc46cf5ecc5c",
      "mergeCommit": {
        "oid": "d41dbb654900f47bf09b022d3774c21262c46a17"
      }
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ3NjQxNjk0",
      "title": "update KeySchedule to remove pkRm redundancy",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/24",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-12-02T14:05:46Z",
      "updatedAt": "2019-12-05T14:14:24Z",
      "closedAt": "2019-12-05T14:09:36Z",
      "mergedAt": "2019-12-05T14:09:36Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Current callers of `KeySchedule` pass in `pkR`, not `pkRm`, so I think the correct thing here is to rename the KeySchedule parameter `pkRm` to `pkR`.",
          "createdAt": "2019-12-03T21:11:58Z",
          "updatedAt": "2019-12-03T21:11:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere I merged this before I saw Chris's comment.  I agree with his point, so I reverted.  Could you please update and submit a new PR?",
          "createdAt": "2019-12-05T14:14:24Z",
          "updatedAt": "2019-12-05T14:14:24Z"
        }
      ],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0788c5536297926ccc17009cfd24eb9adb9a3bd0",
      "headRepository": "suhasHere/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "1720daf6d69cd9a63c25f422a01198b91bb4746b",
      "mergeCommit": {
        "oid": "43fc1cda50d4def683e4b59f517416a9f6126a65"
      }
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ5NDYxNTU5",
      "title": "Revert \"update KeySchedule to remove pkRm redundancy\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/25",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reverts cfrg/draft-irtf-cfrg-hpke#24",
      "createdAt": "2019-12-05T14:12:04Z",
      "updatedAt": "2019-12-05T14:13:45Z",
      "closedAt": "2019-12-05T14:13:45Z",
      "mergedAt": "2019-12-05T14:13:45Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "43fc1cda50d4def683e4b59f517416a9f6126a65",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "revert-24-master",
      "headRefOid": "054f58d897b65f8741f18a4a488cdd6eeed487ec",
      "mergeCommit": {
        "oid": "3d79c0f24fbf43474e47da8ca069bea521eed071"
      }
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUwMjc0OTc5",
      "title": "fix pkrm computation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/26",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-12-07T04:27:30Z",
      "updatedAt": "2019-12-12T18:15:35Z",
      "closedAt": "2019-12-12T18:15:35Z",
      "mergedAt": "2019-12-12T18:15:35Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNDI3MTk5",
          "commit": {
            "abbreviatedOid": "5c43e3d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-12T18:15:29Z",
          "updatedAt": "2019-12-12T18:15:29Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3d79c0f24fbf43474e47da8ca069bea521eed071",
      "headRepository": "suhasHere/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "5c43e3da49fbb53f7de84b95f9acabf3ed8b19e1",
      "mergeCommit": {
        "oid": "9783537f604b3b2726ed0a8c64e6afd50e8e9d1e"
      }
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUyNTQ5MjU0",
      "title": "Add Export interface",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/27",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some applications of HPKE, such as ESNI, require a way to produce a unique value from a HPKE \"invocation\". (For ESNI, this would replace a client-generated nonce that is separate from HPKE entirely.) This change derives an additional exporter secret alongside the HPKE key and nonce, and then adds an Export API that can be used to derive additional secrets from this key using the KDF's `Expand` function.",
      "createdAt": "2019-12-12T18:22:08Z",
      "updatedAt": "2019-12-15T02:34:27Z",
      "closedAt": "2019-12-15T02:34:26Z",
      "mergedAt": "2019-12-15T02:34:26Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNDUyNjE0",
          "commit": {
            "abbreviatedOid": "dfe7fd0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-12T18:58:36Z",
          "updatedAt": "2019-12-12T18:58:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Note that this is different from the TLS exporter, which has both a label and a context.  Might not need all of that here, though.\r\n\r\n```\r\n   TLS-Exporter(label, context_value, key_length) =\r\n       HKDF-Expand-Label(Derive-Secret(Secret, label, \"\"),\r\n                         \"exporter\", Hash(context_value), key_length)\r\n```",
              "createdAt": "2019-12-12T18:58:36Z",
              "updatedAt": "2019-12-12T18:58:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNDUyNjcx",
          "commit": {
            "abbreviatedOid": "dfe7fd0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-12T18:58:42Z",
          "updatedAt": "2019-12-12T18:58:42Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "9783537f604b3b2726ed0a8c64e6afd50e8e9d1e",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/edits-and-exporter",
      "headRefOid": "dfe7fd03691b1900f85415b9281750c29c4a9a58",
      "mergeCommit": {
        "oid": "61e80255c5c69f23f3febe007a572a111a3352ba"
      }
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2MTU4NjI4",
      "title": "s/mode_psk_auth/mode_auth_psk.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/31",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #21.",
      "createdAt": "2020-01-23T02:59:44Z",
      "updatedAt": "2020-01-23T17:20:23Z",
      "closedAt": "2020-01-23T17:20:23Z",
      "mergedAt": "2020-01-23T17:20:23Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation #23 should resolve the CI issue above. ",
          "createdAt": "2020-01-23T03:04:54Z",
          "updatedAt": "2020-01-23T03:04:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDcyOTI1",
          "commit": {
            "abbreviatedOid": "7f568f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T17:20:17Z",
          "updatedAt": "2020-01-23T17:20:17Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d41dbb654900f47bf09b022d3774c21262c46a17",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/auth-psk-naming",
      "headRefOid": "7f568f55d1e1c3f5b19fe141a3850e8d2b7a2e05",
      "mergeCommit": {
        "oid": "456eadc80ee02c6064e3ce3591de59f83be45049"
      }
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2MTU5MTEw",
      "title": "Fix VerifyMode parameter name.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/32",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #19.",
      "createdAt": "2020-01-23T03:02:30Z",
      "updatedAt": "2020-01-23T17:21:16Z",
      "closedAt": "2020-01-23T17:21:15Z",
      "mergedAt": "2020-01-23T17:21:15Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation #23 should resolve the CI issue above. ",
          "createdAt": "2020-01-23T03:05:03Z",
          "updatedAt": "2020-01-23T03:05:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDczNDcz",
          "commit": {
            "abbreviatedOid": "ed3644b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-23T17:21:09Z",
          "updatedAt": "2020-01-23T17:21:09Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d41dbb654900f47bf09b022d3774c21262c46a17",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/key-schedule-notation",
      "headRefOid": "ed3644b5dbcf12ddb849fb284ef1e619cd2c677f",
      "mergeCommit": {
        "oid": "a3ae7b301f6c95922b0897097dae8d03103f83bb"
      }
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY2MTYxNzE3",
      "title": "Clarify unidirectional nature of encryption contexts.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/33",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #29.",
      "createdAt": "2020-01-23T03:17:10Z",
      "updatedAt": "2020-01-24T15:36:44Z",
      "closedAt": "2020-01-24T15:36:44Z",
      "mergedAt": "2020-01-24T15:36:44Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDgyMTY5",
          "commit": {
            "abbreviatedOid": "a677637"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T17:35:15Z",
          "updatedAt": "2020-01-23T17:35:21Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "The additions here seem overly restrictive for a low-level document like this.  The underlying hard requirement is that each nonce value MUST be used only once, so in the event of bidirectional comms, the initiator and responder need to coordinate on which nonces belong to which sender.  For example, they might agree that the initiator sends with even-numbered nonces, and the responder with odd-numbered.  Of course, the details of such a scheme are up to the application.  The simplest such scheme is to use a given HPKE interaction for unidirectional communication, so that the initiator's context would only be used for encrypting and the responder's only for decrypting.",
              "createdAt": "2020-01-23T17:35:15Z",
              "updatedAt": "2020-01-24T15:28:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3NDg3ODMy",
          "commit": {
            "abbreviatedOid": "a677637"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-23T17:44:48Z",
          "updatedAt": "2020-01-23T17:44:48Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "> they might agree that the initiator sends with even-numbered nonces, and the responder with odd-numbered.\r\n\r\nI agree that this is possible, but the document (as specified) doesn't do this. Each sequence number starts at 0 and is always incremented by 1. \r\n\r\n> The simplest such scheme is to use a given HPKE interaction for unidirectional communication\r\n\r\nMaybe we can simplify the text to say this? That is, each context must only be used for unidirectional communication.",
              "createdAt": "2020-01-23T17:44:48Z",
              "updatedAt": "2020-01-24T15:28:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDEzMTEz",
          "commit": {
            "abbreviatedOid": "a677637"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T15:03:43Z",
          "updatedAt": "2020-01-24T15:03:44Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Ok, I'm coming around on this.  If we're going to lock it down, though, let's lock it down.  Namely, the multi-stage encryption here is just an extension of the single-stage version to allow the sender to stream data:\r\n\r\n* Initiator's context MUST be used for encryption only\r\n* Responder's context MUST be used for decryption only\r\n* Any other case, use the exporter\r\n\r\nMaybe we should be more explicit that this is streaming PKE (thus unidirectional I->R).  Should we reflect this in the pseudocode?",
              "createdAt": "2020-01-24T15:03:44Z",
              "updatedAt": "2020-01-24T15:28:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDI0NzIx",
          "commit": {
            "abbreviatedOid": "a677637"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-24T15:20:37Z",
          "updatedAt": "2020-01-24T15:20:37Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "The proposed text works for me! \r\n\r\n> Maybe we should be more explicit that this is streaming PKE (thus unidirectional I->R). Should we reflect this in the pseudocode?\r\n\r\nI don't think that's needed. But maybe others will suggest differently?",
              "createdAt": "2020-01-24T15:20:37Z",
              "updatedAt": "2020-01-24T15:28:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MDM1OTky",
          "commit": {
            "abbreviatedOid": "7c20b2a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-24T15:36:39Z",
          "updatedAt": "2020-01-24T15:36:39Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d41dbb654900f47bf09b022d3774c21262c46a17",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/hpke-nonces",
      "headRefOid": "7c20b2adc8e004ca8bbb7a5e599ca4eca61699a8",
      "mergeCommit": {
        "oid": "8829872725945a470bef092f2ff54e7f9b7bfc14"
      }
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4MTc0NTE0",
      "title": "Unify terminology around Initiator and Responder.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/34",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We used terms such as sender, initiator, receiver, recipient, and responder interchangeably. Let's simplify the vocabulary.",
      "createdAt": "2020-01-28T18:57:33Z",
      "updatedAt": "2020-02-06T21:20:29Z",
      "closedAt": "2020-02-06T21:20:29Z",
      "mergedAt": "2020-02-06T21:20:28Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ping @bifurcation ",
          "createdAt": "2020-01-29T23:04:47Z",
          "updatedAt": "2020-01-29T23:04:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine with converging to two words, but let's not use gratuitous capitals.",
          "createdAt": "2020-01-30T20:46:07Z",
          "updatedAt": "2020-01-30T20:46:07Z"
        },
        {
          "author": "karthikbhargavan",
          "authorAssociation": "NONE",
          "body": "I agree with unifying terminology, but I find \"responder\" to be a bit weird, since the responder never sends any response in HPKE. I prefer sender/recipient. What do you think?",
          "createdAt": "2020-01-30T21:05:26Z",
          "updatedAt": "2020-01-30T21:05:26Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree with unifying terminology, but I find \"responder\" to be a bit weird, since the responder never sends any response in HPKE. I prefer sender/recipient. What do you think?\r\n\r\nThat's better! My thinking was that responder made sense for higher-level protocols into which HPKE would go, but in hindsight it's not the best term for plain old PKE. I moved to sender/receipient!",
          "createdAt": "2020-01-30T21:19:53Z",
          "updatedAt": "2020-01-30T21:19:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation good to go?",
          "createdAt": "2020-02-05T18:42:40Z",
          "updatedAt": "2020-02-05T18:42:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTU1NTI2",
          "commit": {
            "abbreviatedOid": "56a2e60"
          },
          "author": "karthikbhargavan",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:30:57Z",
          "updatedAt": "2020-01-30T21:30:57Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Do we want to change Initiator (I) to Sender (S)?\r\nIf so, do we want to change I everywhere (e.g. pkI) to S (i.e. pkS)?\r\nIts a biggish change, so we'd better all agree.",
              "createdAt": "2020-01-30T21:30:57Z",
              "updatedAt": "2020-01-30T21:39:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTYwMzk0",
          "commit": {
            "abbreviatedOid": "7cb0b92"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:39:39Z",
          "updatedAt": "2020-01-30T21:39:39Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Yep, I think so. I applied that suggestion. Please have a look!",
              "createdAt": "2020-01-30T21:39:39Z",
              "updatedAt": "2020-01-30T21:39:39Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8829872725945a470bef092f2ff54e7f9b7bfc14",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/initiator-responder",
      "headRefOid": "7cb0b926b348b44e742f134c16adcb29ac60ee69",
      "mergeCommit": {
        "oid": "06056da43f1826ca4549acca9358452f52ec2334"
      }
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY5MjgzNjY1",
      "title": "Recommend public key verification.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/35",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses (?) #30.",
      "createdAt": "2020-01-30T20:58:07Z",
      "updatedAt": "2020-01-31T19:47:01Z",
      "closedAt": "2020-01-31T19:47:01Z",
      "mergedAt": "2020-01-31T19:47:01Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, wow, I just realized we have text that addresses this in the \"Key Encapsulation Mechanisms (KEMs)\" section: \r\n\r\n```\r\nFor the NIST curves P-256 and P-521, the Marshal function of the DH\r\nscheme produces the normal (non-compressed) representation of the\r\npublic key, according to {{SECG}}.  When these curves are used, the\r\nrecipient of an HPKE ciphertext MUST validate that the ephemeral public\r\nkey `pkE` is on the curve.  The relevant validation procedures are\r\ndefined in {{keyagreement}}.\r\n```\r\n\r\nSo I'll point to this text in the proposal.",
          "createdAt": "2020-01-30T21:14:05Z",
          "updatedAt": "2020-01-30T21:16:54Z"
        },
        {
          "author": "karthikbhargavan",
          "authorAssociation": "NONE",
          "body": "I agree. We should require all keys to be validated. I wish there were an\nup to date rfc for validation we could cite.\n\nOn Thu, Jan 30, 2020, 22:12 Benjamin Lipp <notifications@github.com> wrote:\n\n> *@blipp* commented on this pull request.\n> ------------------------------\n>\n> In draft-irtf-cfrg-hpke.md\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/35#discussion_r373195756>\n> :\n>\n> > @@ -359,6 +359,11 @@ context. The key schedule inputs are as follows:\n>\n>  * `pkI` - The initiator's public key (optional; default\n>\n>    value `zero(Npk)`)\n>\n>\n>\n> +Responders SHOULD validate the initiator-provided encapsulated key for\n>\n> +correctness. For example, when using a DH-based KEM, the responder should\n>\n> +check that the resulting key share share is valid, i.e., a point on the\n>\n>\n> The sender should then also check if pkR is valid. For secrecy, that's\n> maybe even more important, because it's \u201cbefore the fact\u201d.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/35?email_source=notifications&email_token=ABFUVS46QQ3QVA3Z6DN6OYLRAM7CDA5CNFSM4KN4Y4EKYY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOCTXAVMY#discussion_r373195756>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/ABFUVSY2KUOG2ASBIALOVBLRAM7CDANCNFSM4KN4Y4EA>\n> .\n>\n",
          "createdAt": "2020-01-31T07:32:50Z",
          "updatedAt": "2020-01-31T07:32:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTQyNjk1",
          "commit": {
            "abbreviatedOid": "50b0c20"
          },
          "author": "karthikbhargavan",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:08:36Z",
          "updatedAt": "2020-01-30T21:08:37Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "\"key share share\"\r\n\r\nI am not sure what the \"resulting key share\" is.\r\nI would instead ask that the recipient/responder should check that pkI and pkE are valid.",
              "createdAt": "2020-01-30T21:08:37Z",
              "updatedAt": "2020-01-31T15:36:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTQ0NDI1",
          "commit": {
            "abbreviatedOid": "50b0c20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:11:41Z",
          "updatedAt": "2020-01-30T21:11:41Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good suggestion -- thanks!",
              "createdAt": "2020-01-30T21:11:41Z",
              "updatedAt": "2020-01-31T15:36:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMTQ0NjI3",
          "commit": {
            "abbreviatedOid": "50b0c20"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T21:11:59Z",
          "updatedAt": "2020-01-30T21:12:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "The sender should then also check if pkR is valid. For secrecy, that's maybe even more important, because it's \u201cbefore the fact\u201d.",
              "createdAt": "2020-01-30T21:12:00Z",
              "updatedAt": "2020-01-31T15:36:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxNzM2Njkx",
          "commit": {
            "abbreviatedOid": "66f33c1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-31T19:46:55Z",
          "updatedAt": "2020-01-31T19:46:55Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8829872725945a470bef092f2ff54e7f9b7bfc14",
      "headRepository": "chris-wood/draft-irtf-cfrg-hpke",
      "headRefName": "caw/point-validation",
      "headRefOid": "66f33c1654fd73afa7d031ef6709e54e64df8a1d",
      "mergeCommit": {
        "oid": "4d65f12b240cbb36eb2d5f56eeba0a11fce66241"
      }
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyOTE0NzMz",
      "title": "Size of exporter_secret must be at least Nh, Nk is too small",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/36",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, `exporter_secret` is created with Expand at a size of `Nk` octets. It is then used within Context.Export as first argument to another call to Expand. However, for HKDF-Expand, the RFC https://tools.ietf.org/html/rfc5869 defines the first input as follows (emphasis mine):\r\n\r\n```\r\n   Inputs:\r\n      PRK      a pseudorandom key of *at least HashLen* octets\r\n```\r\n\r\n`HashLen` corresponds to `Nh` in the HPKE draft.\r\n\r\nLooking at the definitions of `Nh`, `Nk`, and `Nn` in https://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#key-derivation-functions-kdfs-kdf-ids, it becomes clear that `Nh >= Nk` and `Nh >= Nn` for all combinations. Thus, to meet the security requirements of HKDF-Expand, `exporter_secret` should be generated with `Nh` bytes and not only with `Nk` bytes.\r\n\r\n(Said differently, `exporter_secret` is not yet the key, but the input to `Expand`)",
      "createdAt": "2020-02-10T02:47:12Z",
      "updatedAt": "2020-02-11T00:40:43Z",
      "closedAt": "2020-02-10T04:05:07Z",
      "mergedAt": "2020-02-10T04:05:07Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NjgyMzky",
          "commit": {
            "abbreviatedOid": "01e32be"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-10T04:05:02Z",
          "updatedAt": "2020-02-10T04:05:02Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "06056da43f1826ca4549acca9358452f52ec2334",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_sizes",
      "headRefOid": "01e32beeec86e14ce982cf7895aa0608ae65fd8c",
      "mergeCommit": {
        "oid": "c41aca085a5dd6dbe6cdd9f432220b2349d2411e"
      }
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0MzczMjY5NzMw",
      "title": "Update test vectors (with new sender/responder notation).",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/37",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-10T17:51:18Z",
      "updatedAt": "2020-02-24T14:14:17Z",
      "closedAt": "2020-02-24T14:14:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, since we should also use PSKs of the appropriate length as per #41.",
          "createdAt": "2020-02-24T14:14:16Z",
          "updatedAt": "2020-02-24T14:14:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c41aca085a5dd6dbe6cdd9f432220b2349d2411e",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/new-vectors",
      "headRefOid": "137301a0683ebf9f4e5bbf94fce24a781b147361",
      "mergeCommit": null
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MTY5NjEx",
      "title": "Fix typo at two occurrences of pskID",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/38",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-21T08:44:19Z",
      "updatedAt": "2020-02-21T16:04:41Z",
      "closedAt": "2020-02-21T16:04:41Z",
      "mergedAt": "2020-02-21T16:04:41Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzM3MTY1",
          "commit": {
            "abbreviatedOid": "4d12b47"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:04:28Z",
          "updatedAt": "2020-02-21T16:04:28Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c41aca085a5dd6dbe6cdd9f432220b2349d2411e",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_fix_I_S",
      "headRefOid": "4d12b47a9b2732e4a11e608fd3b13b16a8a5450d",
      "mergeCommit": {
        "oid": "6d564037bd3f3ec139a7bc1279dac97a26f41dea"
      }
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MTcwODk0",
      "title": "Refactor to use byte consistently instead of octet",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/39",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-21T08:48:04Z",
      "updatedAt": "2020-02-21T16:04:18Z",
      "closedAt": "2020-02-21T16:04:18Z",
      "mergedAt": "2020-02-21T16:04:18Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzM2MDkw",
          "commit": {
            "abbreviatedOid": "26c2bb0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:02:53Z",
          "updatedAt": "2020-02-21T16:02:53Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fef9eaca3be3ab271ffab29b47dbc4a8ab752060",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_octets_bytes",
      "headRefOid": "78e8b1db2f1385f441f9fde91d2fb95a5f5e386b",
      "mergeCommit": {
        "oid": "176678135edd42d90dee45a3796c95b408b7e1a9"
      }
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4MTc4MDY5",
      "title": "Clarify definition of Npk and output of DH",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/40",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Confirming with the F* specs of P256 and Curve25516, DH returns an encoded curve point. This means the output of DH is of length Npk.",
      "createdAt": "2020-02-21T09:08:07Z",
      "updatedAt": "2020-02-21T16:02:18Z",
      "closedAt": "2020-02-21T16:02:17Z",
      "mergedAt": "2020-02-21T16:02:17Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzM1NTcx",
          "commit": {
            "abbreviatedOid": "032a2ee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-21T16:02:12Z",
          "updatedAt": "2020-02-21T16:02:12Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c41aca085a5dd6dbe6cdd9f432220b2349d2411e",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_Npk",
      "headRefOid": "032a2ee20c169ea033340301422fa757a9ef63bb",
      "mergeCommit": {
        "oid": "fef9eaca3be3ab271ffab29b47dbc4a8ab752060"
      }
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc5ODU5MDM0",
      "title": "Summarize security properties.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/44",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Huzzah!\r\n\r\ncc @blipp ",
      "createdAt": "2020-02-25T23:01:46Z",
      "updatedAt": "2020-02-26T20:52:59Z",
      "closedAt": "2020-02-26T20:52:59Z",
      "mergedAt": "2020-02-26T20:52:59Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation should be good to go now!",
          "createdAt": "2020-02-26T15:49:40Z",
          "updatedAt": "2020-02-26T15:49:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTE4Njc2",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-25T23:12:32Z",
          "updatedAt": "2020-02-25T23:15:39Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Pseudo-Random Function",
              "createdAt": "2020-02-25T23:12:32Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 73,
              "body": "the gap Diffie-Hellman (GDH) problem is hard in the appropriate (sub)group.\r\n\r\nI think it is better to cite\r\n\r\n```\r\n@InProceedings{Okamoto01,\r\n  author = \t {Tatsuaki Okamoto and David Pointcheval},\r\n  title = \t {The Gap-Problems: a New Class of Problems for the Security of Cryptographic Schemes},\r\n  booktitle = {PKC 2001},\r\n  year = \t 2001,\r\n  editor = \t {K. Kim},\r\n  volume = \t 1992,\r\n  series = \t lncs,\r\n  pages = \t {104--118},\r\n  month = \t feb,\r\n  conflocation = \t {Cheju Islands, South Korea},\r\n  publisher = \"Springer\",\r\n}\r\n```\r\n\r\nbecause S01 uses a wrong/uncommon name for the assumption (gap computational), and basically also just cites this one.",
              "createdAt": "2020-02-25T23:15:00Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIwNzcx",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:17:37Z",
          "updatedAt": "2020-02-25T23:17:37Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-02-25T23:17:37Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIwOTUx",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:18:02Z",
          "updatedAt": "2020-02-25T23:18:03Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "I might actually change this to \"pseudorandom function\", as that's what was done in RFC8446!",
              "createdAt": "2020-02-25T23:18:02Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIxMDIw",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-25T23:18:12Z",
          "updatedAt": "2020-02-25T23:20:51Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "export secrets\r\n\r\n(could be multiple)",
              "createdAt": "2020-02-25T23:18:13Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 81,
              "body": "Or better:\r\n\r\nIndistinguishability of each export secret from a uniformly random bitstring of equal length.",
              "createdAt": "2020-02-25T23:19:30Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 91,
              "body": "s too much at the end of the line",
              "createdAt": "2020-02-25T23:20:18Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIyMjcz",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:21:23Z",
          "updatedAt": "2020-02-25T23:21:23Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Pesky macbook keyboards.",
              "createdAt": "2020-02-25T23:21:23Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIyMzA5",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:21:28Z",
          "updatedAt": "2020-02-25T23:21:28Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-02-25T23:21:28Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIyNTMy",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-25T23:21:59Z",
          "updatedAt": "2020-02-25T23:22:00Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "ack! I was just suggesting this because you had Random Oracle capitalized. If you do \u201cpseudorandom function\u201d, then maybe also \u201crandom oracle\u201d",
              "createdAt": "2020-02-25T23:21:59Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTIwMjEy",
          "commit": {
            "abbreviatedOid": "06ea5b1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-25T23:16:16Z",
          "updatedAt": "2020-02-26T15:30:09Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Nit: Please align the `|` characters",
              "createdAt": "2020-02-25T23:16:16Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 31,
              "body": "I might like to still have a summary up here, with a pointer down to the security considerations.  How about something like this (which also folds in the text from above):\r\n\r\n> As a hybrid authenticated encryption algorithm, we desire security\r\n> against (adaptive) chosen ciphertext attacks (IND-CCA2 secure). The\r\n> HPKE variants described in this document achieve this property under\r\n> standard assumptions about the underlying primitives {{HPKEAnalysis}}. \r\n> A summary of this analysis is in {{sec-considerations}}.\r\n\r\nI would be OK deleting the section header in any case.",
              "createdAt": "2020-02-26T15:14:26Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 73,
              "body": "It would also be good to say what property we expect of any non-DH KEMs.  That is, if someone is going to implement this with a new KEM, what do they need to verify about that KEM in order to be confident that HPKE with it is good?",
              "createdAt": "2020-02-26T15:16:41Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 73,
              "body": "Would it be worth a brief note that the DH groups, KDF, and KEMs defined in this document have these properties?",
              "createdAt": "2020-02-26T15:17:27Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 81,
              "body": "Nit: \"each exported secret\"",
              "createdAt": "2020-02-26T15:18:21Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 91,
              "body": "Nit: s/as/because/",
              "createdAt": "2020-02-26T15:20:30Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 109,
              "body": "Is this sentence still relevant?  Doesn't seem like it.  If we are still discussing an advanced case, put a subsection break before it.",
              "createdAt": "2020-02-26T15:22:22Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 97,
              "body": "Further nits:\r\n* You're going to overflow the RFC line length with this table.  Need shorter headings\r\n* The `X` /  `N/A` values should be centered\r\n* I think it looks nicer if you group the single-shot ones\r\n\r\nSo:\r\n```\r\n| Variant              | Message Sec. | Export Sec. | Sender Auth. |\r\n|:---------------------|:------------:|:-----------:|:------------:|\r\n| Base, single-shot    | X            | N/A         | N/A          |\r\n| PSK, single-shot     | X            | N/A         | X            |\r\n| Auth, single-shot    | X            | N/A         | X            |\r\n| AuthPSK, single-shot | X            | N/A         | X            |\r\n| Base, export         | X            | X           | N/A          |\r\n| PSK, export          | X            | X           | X            |\r\n| Auth, export         | X            | X           | X            |\r\n| AuthPSK, export      | X            | X           | X            |\r\n```",
              "createdAt": "2020-02-26T15:29:49Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDA3MzIw",
          "commit": {
            "abbreviatedOid": "9ca6448"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T15:42:03Z",
          "updatedAt": "2020-02-26T15:42:04Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I deleted it and wrapped this section in its own header (\"Security Properties\").",
              "createdAt": "2020-02-26T15:42:03Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDE0MTMz",
          "commit": {
            "abbreviatedOid": "dc26b14"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T15:49:24Z",
          "updatedAt": "2020-02-26T15:49:25Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Nice --fixed!",
              "createdAt": "2020-02-26T15:49:24Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDI1MzEy",
          "commit": {
            "abbreviatedOid": "dc26b14"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T16:01:16Z",
          "updatedAt": "2020-02-26T16:02:33Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Don't you need an assumption on the AEAD too?  Presumably just IND-CCA2",
              "createdAt": "2020-02-26T16:01:16Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            },
            {
              "originalPosition": 100,
              "body": "Nit: \"Moreover\" is unnecessary.  \r\n\r\nYou're also still missing what the general KEM property is.  I would arrange as \r\n\r\n* General KEM property\r\n* Probably a paragraph break\r\n* DH-KEM satisfies the general KEM property if gap DH\r\n* KDFs and AEAD functions in this doc meet the requirements\r\n",
              "createdAt": "2020-02-26T16:02:00Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDU0NDA5",
          "commit": {
            "abbreviatedOid": "dc26b14"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T16:33:54Z",
          "updatedAt": "2020-02-26T16:33:55Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "We can't say anything about general KEMs yet. The analysis does not cover that!",
              "createdAt": "2020-02-26T16:33:55Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MDU0NTYy",
          "commit": {
            "abbreviatedOid": "dc26b14"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T16:34:06Z",
          "updatedAt": "2020-02-26T16:34:06Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "I'll add something, sure.",
              "createdAt": "2020-02-26T16:34:06Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTI1NDQ2",
          "commit": {
            "abbreviatedOid": "5cb7705"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T18:10:21Z",
          "updatedAt": "2020-02-26T18:10:22Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "One last thing:\r\n\r\n> In addition, both {{CS01}} and {{HPKEAnalysis}} are premised on the classical random oracle model, and do not consider attackers capable of quantum computation.  A full proof of post-quantum security would need to take this difference into account, in addition to simply using a post-quantum KEM.",
              "createdAt": "2020-02-26T18:10:21Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTUxODMy",
          "commit": {
            "abbreviatedOid": "5cb7705"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-26T18:49:11Z",
          "updatedAt": "2020-02-26T18:49:58Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "`The gap Diffie-Hellman (GDH) problem is hard {{GAP}}.`",
              "createdAt": "2020-02-26T18:49:12Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTU2ODk3",
          "commit": {
            "abbreviatedOid": "5cb7705"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-26T18:56:20Z",
          "updatedAt": "2020-02-26T18:57:33Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Will we make cryptographers nervous when we say \u201cstandard assumptions\u201d but use the ROM? Assuming ROM for HPKE or Hash is pretty standard, but it is not the \u201cstandard _model_\u201d. We don't say the word _model_ here, so it might be ok\u2026 Is \u201cstandard\u201d here meant in the sense of \u201ccommon\u201d, or in the sense of \u201cclassical\u201d (not post-quantum)? Maybe we could use one of these two instead of standard.",
              "createdAt": "2020-02-26T18:56:20Z",
              "updatedAt": "2020-02-26T18:58:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTU5Mjc4",
          "commit": {
            "abbreviatedOid": "61ed7d9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-26T18:59:36Z",
          "updatedAt": "2020-02-26T18:59:36Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Hmm... I hadn't considered that. I replaced this with classical, as that seems to best describe what we've done. ",
              "createdAt": "2020-02-26T18:59:36Z",
              "updatedAt": "2020-02-26T18:59:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjMzMTYw",
          "commit": {
            "abbreviatedOid": "61ed7d9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-26T20:52:52Z",
          "updatedAt": "2020-02-26T20:52:52Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "6d564037bd3f3ec139a7bc1279dac97a26f41dea",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/analysis",
      "headRefOid": "61ed7d99037b5d7698a5d82e26cfddd65fb9e979",
      "mergeCommit": {
        "oid": "be909d595078606f97e76a67d72c28072c41bcfc"
      }
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc5OTczMDQw",
      "title": "Update test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/45",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With new PSK lengths and more fields. Addresses #41.",
      "createdAt": "2020-02-26T02:29:04Z",
      "updatedAt": "2020-02-28T14:34:05Z",
      "closedAt": "2020-02-28T14:34:05Z",
      "mergedAt": "2020-02-28T14:34:05Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDM4NTg4",
          "commit": {
            "abbreviatedOid": "4515e6c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-28T14:32:59Z",
          "updatedAt": "2020-02-28T14:32:59Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "6d564037bd3f3ec139a7bc1279dac97a26f41dea",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/new-vectors-2",
      "headRefOid": "4515e6c5a788c64fa835e5ce88025c238dfc1945",
      "mergeCommit": {
        "oid": "70c44a2080abf83397b9f7d364ee01de153629eb"
      }
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxNDE5ODcx",
      "title": "Domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/47",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Tries to address #46. \r\n\r\ncc @blipp ",
      "createdAt": "2020-02-28T14:30:09Z",
      "updatedAt": "2020-02-28T14:30:57Z",
      "closedAt": "2020-02-28T14:30:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "be909d595078606f97e76a67d72c28072c41bcfc",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/domain-separation",
      "headRefOid": "e4ef3ed0fa54b8752175554888c24756bde2eee1",
      "mergeCommit": null
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxNDIyMTM3",
      "title": "Add domain separation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/48",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add RFC number domain separation tag. Clone KeySchedule Hash calls with one-byte prefix.\r\n\r\nThis attempts to address #47.\r\n\r\n",
      "createdAt": "2020-02-28T14:34:38Z",
      "updatedAt": "2020-03-08T02:19:35Z",
      "closedAt": "2020-03-08T02:19:35Z",
      "mergedAt": "2020-03-08T02:19:35Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp @beurdouche @bifurcation what do we want to do with this?",
          "createdAt": "2020-03-04T22:42:32Z",
          "updatedAt": "2020-03-04T22:42:32Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this change is necessary.  As I understand it, the proofs we have do not rely on independent ROs, so there's no need to assure independence in this way.  @blipp, please correct me if this impression is wrong.\r\n\r\nThe 0x00/0x01 prepending has nothing to do with RO separation.  At best it ensures that a specific type of programming error causes a failure (reversal of pskID and info fields).  It seems fairly certain that in any practical case, such an error would be caught quickly anyway, since it is only hidden when `pskID == info`.",
          "createdAt": "2020-03-06T19:26:49Z",
          "updatedAt": "2020-03-06T19:26:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think this change is necessary. As I understand it, the proofs we have do not rely on independent ROs, so there's no need to assure independence in this way. @blipp, please correct me if this impression is wrong.\r\n\r\nAs discussed offline, I think this is the wrong mental model for domain separation. The rationale in the security considerations section attempts to make the idea clear: adding a prefix to the extract calls ensures that secrets derived from the *same* shares in HPKE do not conflict with secrets derived in other protocols. Can you state with certainty this type of cross-protocol collision is safe? \r\n\r\n> The 0x00/0x01 prepending has nothing to do with RO separation. At best it ensures that a specific type of programming error causes a failure (reversal of pskID and info fields). It seems fairly certain that in any practical case, such an error would be caught quickly anyway, since it is only hidden when pskID == info.\r\n\r\nYes, this change aims to prevent programmer error. I think the API should fail on misuse. As it stands now, that is *not the case*.",
          "createdAt": "2020-03-06T19:29:21Z",
          "updatedAt": "2020-03-06T19:29:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation I removed the Hash prefix changes, limiting this change to `identifier`-based separation. (We can address the Hash proposal in a separate issue/PR if desired!)",
          "createdAt": "2020-03-06T19:38:24Z",
          "updatedAt": "2020-03-06T19:38:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "> Can you state with certainty this type of cross-protocol collision is safe?\r\n\r\nAbsent some globally-enforced standard for hash inputs and a managed namespace for prefixes, you will never achieve certainty.\r\n\r\nI'll grant that \"RFCXXXX\" is probably a bit better than just \"hpke\", and centralizing the prefix is better than how it was before.  So I can live with this.\r\n",
          "createdAt": "2020-03-06T20:08:24Z",
          "updatedAt": "2020-03-06T20:08:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDQ1MTI2",
          "commit": {
            "abbreviatedOid": "797ded8"
          },
          "author": "beurdouche",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T14:42:06Z",
          "updatedAt": "2020-02-28T14:42:06Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I think you can remove \"(or oracle query)\".\r\nI wouldn't use that reference either... There is nothing new here, that said I don't have a good one in mind : )",
              "createdAt": "2020-02-28T14:42:06Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTAyMTI1",
          "commit": {
            "abbreviatedOid": "3fa8824"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T15:57:03Z",
          "updatedAt": "2020-02-28T15:57:03Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I dropped the parenthetical. As I don't have a better reference for domain separation, I'm inclined to keep the citation. (Better to point somewhere than rely on folklore?)",
              "createdAt": "2020-02-28T15:57:03Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTczOTE4",
          "commit": {
            "abbreviatedOid": "3fa8824"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:46:55Z",
          "updatedAt": "2020-02-28T17:46:55Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "`This domain separation does not protect the KeySchedule 'secret' from use in other\r\nprotocols.`: maybe this sentence is not needed, because `secret` is not exposed by the protocol, and thus not used in any other construction.",
              "createdAt": "2020-02-28T17:46:55Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTc1ODk5",
          "commit": {
            "abbreviatedOid": "3fa8824"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:50:27Z",
          "updatedAt": "2020-02-28T17:50:27Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Or maybe we add that clarification? \r\n\r\nDerivation of the KeySchedule 'secret' does not include domain separation as it is an intermediate value not exposed by the protocol.",
              "createdAt": "2020-02-28T17:50:27Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NTc2Nzk3",
          "commit": {
            "abbreviatedOid": "3fa8824"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-28T17:52:02Z",
          "updatedAt": "2020-02-28T17:52:03Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Yes, sounds good.",
              "createdAt": "2020-02-28T17:52:03Z",
              "updatedAt": "2020-03-06T19:51:36Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "70c44a2080abf83397b9f7d364ee01de153629eb",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/separation",
      "headRefOid": "8bbbb3fbe8818dc39a52501e82be232827e84008",
      "mergeCommit": {
        "oid": "a025ae8aa80bcdc5065f5a25cf93bb971582bcfc"
      }
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyNTQxNTcx",
      "title": "Correct KEM sizes for NIST curves.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/49",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-02T18:34:43Z",
      "updatedAt": "2020-03-04T18:46:11Z",
      "closedAt": "2020-03-04T18:46:11Z",
      "mergedAt": "2020-03-04T18:46:11Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation ",
          "createdAt": "2020-03-02T18:35:03Z",
          "updatedAt": "2020-03-02T18:35:03Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This probably needs to update the DHKEM section, too, right?\r\n\r\n```\r\nThe GenerateKeyPair, Marshal, and Unmarshal functions are the same as for the underlying DH group. The Marshal functions for the curves referenced in {#ciphersuites} are as follows:\r\n\r\nP-256: The X-coordinate of the point, encoded as a 32-byte big-endian integer\r\nP-521: The X-coordinate of the point, encoded as a 66-byte big-endian integer\r\n```",
          "createdAt": "2020-03-02T20:07:26Z",
          "updatedAt": "2020-03-02T20:07:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTI3NzI3",
          "commit": {
            "abbreviatedOid": "39bf43a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Good catch!",
          "createdAt": "2020-03-02T21:07:44Z",
          "updatedAt": "2020-03-02T21:08:02Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n  Y-coordinate of the point, encoded as 32-byte big-endian integers\r\n```",
              "createdAt": "2020-03-02T21:07:44Z",
              "updatedAt": "2020-03-02T21:14:16Z"
            },
            {
              "originalPosition": 11,
              "body": "```suggestion\r\n  Y-coordinate of the point, encoded as 66-byte big-endian integers\r\n```",
              "createdAt": "2020-03-02T21:07:54Z",
              "updatedAt": "2020-03-02T21:14:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDI5NzI0",
          "commit": {
            "abbreviatedOid": "6d24cc7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T18:45:48Z",
          "updatedAt": "2020-03-04T18:45:48Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "70c44a2080abf83397b9f7d364ee01de153629eb",
      "headRepository": "Bren2010/draft-irtf-cfrg-hpke",
      "headRefName": "brendan/kem-sizes",
      "headRefOid": "6d24cc78d0ddda6064f45b8094be9fe337624eed",
      "mergeCommit": {
        "oid": "e4be5411828691b396fb2de7f9a40a319765a7d0"
      }
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTIyOTkx",
      "title": "Modifications for IND-CCA-secure DHKEM and independent random oracles",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The isolated DHKEM cannot be proven IND-CCA-secure as it is: In the current Encap, nothing is done with the result of the DH operation, `zz`. This means there is nowhere where the GDH assumption can be applied, as for this we need a comparison of a value with `g^ab` in the game, like `g^c = g^ab`, which we can then change in a game hop to `false`.\r\n\r\nThis is not a problem when looking at HPKE as a whole, because `zz` is fed into Extract which we model as a random oracle. For DHKEM isolated, this problem can be fixed by feeding the Diffie-Hellman shared secret through another random oracle before returning the result as `zz`.\r\n\r\nThe hash functions suggested in this pull request are chosen to correspond to the security level of the elliptic curve DH, respectively. If users of HPKE want to use only one hash function, then they need to choose the KDF depending on the used DHKEM. Specifying each DHKEM for multiple (i.e. different output size) hash functions seems overkill and like sending wrong signals about the security level of DHKEM.\r\n\r\nRegarding random oracle cloning: By introducing another call to a random oracle, which might be implemented by the same hash function, this becomes now more relevant than before. I think we need to make sure that Hash' and the calls to Hash inside HMAC are independent, to be able to use the indifferentiability theorem on SHAxxx. I looked at the input domains of these two calls for SHA256, SHA384, and SHA512 and they are indeed _already disjoint_ by their lengths. An open question is if we need to do something about the Hash calls `Hash(pskID)` and `Hash(info)` that we model as collision resistant. I like to discuss this with Bruno and/or Karthik before proceeding.\r\n\r\nThis pull request is to keep you in the loop, please feel free to provide preliminary feedback.",
      "createdAt": "2020-03-06T16:54:50Z",
      "updatedAt": "2020-04-10T20:31:27Z",
      "closedAt": "2020-04-10T20:31:27Z",
      "mergedAt": "2020-04-10T20:31:27Z",
      "mergedBy": "bifurcation",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I came to the conclusion that we need to separate `HashDH` and `Hash`: If we model `HashDH` as random oracle, and `Hash` as collision resistant, then this model is not sound if they are instantiated by the same function. (because then the `HashDH` random oracle should have taken into account collisions with `Hash` and vice versa, but they didn't in the model because they are modeled as independent)\r\n\r\nI introduced prefixes for `HashDH` and `Hash`.\r\n\r\nI somewhat incorporated the proposals from #48:\r\n- The prefix is \u201cRFCXXXX\u201d plus \u201cDHKEM\u201d or \u201cHPKE\u201d\r\n- However, if the prefix is already inside pskID_hash and info_hash, I think it's not additionally needed as `identifier` at the beginning of context.\r\n- \u201chpke\u201d is removed from the Expand contexts, as it's already in the prefix.\r\n- comment on the independence of derived secrets form other protocols using the same KEM.\r\n\r\nI am open to suggestions to replace the hash function name `HashDH` and the variable name `dh` by something else; same for `label_dhkem` and `label_hash`.",
          "createdAt": "2020-03-08T02:17:36Z",
          "updatedAt": "2020-03-08T02:27:48Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, if the prefix is already inside pskID_hash and info_hash, I think it's not additionally needed as identifier at the beginning of context.\r\n\r\nI would prefer we keep `identifier` as a prefix in `context` since that's fed directly into Expand. ",
          "createdAt": "2020-03-08T02:28:12Z",
          "updatedAt": "2020-03-08T02:28:12Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I would prefer we keep `identifier` as a prefix in `context` since that's fed directly into Expand.\r\n\r\nThat's fair; because it's different issues being addressed (random oracle cloning and binding the keys to the primitive name).",
          "createdAt": "2020-03-08T02:35:14Z",
          "updatedAt": "2020-03-08T02:35:14Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One way to resolve the merge conflict would be\r\n```\r\ndef KeySchedule(mode, pkR, zz, enc, info, psk, pskID, pkSm):\r\n  VerifyMode(mode, psk, pskID, pkSm)\r\n\r\n  pkRm = Marshal(pkR)\r\n  identifier = \"RFCXXXX\"\r\n  label_hash = \"RFCXXXX HPKE\"\r\n  ciphersuite = concat(kem_id, kdf_id, aead_id)\r\n  pskID_hash = Hash(concat(label_hash, pskID))\r\n  info_hash = Hash(concat(label_hash, info))\r\n  context = concat(identifier, ciphersuite, mode, enc, pkRm,\r\n                   pkSm, pskID_hash, info_hash)\r\n\r\n  secret = Extract(psk, zz)\r\n  key = Expand(secret, concat(\"key\", context), Nk)\r\n  nonce = Expand(secret, concat(\"nonce\", context), Nn)\r\n  exporter_secret = Expand(secret, concat(\"exp\", context), Nh)\r\n\r\n  return Context(key, nonce, exporter_secret)\r\n~~~~~\r\n\\[\\[RFC editor: please change \"RFCXXXX\" to the correct number before publication.]]\r\n\r\n```",
          "createdAt": "2020-03-08T02:47:55Z",
          "updatedAt": "2020-03-08T02:47:55Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\nThe KeySchedule procedure includes the domain separation string \"RFCXXXX\" in\r\neach Expand invocation. This ensures any secrets derived in HPKE are independent\r\nfrom those used in other protocols, even when derived from the same IKM (secret).\r\n```\r\n\r\nI am not happy at the moment with the language of the description of the `identifier`. As 2020/241 says, and I agree, domain separation is a method, not a goal. What's the goal with `identifier`? I think the goal is to bind the key to the protocol/primitive name. I don't see at the moment how \u201dindependent\u201d is defined here? (maybe we can have a formulation without that, like `This ensures any secrets derived in HPKE are bound to the scheme's name, even when possibly derived from the same KEM shared secret as in another scheme.`)\r\n\r\n```\r\nDerivation of the KeySchedule 'secret' does not include domain separation as it\r\nis an intermediate value not exposed by the protocol.\r\n```\r\n\r\nI would drop this sentence: If we agree that the goal is binding of keys to the primitive name, then we don't need to bind an intermediary value to the primitive name.",
          "createdAt": "2020-03-08T03:01:27Z",
          "updatedAt": "2020-03-08T03:01:27Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> This ensures any secrets derived in HPKE are bound to the scheme's name, even when possibly derived from the same KEM shared secret as in another scheme.\r\n\r\nI like it! Want to make that change?\r\n\r\n> I would drop this sentence: If we agree that the goal is binding of keys to the primitive name, then we don't need to bind an intermediary value to the primitive name.\r\n\r\nHmm... this sentence is clarifying why we don't prefix extraction for `secret`. I don't think this conflicts with the stated goal.",
          "createdAt": "2020-03-08T03:08:41Z",
          "updatedAt": "2020-03-08T03:08:41Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I like it! Want to make that change?\r\n\r\nAck, I'll make the change (when we know what to do with the rest).\r\n\r\n> Hmm... this sentence is clarifying why we don't prefix extraction for `secret`. I don't think this conflicts with the stated goal.\r\n\r\nWe could also add the prefix to `secret`, it would have the same effect of binding HPKE's output secrets to the primitive name. In my view we chose to add the prefix to `context` because that's a place where we already add all the other context. Now that I am looking closer, the outputs of the three Expand calls are also not exposed by the protocol and thus can be considered intermediary values as well (`key` and `nonce` are used to produce ciphertexts, only those are exposed; `exporter_secret` is used to derive the actual exported secrets). That's why I would not comment on another intermediary value (secret), and drop this sentence.\r\n\r\nI think I can now express my weird feeling towards \u201cindependent\u201d better: the goal of binding the secrets to the primitive name is not assured by a security proof. I think we cannot prove that other protocols do not derive the same keys, because we do not have control over these other protocols. They could still derive the same keys on purpose. What we achieve by the `identifier` string is that the probability gets small that someone does it by accident. But we cannot get a guarantee like with `HashDH` and `Hash`, where we control both protocols. That's why I felt uncomfortable with \u201cindependent\u201d, because it suggests a more formal guarantee as it actually gives.",
          "createdAt": "2020-03-08T04:00:26Z",
          "updatedAt": "2020-03-08T04:00:26Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "By this reasoning, `label_hash` would be enough to bind HPKE's outputs to its name/identifier. It just happens one computation step earlier.",
          "createdAt": "2020-03-08T04:16:49Z",
          "updatedAt": "2020-03-08T04:16:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "What happens if either pskID or label are unspecified? Their hashes would be a singe, fixed value. Aren\u2019t other (attacker-controlled?) parameters added to context? Don\u2019t we need to separate inline with those values? (Sorry for possibly hand wavy nonsense!)",
          "createdAt": "2020-03-08T04:29:58Z",
          "updatedAt": "2020-03-08T04:29:58Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> What happens if either pskID or label are unspecified? Their hashes would be a singe, fixed value. Aren\u2019t other (attacker-controlled?) parameters added to context? Don\u2019t we need to separate inline with those values? (Sorry for possibly hand wavy nonsense!)\r\n\r\nOur goal is to make the derived values dependent on the primitives name. This is still the case even if application info or pskID are empty, because the prefix stays.\r\n\r\nNoise protocols like WireGuard add the protocol name in a similar way. In WireGuard, the protocol starts with [1]:\r\n\r\n```\r\nC_i := Hash(Construction)\r\nH_i := Hash(C_i || Identifier)\r\n\u2026\r\n```\r\n\r\nwith the constants being\r\n\r\n```\r\nConstruction = The UTF-8 string literal \u201cNoise_IKpsk2_25519_ChaChaPoly_BLAKE2s\u201d, 37 bytes of\r\noutput.\r\nIdentifier = The UTF-8 string literal \u201cWireGuard v1 zx2c4 Jason@zx2c4.com\u201d, 34 bytes of output.\r\n```\r\n\r\n[1] https://www.wireguard.com/papers/wireguard.pdf page 10",
          "createdAt": "2020-03-09T11:31:07Z",
          "updatedAt": "2020-03-09T11:31:07Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the PSK length:\r\n\r\nHMAC(K, M) feeds K through a call to Hash if K is longer than Hash's blocksize. If we allow arbitrary-size PSKs for user convenience, this would introduce another place where Hash is called on arbitrary-sized input, just like with info and pskID. (As a reminder: Arbitrary-sized input to Hash can lead to collisions with input to Hash calls inside HMAC. This would render the proof inapplicable that proves indifferentiability of HMAC from a random oracle. To avoid collisions, we use Extract calls and separate the input domains by using a prefix).\r\n\r\nTo avoid this extra Hash call inside HMAC, we can just anticipate it directly in KeySchedule, and thus control the prefix. While this introduces branching inside KeySchedule, this branching would either way be done inside HMAC. Doing the Extract call even if the PSK is shorter then Nb would hurt performance in non-PSK modes, too.",
          "createdAt": "2020-03-25T00:09:52Z",
          "updatedAt": "2020-03-25T00:09:52Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On the context added to DHKEM:\r\n\r\nAs a reminder, this is an ongoing effort to propose changes to the HPKE draft, with the goal to make DHKEM a KEM being provable IND-CCA-secure independently from HPKE as a whole.\r\n\r\nHaving DHKEM IND-CCA-secure on its own is nice because then it is enough to do _one_ proof of HPKE assuming an IND-CCA-secure KEM. If DHKEM would not be IND-CCA-secure, then we would need both an explicit proof of the entire HPKE[DHKEM] _and_ a proof of HPKE assuming an IND-CCA-secure KEM if we want other KEMs to be pluggable into HPKE.\r\n\r\n- As discussed earlier and off-channel, Curve25519 has equivalent keys. This results in a weaker security property for DHKEM in comparison to full HPKE, because DHKEM does not have any context so far in the derivation of zz.\r\n\r\n  The common recommendation is to include enc, pkRm, and pkSm into the context of the derivation of zz. Adding context to the Extract step of HKDF is not advisable as noted in the HKDF RFC [1]. This is why this update of the pull request adds an Expand step to DHKEM.\r\n\r\n  Curve25519 is specified not to have/need public-key validation, which is why equivalent keys \u201ccannot\u201d be detected beforehand. (Also, adding context is a lot cheaper than doing a scalar mult/point addition to detect equivalent keys).\r\n\r\n- Why not have more context within DHKEM: would it desirable to have kem_id, kdf_id, and a protocol-specific identifier in the context?\r\n\r\n  The goal of such context would be that, even if someone uses DHKEM with the same static keys in parallel with two different protocols (HPKE and some other protocol), the two DHKEM key distributions (of zz) are independent.\r\n\r\n  We came to the conclusion that to achieve this goal, DHKEM's key derivation needs to be protocol-dependent, for example by receiving as input an info variable that contains the protocol name, and use this in the context. (kem_id and kdf_id are not protocol-dependent but specific to DHKEM and thus are not useful to make the keys independent if the same DHKEM is used.)\r\n\r\n  Requiring an info parameter for DHKEM seemed to be rather complex in comparison to the benefit; also this benefit is rather uncontrollable because it involves assumptions on the well-behavior of other protocols. Also, the post-quantum KEMs don't seem to do that. We came to the conclusion to only make sure that enc, pkSm, pkRm are in DHKEM's context, because they are necessary to make it IND-CCA-secure on its own.\r\n\r\nLeft to discuss:\r\n- enc, pkSm, pkRm are now part of the context of both DHKEM and KeySchedule. It would be ok to _not_ include them in KeySchedule's context if HPKE would require from a KEM that public keys and the KEM ciphertext are included explicitly in the derivation of the KEM shared secret.\r\n\r\n[1] https://hyp.is/BEfR7m1AEeqBfpNgYg1Ivg/tools.ietf.org/html/rfc5869",
          "createdAt": "2020-03-25T00:59:23Z",
          "updatedAt": "2020-03-25T00:59:23Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Notes on PSK in KeySchedule vs PSK in DHKEM:\r\n\r\nThe PSK provides additional secrecy and authentication guarantees and as such could also be part of the DHKEM definition. However, no post-quantum KEM seems to have a PSK mode. Leaving the PSK outside DHKEM but in KeySchedule makes sense if we want to keep the possibility of a PSK if HPKE is used with a general KEM other than DHKEM.",
          "createdAt": "2020-03-25T11:38:43Z",
          "updatedAt": "2020-03-25T11:38:43Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This one is more of an implementation consideration:\r\n\r\nThe DHKEM functions and KeySchedule compute the marshaled public keys each time. Would it be acceptable if an implementation chooses to receive these values as additional parameters? Do you think this needs to be explicitly allowed in the spec?",
          "createdAt": "2020-03-25T11:44:16Z",
          "updatedAt": "2020-03-25T11:44:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> The DHKEM functions and KeySchedule compute the marshaled public keys each time. Would it be acceptable if an implementation chooses to receive these values as additional parameters? Do you think this needs to be explicitly allowed in the spec?\r\n\r\nI'm sure implementations might want to do that. We can probably note it as an implementation detail. I don't think the spec needs to spell that out in the pseudocode, though.",
          "createdAt": "2020-03-25T17:43:23Z",
          "updatedAt": "2020-03-25T17:43:23Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> enc, pkSm, pkRm are now part of the context of both DHKEM and KeySchedule. It would be ok to not include them in KeySchedule's context if HPKE would require from a KEM that public keys and the KEM ciphertext are included explicitly in the derivation of the KEM shared secret.\r\n\r\nInteresting point. I think this is nice simplification of the key schedule and a perfectly fine requirement to levy on future KEMs. @bifurcation, penny for your thoughts?",
          "createdAt": "2020-03-25T17:46:09Z",
          "updatedAt": "2020-03-25T17:46:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation please review!",
          "createdAt": "2020-03-30T22:56:31Z",
          "updatedAt": "2020-03-30T22:56:31Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > enc, pkSm, pkRm are now part of the context of both DHKEM and KeySchedule. It would be ok to not include them in KeySchedule's context if HPKE would require from a KEM that public keys and the KEM ciphertext are included explicitly in the derivation of the KEM shared secret.\r\n> \r\n> Interesting point. I think this is nice simplification of the key schedule and a perfectly fine requirement to levy on future KEMs. @bifurcation, penny for your thoughts?\r\n\r\nAddressed in commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/38f915fe919c8514a8bb2f3127438ec899330711.",
          "createdAt": "2020-04-08T19:31:04Z",
          "updatedAt": "2020-04-08T19:31:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDc5NTYy",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-06T16:58:37Z",
          "updatedAt": "2020-03-06T16:59:01Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Can we introduce this notation (`DHKEM(curve, hash)`) in the DHKEM section?",
              "createdAt": "2020-03-06T16:58:38Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDc5Njcy",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T16:58:47Z",
          "updatedAt": "2020-03-06T17:02:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I would just add this to the above list of required functions.  \"Suppose we are given a Diffie-Hellman group and a hash function ...\"",
              "createdAt": "2020-03-06T16:58:47Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 15,
              "body": "For compatibility with programming languages, might call this \"Hash2\" or something that could actually be a function name in.",
              "createdAt": "2020-03-06T16:59:45Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 16,
              "body": "`Nzz` needs to be defined somewhere; TBH seems like this would be good to know for other KEMs as well.  I think this loses the idea that the DH output is fixed-size, though.  Do we need that?",
              "createdAt": "2020-03-06T17:01:01Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDg0NTgz",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:06:09Z",
          "updatedAt": "2020-03-06T17:06:10Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Putting it alongside the `Nh` et al. definitions would suffice. \r\n\r\n> I think this loses the idea that the DH output is fixed-size, though. Do we need that?\r\n\r\n@bifurcation I'm not sure I follow. Nzz *is* fixed, so isn't the output fixed size?",
              "createdAt": "2020-03-06T17:06:10Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDg2ODI2",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:09:47Z",
          "updatedAt": "2020-03-06T17:09:47Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Good point, I'll add `Nzz` to the \u201cCryptographic Dependencies\u201d part; I am not sure what you mean regarding the fixed-size DH output? (sorry for the double question, I was writing at the same time with Chris ;) )",
              "createdAt": "2020-03-06T17:09:47Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDkwMTE0",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:14:47Z",
          "updatedAt": "2020-03-06T17:14:48Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Might be relevant: Encap and AuthEncap now have the same output size for `zz`. Before, AuthEncap's `zz` had double the size of Encap's `zz`.",
              "createdAt": "2020-03-06T17:14:47Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDkxMTE5",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:16:19Z",
          "updatedAt": "2020-03-06T17:16:19Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Interesting -- does that affect analysis?",
              "createdAt": "2020-03-06T17:16:19Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNDk0NzMw",
          "commit": {
            "abbreviatedOid": "67382c4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T17:22:02Z",
          "updatedAt": "2020-03-06T17:22:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Not so much I'd say \u2013 it makes analysis of Extract a bit easier because it's input length has one case distinction less.",
              "createdAt": "2020-03-06T17:22:02Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NzM0NTA2",
          "commit": {
            "abbreviatedOid": "d8eda21"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T19:04:20Z",
          "updatedAt": "2020-03-23T19:09:23Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "It seems like it might be worth defining a different length, say `Ndh` for this, since there are definitely schemes where the shared secret is not of length `Npk`.",
              "createdAt": "2020-03-23T19:04:20Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 32,
              "body": "I wonder if it would be simplest to do something like the following\r\n\r\n```\r\ndef LabeledExtract(salt, label, secret):\r\n    labeledSecret = concat(\"RFC XXXX\", label, secret)  \r\n    return Extract(salt, labeledSecret)\r\n```\r\n\r\nThis is what TLS 1.3 does to make sure the general label gets added everywhere.",
              "createdAt": "2020-03-23T19:08:26Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 32,
              "body": "Is there a reason to attach the label to the secret vs. the salt?",
              "createdAt": "2020-03-23T19:08:54Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDg3NzY3",
          "commit": {
            "abbreviatedOid": "d8eda21"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T16:31:26Z",
          "updatedAt": "2020-03-24T16:31:27Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> Is there a reason to attach the label to the secret vs. the salt?\r\n\r\nThe goal of the label in the end is to separate the input domains of all HMAC calls. This concerns Extract and Expand. The three Expand calls for key, nonce, exporter_secret already have the label as prefix of the second argument, and that's why it's in the second argument for Extract, too (and thus attached to the secret/IKM).",
              "createdAt": "2020-03-24T16:31:26Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzc2OTAw",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T23:57:09Z",
          "updatedAt": "2020-03-24T23:57:09Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "> I wonder if it would be simplest to do something like the following [\u2026]\r\n> This is what TLS 1.3 does to make sure the general label gets added everywhere.\r\n\r\nUps, I forgot that in my recent update. I'll first write some comments to what I did there, and later try to incorporate this suggestions.",
              "createdAt": "2020-03-24T23:57:09Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMDg1OTgx",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T12:06:35Z",
          "updatedAt": "2020-03-25T12:06:36Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Is this correct for the 12-letter UTF-8 string literal \u201cRFCXXXX HPKE\u201d?",
              "createdAt": "2020-03-25T12:06:36Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMzcyNjU3",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the update! This is heading in the right direction. I don't love the notation `Hash_kem` etc, though I don't have a better suggestion off hand. I'd also like to see motivating text for PSK length recommendations moved to the security considerations as per #59. Would that be OK?",
          "createdAt": "2020-03-25T17:24:48Z",
          "updatedAt": "2020-03-25T17:42:20Z",
          "comments": [
            {
              "originalPosition": 168,
              "body": "Let's treat it as an ASCII string, in which case, yes!",
              "createdAt": "2020-03-25T17:24:49Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 167,
              "body": "```suggestion\r\n    uint8 identifier[12] = \"RFCXXXX HPKE\";\r\n```",
              "createdAt": "2020-03-25T17:25:03Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 46,
              "body": "Re-defining this is somewhat confusing -- is it needed? ",
              "createdAt": "2020-03-25T17:26:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 40,
              "body": "Can we define `Ndh` on its own line? (I missed it the first time around.) Is it even needed?",
              "createdAt": "2020-03-25T17:28:08Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 67,
              "body": "```suggestion\r\n  prk = Extract_kem(0, concat(label_dh, dh))\r\n```",
              "createdAt": "2020-03-25T17:29:01Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n  prk = Extract_kem(0, concat(label_dh, dh))\r\n```",
              "createdAt": "2020-03-25T17:29:10Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 95,
              "body": "```suggestion\r\n  prk = Extract_kem(0, concat(label_dh, dh))\r\n```",
              "createdAt": "2020-03-25T17:29:20Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n  prk = Extract_kem(0, concat(label_dh, dh))\r\n```",
              "createdAt": "2020-03-25T17:29:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 187,
              "body": "Can we pull the text from #59 and place it here? (And move the next paragraph to the security considerations as is done in #59?)",
              "createdAt": "2020-03-25T17:30:29Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 243,
              "body": "```suggestion\r\n## Domain Separation\r\n```\r\n\r\n... since Random Oracle Cloning isn't a widely used term yet.",
              "createdAt": "2020-03-25T17:32:39Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 256,
              "body": "```suggestion\r\nFuture KEM instantiations MUST ensure that all internal hash function invocations are prefixed with a unique label similar to `\"RFCXXXX DHKEM\"`. This ensures they can be modeled as a function independent from `Hash`.\r\n```",
              "createdAt": "2020-03-25T17:34:57Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nThen we can construct a KEM called `DHKEM(Group, Hash_kem)` in the\r\nfollowing way, where `Group` denotes the Diffie-Hellman group and\r\n`Hash_kem` the hash function underlying KDF_kem:\r\n```",
              "createdAt": "2020-03-25T17:37:32Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 67,
              "body": "These lines (prk = ..., zz = ...) are the same across all variants. Can we pull them out into a common function that takes `dh`, `context_kem` as input?\r\n\r\n```\r\ndef ExtractAndExpand(dh, prk):\r\n   prk = Extract_kem(0, concat(\"RFCXXXX DHKEM\", dh))\r\n   zz  = Expand_kem(prk, concat(\"prk\", context_kem), Nzz)\r\n```\r\n\r\nThen call like so:\r\n\r\n```\r\ndef Encap(pkR):\r\n   ...\r\n   zz = ExtractAndExpand(dh, context_kem)\r\n   return zz, enc\r\n```",
              "createdAt": "2020-03-25T17:41:49Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMTA1NDU4",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T15:09:04Z",
          "updatedAt": "2020-03-26T15:09:05Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "We also redefine GenerateKeyPair, DH, Marshal, Unmarshal to make their definitions adapted to DHKEM. With the line about Nzz I want to make clear that Nzz is the length of Hash_kem's output. This is only implicitly clear by seeing that the result of Expand is returned.\r\n\r\nIt's true that this (Nzz is the length of Hash_kem's output) is true for our variants of DHKEM with SHA2. But now that I included Nzz as third argument to Expand, other settings are also possible.\r\n\r\nSo maybe we could move this line away from the definitions list and put it as a comment below the pseudo-code, saying that for our specified versions of DHKEM, Nzz is Hash_kem's output length. What do you think about that?",
              "createdAt": "2020-03-26T15:09:04Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMTA4MzM5",
          "commit": {
            "abbreviatedOid": "710c89c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T15:11:48Z",
          "updatedAt": "2020-03-26T15:11:48Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "This was a suggestion by @bifurcation, with the background that there might be a DH scheme where the result of the DH operation is not an encoded public key.\r\n\r\nWe can move it to it's own line I think.",
              "createdAt": "2020-03-26T15:11:48Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjY2MTE5",
          "commit": {
            "abbreviatedOid": "e074762"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T17:55:41Z",
          "updatedAt": "2020-03-26T17:59:51Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> So maybe we could move this line away from the definitions list and put it as a comment below the pseudo-code, saying that for our specified versions of DHKEM, Nzz is Hash_kem's output length. What do you think about that?\r\n\r\nThat'd be great!",
              "createdAt": "2020-03-26T17:55:41Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjc2NDA3",
          "commit": {
            "abbreviatedOid": "8790927"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-26T18:05:50Z",
          "updatedAt": "2020-03-26T18:13:50Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nThe adversary can use different oracles to decide if a PSK guess was correct,\r\n```",
              "createdAt": "2020-03-26T18:05:50Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 88,
              "body": "```suggestion\r\nthe adversary can use decryption of the ciphertext as oracle. HPKE ciphertexts are\r\n```",
              "createdAt": "2020-03-26T18:06:35Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 87,
              "body": "In this scenario, the adversary didn't guess the PSK value, so I don't think it's a relevant example.",
              "createdAt": "2020-03-26T18:09:15Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 97,
              "body": "```suggestion\r\nScenarios in which the adversary knows the KEM shared secret zz\r\n```",
              "createdAt": "2020-03-26T18:09:32Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\r\nknows all private keys of one participant. \r\n```\r\n\r\nI recommend deleting these examples as knowledge of all private keys of one participant is adequate. ",
              "createdAt": "2020-03-26T18:13:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjk1MDky",
          "commit": {
            "abbreviatedOid": "5a59b51"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:27:07Z",
          "updatedAt": "2020-03-26T18:27:07Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "The adversary can try decryption for each PSK value it wants to guess. This is an example of a passive adversary. Would replacing \u201con observation of an HPKE ciphertext\u201d by \u201cwith a captured HPKE ciphertext\u201d make this clearer?",
              "createdAt": "2020-03-26T18:27:07Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjk3MzAz",
          "commit": {
            "abbreviatedOid": "5a59b51"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:29:46Z",
          "updatedAt": "2020-03-26T18:29:47Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "If the adversary doesn't have access to the ephemeral or private shares, this isn't possible, right? ",
              "createdAt": "2020-03-26T18:29:46Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNzgwOTk5",
          "commit": {
            "abbreviatedOid": "f9c99c9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T11:36:08Z",
          "updatedAt": "2020-03-27T11:36:08Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Is it ok to use the already defined `len()` for the psk?\r\n```\r\n- `len(x)`: The length of the byte string `x`, expressed as a\r\n  two-byte unsigned integer in network (big-endian) byte order\r\n```\r\nFor now `len()` is only used to get the length of the nonce:\r\n```\r\ndef Context.Nonce(seq):\r\n  encSeq = encode_big_endian(seq, len(self.nonce))\r\n  return xor(self.nonce, encSeq)\r\n```\r\nBy the way, why compute the length of the nonce here? We know that it has length `Nn`. Also, why does encode_big_endian apparently need the length in \u201cnetwork (big-endian) byte order\u201d and as two-byte integer?",
              "createdAt": "2020-03-27T11:36:08Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTY3NTE2",
          "commit": {
            "abbreviatedOid": "f9c99c9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:33:46Z",
          "updatedAt": "2020-03-27T15:33:47Z",
          "comments": [
            {
              "originalPosition": 163,
              "body": "Yep, it's fine, and preferred! We pass a length in case the resulting number needs to be padded with zeros.",
              "createdAt": "2020-03-27T15:33:47Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTY5MTU2",
          "commit": {
            "abbreviatedOid": "7e98278"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:35:34Z",
          "updatedAt": "2020-03-27T15:35:34Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-03-27T15:35:34Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTcyMzk5",
          "commit": {
            "abbreviatedOid": "7e98278"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:39:13Z",
          "updatedAt": "2020-03-27T15:39:14Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nBy design, the calls to Extract and Expand inside DHKEM and the remainder of HPKE \r\nhave different prefix-free encodings for the second parameter. This is achieved by the \r\ndifferent prefix-free label parameters in the calls to LabeledExtract and LabeledExpand. \r\nThis serves to separate all Extract and Expand invocation input domains. It also justifies \r\nmodeling them as independent functions even if instantiated by the same KDF.\r\n```",
              "createdAt": "2020-03-27T15:39:14Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTc0OTg0",
          "commit": {
            "abbreviatedOid": "7e98278"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:42:11Z",
          "updatedAt": "2020-03-27T15:42:12Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nin HPKE's Extract or Expand, such as Hash in the case of HKDF. Inputs to these\r\ninvocations MUST apply domain separation such that they cannot collide\r\nwith inputs used inside Extract or Expand.\r\n```",
              "createdAt": "2020-03-27T15:42:11Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTc1MjE0",
          "commit": {
            "abbreviatedOid": "7e98278"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T15:42:27Z",
          "updatedAt": "2020-03-27T15:42:28Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nThe string literal \"RFCXXXX\" used in LabeledExtract and LabeledExpand\r\n```",
              "createdAt": "2020-03-27T15:42:27Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTc1NjYz",
          "commit": {
            "abbreviatedOid": "1cf2e52"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with the pending suggestions -- thanks, @blipp!",
          "createdAt": "2020-03-27T15:42:57Z",
          "updatedAt": "2020-03-27T15:42:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMTA1MDE5",
          "commit": {
            "abbreviatedOid": "5ba9148"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-27T18:27:50Z",
          "updatedAt": "2020-03-27T18:27:50Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "(I don't know why but it's marked as outdated for me, already before my most recent commit)\r\nI applied the suggestions with the \u201csuch\u201d and \u201cthe\u201d. Domain separation is not the solution here because we cannot change the inputs to the internal invocations.",
              "createdAt": "2020-03-27T18:27:50Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0ODk0NjE4",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is on the right track, but needs some tweaks.\r\n",
          "createdAt": "2020-03-31T16:17:03Z",
          "updatedAt": "2020-03-31T16:39:14Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Nit: I would remove the `_` here.",
              "createdAt": "2020-03-31T16:17:04Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 33,
              "body": "Is there a reason to put the label on the IKM vs. the salt?",
              "createdAt": "2020-03-31T16:17:16Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 31,
              "body": "You use `0` for the salt value several times below.  It would be good to clarify whether that means (a) an all-zero octet string (and if so, what length), or (b) the empty octet string.",
              "createdAt": "2020-03-31T16:23:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 108,
              "body": "Nit: Suggest `kemContext`",
              "createdAt": "2020-03-31T16:24:56Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 129,
              "body": "Do we have guidance on what the right answer is?",
              "createdAt": "2020-03-31T16:27:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 11,
              "body": "Can we get rid of `Hash()` now?",
              "createdAt": "2020-03-31T16:29:20Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 288,
              "body": "What does \"respectively\" mean here?  If you mean that they are each individually indifferentiable, I would phrase as \"Each function is individually indifferentiable from a random oracle\".",
              "createdAt": "2020-03-31T16:32:57Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 288,
              "body": "I assume this bullet and the next one are supposed to be \"KDF used in DHKEM\" and \"KDF used in the rest of HPKE\"?  If so, let's just say that.  Something like:\r\n\r\n```\r\n- Extract and Expand (in DHKEM): ...\r\n- Extract and Expand (elsewhere): ...\r\n```",
              "createdAt": "2020-03-31T16:34:07Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 310,
              "body": "\"In the PSK and AuthPSK modes, ...\"",
              "createdAt": "2020-03-31T16:34:37Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 323,
              "body": "How does Seal/Open prevent this?  If you behave differently on decryption failure, then it seems like you still create an oracle.  ",
              "createdAt": "2020-03-31T16:35:57Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 329,
              "body": "What do you mean by \"it is enough\"?  Also, I don't understand the dependency on DHKEM here.",
              "createdAt": "2020-03-31T16:38:19Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 166,
              "body": "Why do we need this explicit hashing step?  Shouldn't the internals of `LabeledExtract` handle that for us?",
              "createdAt": "2020-03-31T16:38:59Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTQ5MDc5",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:24:53Z",
          "updatedAt": "2020-03-31T17:24:54Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "In the end, the goal of the label is to separate the input domains of all HMAC calls. This concerns both Extract and Expand. The three Expand calls for key, nonce, exporter_secret already have a label as prefix of the second argument, and that's why it's in the second argument for Extract, too (and thus attached to the IKM).",
              "createdAt": "2020-03-31T17:24:53Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTUzODky",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:31:06Z",
          "updatedAt": "2020-03-31T17:31:07Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "In this pull request, I suggest one particular KDF for each of DHKEM's DH groups. This recommendation is based on the security level of the DH group. We could include as guidance that choosing the same KDF for the remainder of KDF is the best trade-of: this keeps the security level of DHKEM while not pretending a higher security level by using a KDF with greater output length.\r\n\r\nDoes this go into the direction you meant to go with your question?",
              "createdAt": "2020-03-31T17:31:06Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTU1MTc1",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:32:52Z",
          "updatedAt": "2020-03-31T17:32:52Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I also had this thought but didn't follow it yet, thanks for bringing it up. I think we can get rid of Hash. I'll have a look where in the spec this would need adjustment.",
              "createdAt": "2020-03-31T17:32:52Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTU3NTI3",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:36:00Z",
          "updatedAt": "2020-03-31T17:36:01Z",
          "comments": [
            {
              "originalPosition": 288,
              "body": "Ups, sorry that one slipped through after removing the `_kem` suffix. Yes, it means \u201cEach function [\u2026]\u201d.",
              "createdAt": "2020-03-31T17:36:00Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTY0MTUz",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:44:51Z",
          "updatedAt": "2020-03-31T17:44:52Z",
          "comments": [
            {
              "originalPosition": 323,
              "body": "New proposal:\r\n\r\nThus, HPKE's PSK mechanism is not suitable for use with a low-entropy\r\npassword as the PSK: in scenarios in which the adversary knows the\r\nKEM shared secret zz and has access to an oracle that allows to distinguish\r\nbetween a good and a wrong key, it can perform a dictionary attack on the PSK.\r\nThis oracle can be the decryption operation on a captured HPKE ciphertext or\r\nany other recipient behavior which is observably different when using a wrong key.",
              "createdAt": "2020-03-31T17:44:51Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTcyNzE3",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T17:56:14Z",
          "updatedAt": "2020-03-31T17:56:14Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "The adversary knows the KEM shared secret zz in certain compromise scenarios. We were hesitant to make a general claim about compromise scenarios with a general KEM. But maybe it's actually possible. Have to think about it.\r\n\r\nThe \u201cenough\u201d because people could think that for DHKEM's AuthPSK it is not enough to know only the recipient's private static key, but that knowing the sender's private static key is also necessary; because of key-compromise impersonation this is not the case. We could do without the \u201cenough\u201d and say \u201cFor DHKEM this is the case if the adversary knows all private keys of one participant\u201d.",
              "createdAt": "2020-03-31T17:56:14Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTc4NjIw",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-31T18:04:11Z",
          "updatedAt": "2020-03-31T18:04:11Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Are you suggesting that this `if` should be inside LabeledExtract? This is the only place where we give an arbitrary-length bitstring as the first parameter to (Labeled)Extract, so maybe it's wasteful to have the branching every time (even for all the calls with 0 as first parameter)? If you say you prefer this to have a cleaner KeySchedule, I think I could agree.\r\n\r\nJust in case: Have you seen my earlier comment? It might have been buried within this long discussion, so let me cite:\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50#issuecomment-603568796\r\n\r\n> On the PSK length:\r\n> \r\n> HMAC(K, M) feeds K through a call to Hash if K is longer than Hash's blocksize. If we allow arbitrary-size PSKs for user convenience, this would introduce another place where Hash is called on arbitrary-sized input, just like with info and pskID. (As a reminder: Arbitrary-sized input to Hash can lead to collisions with input to Hash calls inside HMAC. This would render the proof inapplicable that proves indifferentiability of HMAC from a random oracle. To avoid collisions, we use Extract calls and separate the input domains by using a prefix).\r\n> \r\n> To avoid this extra Hash call inside HMAC, we can just anticipate it directly in KeySchedule, and thus control the prefix. While this introduces branching inside KeySchedule, this branching would either way be done inside HMAC. Doing the Extract call even if the PSK is shorter then Nb would hurt performance in non-PSK modes, too.\r\n\r\n",
              "createdAt": "2020-03-31T18:04:11Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTgwNDI1",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "(Github said: \u201cYou need to leave a comment indicating the requested changes.\u201d, so I just copied this text here)",
          "createdAt": "2020-03-31T18:06:43Z",
          "updatedAt": "2020-03-31T18:07:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NDkxMjIw",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-02T14:37:19Z",
          "updatedAt": "2020-04-02T14:37:19Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "For a \u201cgood or bad PSK\u201d oracle, knowing the secrets of _one_ party is enough because: Each one of the two parties involved in HPKE must be able to decrypt a message, and each party only knows its own secrets.\r\n\r\nI will rephrase the paragraph accordingly.",
              "createdAt": "2020-04-02T14:37:19Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MjMzOTQz",
          "commit": {
            "abbreviatedOid": "d48bab9"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T13:02:22Z",
          "updatedAt": "2020-04-03T13:02:22Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "I am reading specs of Keccak and Blake2/3 to see if they do internal hashing in their KDF/XOF modes that could collide with a Hash call inside HPKE. This `len > Nb` step is very specific to HMAC, and people might implement Extract and Expand with something different. So maybe we can come up with a more general statement here instead of hardcoding support for HMAC.",
              "createdAt": "2020-04-03T13:02:22Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDQ3NDA4",
          "commit": {
            "abbreviatedOid": "8a2d43c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T17:28:20Z",
          "updatedAt": "2020-04-03T17:31:31Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "Right, I was thinking that in the HKDF case, this duplicated what HMAC was doing internally.  If there's nothing current that is doing something that would collide, I would suggest we remove this, and maybe add a note about the assumption we're making about the KDF (no internal hashing that could collide).",
              "createdAt": "2020-04-03T17:28:21Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 323,
              "body": "Works for me, thanks.",
              "createdAt": "2020-04-03T17:30:06Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            },
            {
              "originalPosition": 329,
              "body": "I see.  I think I misunderstood the \"Scenaris where the adversary knows zz\" above.  With your new text above, it's clearer.",
              "createdAt": "2020-04-03T17:31:24Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMDgyMDg2",
          "commit": {
            "abbreviatedOid": "8a2d43c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T15:24:59Z",
          "updatedAt": "2020-04-08T15:25:00Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "In commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/e7313ea2845c72a543dcc32f1eb2be99acb2d9d9, I chose to make explicit what HKDF-Extract would do by default, by using `zero(Nh)`.",
              "createdAt": "2020-04-08T15:25:00Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTA2NTU5",
          "commit": {
            "abbreviatedOid": "1c84680"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T15:52:11Z",
          "updatedAt": "2020-04-08T15:52:11Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "To everyone: I attempted to clarify this in commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/1c84680727de94679dcf1f96c7c401a0cc8178b8, please let me know if you think this works. I decided to attach this to the previous paragraph, because it kind of belongs to it; please let me know if you like that.",
              "createdAt": "2020-04-08T15:52:11Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTM0MTgz",
          "commit": {
            "abbreviatedOid": "1c84680"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T16:24:15Z",
          "updatedAt": "2020-04-08T16:24:16Z",
          "comments": [
            {
              "originalPosition": 329,
              "body": "This reads well to me. Thanks for clarifying, @blipp!",
              "createdAt": "2020-04-08T16:24:16Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTM2NDMz",
          "commit": {
            "abbreviatedOid": "1c84680"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T16:27:07Z",
          "updatedAt": "2020-04-08T16:27:08Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "@bifurcation this isn't quite duplicating what HMAC is doing internally, since it explicitly prefixes the input before hashing.",
              "createdAt": "2020-04-08T16:27:07Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjIwMzkw",
          "commit": {
            "abbreviatedOid": "421828d"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:20:46Z",
          "updatedAt": "2020-04-08T18:20:46Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "With commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/421828db601168b9f81acc6d299754e477e4d10a, the PSK is now always fed through LabeledExtract. I included my reasoning in the commit message. Please let me know if that makes sense to you.",
              "createdAt": "2020-04-08T18:20:46Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjIyMzg4",
          "commit": {
            "abbreviatedOid": "421828d"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:23:29Z",
          "updatedAt": "2020-04-08T18:23:30Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "An alternative to feeding the PSK always through LabeledExtract is to restrict the PSK to a fixed length, for example to Nh.",
              "createdAt": "2020-04-08T18:23:30Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjIzNjg1",
          "commit": {
            "abbreviatedOid": "421828d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:25:15Z",
          "updatedAt": "2020-04-08T18:25:16Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-04-08T18:25:15Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjI1OTUy",
          "commit": {
            "abbreviatedOid": "8772378"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:28:21Z",
          "updatedAt": "2020-04-08T18:28:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Removed Hash (and Nb) with commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/877237816152d2a58dc866bba1c9e12b3c4a5a93.",
              "createdAt": "2020-04-08T18:28:21Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjMyNTA2",
          "commit": {
            "abbreviatedOid": "fbea8c0"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:37:11Z",
          "updatedAt": "2020-04-08T18:37:11Z",
          "comments": [
            {
              "originalPosition": 288,
              "body": "Addressed in commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/fbea8c041a50b6db3a458b7c2cdefa4cdb1014e8.",
              "createdAt": "2020-04-08T18:37:11Z",
              "updatedAt": "2020-04-08T20:11:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjk2Mzk0",
          "commit": {
            "abbreviatedOid": "09acc77"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T20:12:47Z",
          "updatedAt": "2020-04-08T20:12:48Z",
          "comments": [
            {
              "originalPosition": 166,
              "body": "If someone implements Extract and Expand with something else than HKDF, like a modern hash function's KDF and XOF modes, then this PSK hashing step is probably not needed. I attempted a formulation with commit https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/50/commits/09acc770c7604185836085499b7284dcfa0568a8.",
              "createdAt": "2020-04-08T20:12:47Z",
              "updatedAt": "2020-04-08T20:12:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNjUwNzA5",
          "commit": {
            "abbreviatedOid": "09acc77"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-10T20:31:16Z",
          "updatedAt": "2020-04-10T20:31:16Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_dhkem",
      "headRefOid": "09acc770c7604185836085499b7284dcfa0568a8",
      "mergeCommit": {
        "oid": "916823a65f4cbf1f7f0918f96fd6062968f06d68"
      }
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1NjQ0NjEw",
      "title": "Clarify KeySchedule inputs: it's an encoded public key",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/51",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-09T15:09:51Z",
      "updatedAt": "2020-03-09T16:11:29Z",
      "closedAt": "2020-03-09T16:08:52Z",
      "mergedAt": "2020-03-09T16:08:52Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, deleted the default for pskID being zero(0) because for info it's also just defined as \"\".",
          "createdAt": "2020-03-09T15:13:15Z",
          "updatedAt": "2020-03-09T15:13:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjc3MjEw",
          "commit": {
            "abbreviatedOid": "4de3de8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-09T15:20:48Z",
          "updatedAt": "2020-03-09T15:20:53Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n* `pskID` - An identifier for the PSK (optional; default value `zero(0)`)\r\n```",
              "createdAt": "2020-03-09T15:20:49Z",
              "updatedAt": "2020-03-09T15:50:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjc5MjIw",
          "commit": {
            "abbreviatedOid": "4de3de8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T15:23:03Z",
          "updatedAt": "2020-03-09T15:23:03Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "That works as well. I would change it for `info` as well then, to zero(0)?",
              "createdAt": "2020-03-09T15:23:03Z",
              "updatedAt": "2020-03-09T15:50:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjkxMDQy",
          "commit": {
            "abbreviatedOid": "4de3de8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T15:36:18Z",
          "updatedAt": "2020-03-09T15:36:18Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Well, pskID is an opaque byte string and has a default value in the pseudocode (`zero(0)`), whereas `info` is traditionally considered to be a UTF8-encoded string. Maybe we could clarify that instead?  @bifurcation, penny for your thoughts?",
              "createdAt": "2020-03-09T15:36:18Z",
              "updatedAt": "2020-03-09T15:50:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjk3ODI0",
          "commit": {
            "abbreviatedOid": "4de3de8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-09T15:43:48Z",
          "updatedAt": "2020-03-09T15:43:48Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Ah you are right, I forgot about the default for pskID. Given that, I like your suggestion to have zero(0) for pskID and \"\" for info.",
              "createdAt": "2020-03-09T15:43:48Z",
              "updatedAt": "2020-03-09T15:50:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzE4OTk0",
          "commit": {
            "abbreviatedOid": "ecede56"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-09T16:08:18Z",
          "updatedAt": "2020-03-09T16:08:18Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a025ae8aa80bcdc5065f5a25cf93bb971582bcfc",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_key_schedule_inputs",
      "headRefOid": "ecede56bd01859b652cb8fef9eccb0f195897b25",
      "mergeCommit": {
        "oid": "72f04cd7eb0138de86300d305d516a82d7d638bd"
      }
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg3NTI5NDA2",
      "title": "Add self as author.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/54",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-13T00:09:51Z",
      "updatedAt": "2020-03-13T20:32:50Z",
      "closedAt": "2020-03-13T20:32:50Z",
      "mergedAt": "2020-03-13T20:32:50Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "72f04cd7eb0138de86300d305d516a82d7d638bd",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/author",
      "headRefOid": "77a32fd23c210fb9eb6bf7d8770617f37efde9fc",
      "mergeCommit": {
        "oid": "ea4494566f7d2ef764b27ae36af2837415a46ef6"
      }
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxNDYyMzE1",
      "title": "Reference revision 3 of NIST.SP.800-56A (and insert newlines to make .md more readable on Github)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/55",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is revision 3 of NIST.SP.800-56A since a while. Is there a specific reason why revision 2 is referenced? If not then this pull request proposes to change the reference to revision 3.\r\n\r\nI did /not/ check if, for example, broadly-deployed implementations are not yet implementing revision 3.",
      "createdAt": "2020-03-20T10:43:06Z",
      "updatedAt": "2020-03-20T14:37:28Z",
      "closedAt": "2020-03-20T14:36:58Z",
      "mergedAt": "2020-03-20T14:36:58Z",
      "mergedBy": "chris-wood",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "None that I'm aware of. We can always change to revision 3 if folks tell us otherwise!",
          "createdAt": "2020-03-20T14:37:28Z",
          "updatedAt": "2020-03-20T14:37:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTM4MTk4",
          "commit": {
            "abbreviatedOid": "30c4527"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-20T14:36:47Z",
          "updatedAt": "2020-03-20T14:36:47Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ea4494566f7d2ef764b27ae36af2837415a46ef6",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_56ar3",
      "headRefOid": "30c452723e2804d15312291c95ac416d06df6039",
      "mergeCommit": {
        "oid": "1674f75832d0f633119f1f5f032ad340a47b6ce0"
      }
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxNTE1MDM5",
      "title": "Clarify key validation, as it is different for NIST curves and Curve25519/448",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/56",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Points to discuss:\r\n\r\n- I made this proposal with \u201cMAY check whether the shared secret is the all-zero value\u201d for Curve25519/448 because this how the RFC states it. We can discuss if HPKE should be more opinionated on it\r\n- I shortened the discussion of validation in Section \u201cCreating the Encryption Context\u201d and instead link to {{kem-ids}}. I added the more or less same paragraph to Section \u201cDH-Based KEM\u201d because that is where DHKEM is actually defined. We can discuss if one of the two places is enough to mention validation.",
      "createdAt": "2020-03-20T12:50:14Z",
      "updatedAt": "2020-03-23T15:45:50Z",
      "closedAt": "2020-03-23T15:45:50Z",
      "mergedAt": "2020-03-23T15:45:50Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTQwMjc1",
          "commit": {
            "abbreviatedOid": "5133b33"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-20T14:39:15Z",
          "updatedAt": "2020-03-20T14:40:26Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nFor authenticated modes the same validation MUST be done for the static\r\n```",
              "createdAt": "2020-03-20T14:39:15Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            },
            {
              "originalPosition": 17,
              "body": "We lost this recommendation (check `pkR`) in the new text. Can we bring it back?",
              "createdAt": "2020-03-20T14:39:56Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NjI1MTQ2",
          "commit": {
            "abbreviatedOid": "22787c2"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-20T16:17:18Z",
          "updatedAt": "2020-03-20T16:17:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Please let me know if you think this is addressed by my most recent change.",
              "createdAt": "2020-03-20T16:17:19Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4OTM4OTgz",
          "commit": {
            "abbreviatedOid": "22787c2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Couple more nits!",
          "createdAt": "2020-03-21T18:12:24Z",
          "updatedAt": "2020-03-21T18:13:07Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Can we move the text from \"The sender MUST...\" to the end of this paragraph to its own paragraph? By folding this into the paragraph specific to NIST curves, it might read as though it only applies to NIST curves, which is not the intent.",
              "createdAt": "2020-03-21T18:12:24Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            },
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nSenders and recipients MUST validate KEM inputs and outputs as described\r\n```",
              "createdAt": "2020-03-21T18:12:49Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nSenders and recipients MUST validate KEM inputs and outputs as described\r\n```",
              "createdAt": "2020-03-21T18:12:59Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NDE5MDY4",
          "commit": {
            "abbreviatedOid": "ce6ad5b"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T13:19:14Z",
          "updatedAt": "2020-03-23T13:19:15Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I am not sure how to deal with this, so I'll lay out what my current view is: In the current version of HPKE, there is only NIST curves and Curve25519/448. Public key validation applies for the NIST curves but not for Curve25519/448. Which means in this context, it applies only to NIST curves.",
              "createdAt": "2020-03-23T13:19:14Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NTEyOTEw",
          "commit": {
            "abbreviatedOid": "ce6ad5b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T14:59:42Z",
          "updatedAt": "2020-03-23T14:59:42Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "This seems to be conflating two things: what curves require validation, and what keys are validated. I think we should separate these two. (I also think we should validate curve25519 and curve448 points, too, as the previous text suggested.)",
              "createdAt": "2020-03-23T14:59:42Z",
              "updatedAt": "2020-03-23T15:43:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NTU3ODYy",
          "commit": {
            "abbreviatedOid": "8aa9439"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Much better -- thanks!",
          "createdAt": "2020-03-23T15:45:04Z",
          "updatedAt": "2020-03-23T15:45:04Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ea4494566f7d2ef764b27ae36af2837415a46ef6",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_curves",
      "headRefOid": "8aa9439e4400f78f142ee8f72aeb8a13d532cd6c",
      "mergeCommit": {
        "oid": "b3baa62ce8b603ec60553cb728ba92e30c34924b"
      }
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxNTgwNTM2",
      "title": "Clarified endianness of ciphersuite serialization",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/57",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was an ambiguity. `concat` is only defined for bytestrings, but the ciphersuite identifiers are all u16. Since everything else is big-endian, it makes sense for this to be big-endian as well.",
      "createdAt": "2020-03-20T15:03:16Z",
      "updatedAt": "2020-03-23T15:46:03Z",
      "closedAt": "2020-03-23T15:46:03Z",
      "mergedAt": "2020-03-23T15:46:03Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NjAwMzY5",
          "commit": {
            "abbreviatedOid": "7996c02"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "cc @bifurcation ",
          "createdAt": "2020-03-20T15:48:12Z",
          "updatedAt": "2020-03-20T15:48:12Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "1674f75832d0f633119f1f5f032ad340a47b6ce0",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "7996c0232eeec6eb6d8803b477d19368721f153b",
      "mergeCommit": {
        "oid": "bf47c4c73e825839fa7d506ce709f32a593e9a48"
      }
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNDcwODQ5",
      "title": "Add missing 'not' for Curve25519/448",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/58",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-23T15:52:36Z",
      "updatedAt": "2020-03-23T15:54:03Z",
      "closedAt": "2020-03-23T15:54:03Z",
      "mergedAt": "2020-03-23T15:54:03Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NTY2ODMx",
          "commit": {
            "abbreviatedOid": "f0b91b6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-23T15:53:56Z",
          "updatedAt": "2020-03-23T15:53:56Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "bf47c4c73e825839fa7d506ce709f32a593e9a48",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "f0b91b68c56999574c80e0f2503c3ea296321521",
      "mergeCommit": {
        "oid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774"
      }
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyNjE5NDc5",
      "title": "Recommend minimum length for PSKs.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/59",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @blipp ",
      "createdAt": "2020-03-23T20:22:16Z",
      "updatedAt": "2020-03-26T18:19:00Z",
      "closedAt": "2020-03-26T18:17:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp @bifurcation fixed -- please have a look! If you're OK with the text, can we move it to #50?",
          "createdAt": "2020-03-25T00:40:53Z",
          "updatedAt": "2020-03-25T00:45:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #50.",
          "createdAt": "2020-03-26T18:17:06Z",
          "updatedAt": "2020-03-26T18:17:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODM2NjUy",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T21:29:17Z",
          "updatedAt": "2020-03-23T21:29:25Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Is this actually true?  How would such a dictionary attack be mounted without access to either the ephemeral private key or the recipient private key?",
              "createdAt": "2020-03-23T21:29:17Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODM3NTgz",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T21:30:50Z",
          "updatedAt": "2020-03-23T21:30:50Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Say a given client and server have a low entropy PSK k. The adversary can search for it by sending messages to the server, with test PSKs, and seeing which of those are decrypted successfully or not.",
              "createdAt": "2020-03-23T21:30:50Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODQ0NDA3",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T21:42:32Z",
          "updatedAt": "2020-03-23T21:42:33Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Hm, that seems like an oracle provided by a higher-layer protocol, not by HPKE.",
              "createdAt": "2020-03-23T21:42:33Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5ODUwNTMy",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-23T21:53:33Z",
          "updatedAt": "2020-03-23T21:53:34Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Is it? (Either way, we should probably say *something* about it, right?) What text would you propose?",
              "createdAt": "2020-03-23T21:53:33Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzUzMDA0",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T22:53:27Z",
          "updatedAt": "2020-03-24T22:53:28Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I think a dictionary attack would only be feasible if the adversary already knows the KEM keys, like the ephemeral and the static key(s). Then the adversary can use the decryption of the authenticated encryption as an oracle: it fails if the key is not correct.\r\n\r\nA quantum adversary could for example know all KEM keys of a classic (non-post-quantum) KEM, but not the PSK, and then mount this attack.\r\n\r\nHowever, the statement about low-entropy PSKs depends on the employed KDF algorithm. At this place in the spec, the definitions are still rather general. Only later it becomes obvious that HPKE is specified with HKDF and SHA2. HKDF's RFC clearly states that it is not designed to slow down dictionary attacks [1].\r\n\r\n[1] https://hyp.is/xAKxmG4hEeqyB5fD4eRdUQ/tools.ietf.org/html/rfc5869",
              "createdAt": "2020-03-24T22:53:28Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzY5ODEw",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T23:36:26Z",
          "updatedAt": "2020-03-24T23:36:27Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Yes, in the example I gave, the adversary is active and knows the sender ephemeral keys.",
              "createdAt": "2020-03-24T23:36:27Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNzc1ODM5",
          "commit": {
            "abbreviatedOid": "96c0011"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-24T23:54:00Z",
          "updatedAt": "2020-03-24T23:54:01Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "As discussed with @chris-wood off-channel yesterday, I folded this into pull request #50 and make a proposal for a text there.",
              "createdAt": "2020-03-24T23:54:00Z",
              "updatedAt": "2020-03-25T17:22:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjc4NTY3",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:07:30Z",
          "updatedAt": "2020-03-26T18:07:31Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I chose a formulation different from \u201cderived from at least Nh bytes of entropy\u201d in #50 because I think deriving from Nh bytes of entropy does not mean that the result of this derivation keeps those Nh bytes of entropy. (e.g. it could be a hash of an appropriate output length for keeping the entropy but then you cut it in half)",
              "createdAt": "2020-03-26T18:07:31Z",
              "updatedAt": "2020-03-26T18:07:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjc5NDk3",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:08:39Z",
          "updatedAt": "2020-03-26T18:08:40Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I tried to find a more general formulation in #50 that considers all cases where the adversary has access to zz.",
              "createdAt": "2020-03-26T18:08:40Z",
              "updatedAt": "2020-03-26T18:08:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjgxMzQx",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:11:00Z",
          "updatedAt": "2020-03-26T18:11:00Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "I prefer not to invoke IND-CCA here because IND-CCA does not state anything about if the ciphertext reveals smth about the key. It just assumes that the key is random and secret.",
              "createdAt": "2020-03-26T18:11:00Z",
              "updatedAt": "2020-03-26T18:11:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjg1NjI2",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:16:23Z",
          "updatedAt": "2020-03-26T18:16:23Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Good point! I'm fine with the variant.",
              "createdAt": "2020-03-26T18:16:23Z",
              "updatedAt": "2020-03-26T18:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjg1OTk2",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:16:51Z",
          "updatedAt": "2020-03-26T18:16:51Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "\ud83d\udc4d  I left a comment over there.",
              "createdAt": "2020-03-26T18:16:51Z",
              "updatedAt": "2020-03-26T18:16:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjg2MDk3",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:16:59Z",
          "updatedAt": "2020-03-26T18:17:00Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "That works!",
              "createdAt": "2020-03-26T18:16:59Z",
              "updatedAt": "2020-03-26T18:17:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjg3NjY2",
          "commit": {
            "abbreviatedOid": "b3ac918"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T18:19:00Z",
          "updatedAt": "2020-03-26T18:19:00Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Actually IND-CCA is what makes the dictionary attack possible in case of a low-entropy key, because of the ciphertext integrity part of IND-CCA, which provides the (decryption failure) oracle.",
              "createdAt": "2020-03-26T18:19:00Z",
              "updatedAt": "2020-03-26T18:19:00Z"
            }
          ]
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/psk-lengths",
      "headRefOid": "b3ac918c3ccf2cb08278ccd90acbd905eec4085e",
      "mergeCommit": null
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk0Nzc1MTUy",
      "title": "Clarification on validation for NIST curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/60",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Implicitly, it might be assumed that the scalar (private key) is honestly generated and thus ensured to be in the correct interval. This proposed change makes this more explicit.",
      "createdAt": "2020-03-27T14:09:02Z",
      "updatedAt": "2020-03-30T22:54:46Z",
      "closedAt": "2020-03-30T22:54:46Z",
      "mergedAt": "2020-03-30T22:54:46Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0Mjg5NDk5",
          "commit": {
            "abbreviatedOid": "83b124e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-30T22:54:40Z",
          "updatedAt": "2020-03-30T22:54:40Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_validation",
      "headRefOid": "83b124e287c4df6d22392fe1bd7361e1f89e9a1c",
      "mergeCommit": {
        "oid": "8dafe8aee83c8440be7d622722474e45ccf69037"
      }
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk0OTE0OTM3",
      "title": "Simplify definition of the len function",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/61",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- We know that the length of the nonce is `Nn` because it was created with `Expand(\u2026, \u2026, Nn)`, so we don't need a dynamic computation of it.\r\n- For `len` and `zero`, clarify that the length is in bytes\r\n\r\nNow the _only_ use of `len` is when we compare the length of the PSK to `Nb` (if #50 gets merged as is):\r\n```\r\n  if len(psk) > Nb then:\r\n    psk = LabeledExtract(0, \"psk\", psk)\r\n```\r\n\r\nI suggest that in the definition of `len` we remove the part that details that the result is `expressed as two-byte unsigned integer in network (big-endian) byte order`. Arguments pro:\r\n- little-endian is the dominant ordering for processor architectures. This would mean that most implementations must do extra work to have len return big-endian, just to notice then that Nb is little-endian and that they cannot compare a big-endian value to a little-endian one.\r\n- it arbitrarily limits the PSK to 2^16 bytes\r\n- we don't specify how implementations have to store local integer values like `Nn`, `Nh`, etc so it seems overly specific to impose a certain encoding for the result of an internal function",
      "createdAt": "2020-03-27T18:44:06Z",
      "updatedAt": "2020-03-30T22:56:17Z",
      "closedAt": "2020-03-30T22:56:17Z",
      "mergedAt": "2020-03-30T22:56:17Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MjkwMTQy",
          "commit": {
            "abbreviatedOid": "3463416"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-30T22:56:12Z",
          "updatedAt": "2020-03-30T22:56:12Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8d1a29a3dffd46a3cc69d315e5dfe58a74961774",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_len",
      "headRefOid": "3463416951bf30502c71e687476883bad28fb4b6",
      "mergeCommit": {
        "oid": "cf81e410aad729da44387aefa8edd294f6d1ca0e"
      }
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyMzU2MjE5",
      "title": "Fix various leftover issues and update test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/62",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new test vectors omit fields not needed by certain modes, e.g., `psk` and `pskID` are not included in non-PSK modes.\r\n\r\ncc @blipp",
      "createdAt": "2020-04-12T15:34:18Z",
      "updatedAt": "2020-04-17T14:59:07Z",
      "closedAt": "2020-04-17T14:59:07Z",
      "mergedAt": "2020-04-17T14:59:07Z",
      "mergedBy": "bifurcation",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMjA3Njk3",
          "commit": {
            "abbreviatedOid": "05e9d15"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Good catches with the Setup functions, thanks!",
          "createdAt": "2020-04-13T15:12:08Z",
          "updatedAt": "2020-04-13T15:18:06Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "maybe add bytes as we did in some other places? Like \u201cof fixed length `Nh` bytes\u201d, or \u201cof length `Nh` bytes\u201d",
              "createdAt": "2020-04-13T15:12:08Z",
              "updatedAt": "2020-04-13T15:22:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMjE0NDQz",
          "commit": {
            "abbreviatedOid": "05e9d15"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-13T15:21:59Z",
          "updatedAt": "2020-04-13T15:22:00Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n  - Extract(salt, IKM): Extract a pseudorandom key of fixed length `Nh` bytes\r\n```",
              "createdAt": "2020-04-13T15:21:59Z",
              "updatedAt": "2020-04-13T15:22:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTMwMDE5",
          "commit": {
            "abbreviatedOid": "017a94d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-17T14:59:02Z",
          "updatedAt": "2020-04-17T14:59:02Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "916823a65f4cbf1f7f0918f96fd6062968f06d68",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/nits",
      "headRefOid": "017a94da26766d7b7d5ae41868230725d337714f",
      "mergeCommit": {
        "oid": "4a1a0ac3350fb837ef9b339a881dc284c07454e3"
      }
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyNjg3Njgz",
      "title": "Only hash PSK in the PSK and AuthPSK modes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/63",
      "state": "CLOSED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the Base and Auth modes, the only PSK ever used is the default psk, which is constant and all zero. Instead of transforming the Nh bytes default psk into another constant of length Nh bytes, using LabeledExtract, we can just not transform the default psk at all and use it directly. This removes the performance penalty for non-psk modes.\r\n\r\nAn alternative would be that implementations pre-computed the transformed default psk value. This seems a stretch to me, as transforming the default psk does not buy anything in terms of provable security. If we assume that implementations specialize for one particular HPKE mode anyway, it also does not buy much in terms of reducing probability of implementation mistakes.",
      "createdAt": "2020-04-13T15:07:53Z",
      "updatedAt": "2020-04-23T17:37:41Z",
      "closedAt": "2020-04-23T17:37:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> An alternative would be that implementations pre-computed the transformed default psk value. This seems a stretch to me, as transforming the default psk does not buy anything in terms of provable security. If we assume that implementations specialize for one particular HPKE mode anyway, it also does not buy much in terms of reducing probability of implementation mistakes.\r\n\r\nI prefer this approach. It lets implementations pre-compute that value and simplify their KeySchedule code (no branches). ",
          "createdAt": "2020-04-23T16:41:46Z",
          "updatedAt": "2020-04-23T16:41:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with @chris-wood here.  Pre-hashing constant values is a known optimization trick; there's a similar issue with early data / PSKs in TLS.  I would suggest we just add a note somewhere reminding people that this optimization is possible.",
          "createdAt": "2020-04-23T17:09:25Z",
          "updatedAt": "2020-04-23T17:09:25Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's fine with me, I'll close this pull request. The note about the pre-computation can go into a separate PR.",
          "createdAt": "2020-04-23T17:37:41Z",
          "updatedAt": "2020-04-23T17:37:41Z"
        }
      ],
      "reviews": [],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "916823a65f4cbf1f7f0918f96fd6062968f06d68",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_psk",
      "headRefOid": "84ef51656daf93ac3a74e49a3cbfaebd1d09afcf",
      "mergeCommit": null
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyNjk4MDM3",
      "title": "Remove unused function len",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/64",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "as the PSK hashing step does no longer depend on the PSK's length.",
      "createdAt": "2020-04-13T15:30:54Z",
      "updatedAt": "2020-04-23T16:36:30Z",
      "closedAt": "2020-04-23T16:36:30Z",
      "mergedAt": "2020-04-23T16:36:30Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5Mjc4ODg1",
          "commit": {
            "abbreviatedOid": "7754f3b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-23T16:36:24Z",
          "updatedAt": "2020-04-23T16:36:24Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "916823a65f4cbf1f7f0918f96fd6062968f06d68",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_len",
      "headRefOid": "7754f3b64934f63f5f7d63f4f6b7d886890b5345",
      "mergeCommit": {
        "oid": "fe97496c9ede2f8eaa106e3e607d43d6f4ac0dee"
      }
    },
    {
      "number": 65,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEyNjM3ODEz",
      "title": "Change labels for pskID and psk to be prefix-free",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/65",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We claim in the document that all our labels are prefix-free, but the labels for pskID (\"pskID\") and psk (\"psk\") were actually not prefix-free. Appending \"_hash\" is just the first thing I came up with, I am open to other suggestions for maybe shorter labels for these two cases.",
      "createdAt": "2020-05-03T17:36:17Z",
      "updatedAt": "2020-05-04T19:59:12Z",
      "closedAt": "2020-05-04T19:59:12Z",
      "mergedAt": "2020-05-04T19:59:12Z",
      "mergedBy": "chris-wood",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MzAyNzU5",
          "commit": {
            "abbreviatedOid": "d4d09d1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-04T19:59:06Z",
          "updatedAt": "2020-05-04T19:59:06Z",
          "comments": []
        }
      ],
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fe97496c9ede2f8eaa106e3e607d43d6f4ac0dee",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "patch-2",
      "headRefOid": "d4d09d1591fbad2c2874e4ba631b4ac16deef2be",
      "mergeCommit": {
        "oid": "961a873d95c9631a375d3865feb33cbd88c55de2"
      }
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE0MzkyMDI5",
      "title": "Update vectors and one table nit",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/68",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per #67 and #66. Thanks, @kjacobs-moz!",
      "createdAt": "2020-05-07T00:01:59Z",
      "updatedAt": "2020-05-08T19:28:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "5bc57ba5753f6e76d6350e532c1ca069ac8b228c",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/vectors-and-nits",
      "headRefOid": "0491164a2717047f129c1f2e6b279f304453822f",
      "closedAt": "2020-05-08T19:28:03Z",
      "mergedAt": "2020-05-08T19:28:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "312b9da6fd832e07cccae9381605d657052de147"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These test vectors also pass on my impl",
          "createdAt": "2020-05-07T04:21:30Z",
          "updatedAt": "2020-05-07T04:21:30Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please see https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/67#issuecomment-625067374 where I reason about why the 64 bytes is what we wanted.",
          "createdAt": "2020-05-07T06:56:58Z",
          "updatedAt": "2020-05-07T06:57:32Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think 4.1 may still have a contradictory definition of Nzz (being the length of Extract output - maybe it's supposed to be \"and the output length of the KDF's _Expand_ function is Nzz bytes.\"?\r\n\r\nAs I said in https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/67#issuecomment-625067374, this sentence is really confusing and we should improve it, or delete it. The Expand function has variable output, so while the concrete invocation within ExtractAndExpand uses length Nzz, I believe we should not make a statement that sounds too general.",
          "createdAt": "2020-05-07T06:59:56Z",
          "updatedAt": "2020-05-07T06:59:56Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Proposal: \u201cFor the variants of DHKEM defined in this document, Ndh is equal to Npk, and Nzz is equal to the output length of the hash function underlying the KDF.\u201d\r\n\r\nMaybe we chose to talk about HKDF-Extract in the current version because our abstract definition of a KDF does not mention a hash function, but only Extract and Expand. Given that the variants of DHKEM defined in the document all use HKDF, I think it might be ok and less confusing to write what I proposed.",
          "createdAt": "2020-05-07T07:11:01Z",
          "updatedAt": "2020-05-07T07:11:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp I'll take your proposal -- it clears things up for me. Thanks!",
          "createdAt": "2020-05-07T12:17:09Z",
          "updatedAt": "2020-05-07T12:17:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@kjacobs-moz, @rozbb, @blipp please have a look (and test) the latest vectors and changes. They make clear that Nzz is the KDF's output size. (I also removed superfluous output from {Auth}Decap.)",
          "createdAt": "2020-05-07T12:22:24Z",
          "updatedAt": "2020-05-07T12:22:24Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "NONE",
          "body": "Thanks @chris-wood, @blipp. These vectors pass with the updated Nzz value, though my implementation is limited to base mode. ",
          "createdAt": "2020-05-07T15:15:12Z",
          "updatedAt": "2020-05-07T15:15:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for confirming!",
          "createdAt": "2020-05-07T15:15:59Z",
          "updatedAt": "2020-05-07T15:15:59Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have X448 or P-curves implemented yet, but everything using X25519 passes for me.",
          "createdAt": "2020-05-07T15:22:31Z",
          "updatedAt": "2020-05-07T15:22:31Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @rozbb!",
          "createdAt": "2020-05-07T15:24:07Z",
          "updatedAt": "2020-05-07T15:24:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MDczNzgx",
          "commit": {
            "abbreviatedOid": "c95bfa3"
          },
          "author": "kjacobs-moz",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Thanks! These vectors look right.\r\n\r\nI think 4.1 may still have a contradictory definition of Nzz (being the length of Extract output - maybe it's supposed to be \"and the output length of the KDF's *Expand* function is Nzz bytes.\"?",
          "createdAt": "2020-05-07T00:24:52Z",
          "updatedAt": "2020-05-07T00:24:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 70,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE1NDY5NDA0",
      "title": "Removed mention of subgroups in point validation paragraph",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/70",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is no need to check that a point of a NIST P-curve is in the \"correct prime-order subgroup\" because all P-curves have cofactor 1.\r\n\r\nSource: [NIST FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf) appendix D.1.2",
      "createdAt": "2020-05-08T23:09:09Z",
      "updatedAt": "2020-05-12T12:57:16Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "312b9da6fd832e07cccae9381605d657052de147",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "60edaf522105e5b2b2f61507f079779d13483640",
      "closedAt": "2020-05-12T12:57:10Z",
      "mergedAt": "2020-05-12T12:57:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e955931cdc4e9708da2fd4d905dd920fc4668c85"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2020-05-12T12:57:15Z",
          "updatedAt": "2020-05-12T12:57:15Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE4MDY4Nzky",
      "title": "Clarify psk overwriting",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/73",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-14T15:22:30Z",
      "updatedAt": "2020-05-14T16:11:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "e955931cdc4e9708da2fd4d905dd920fc4668c85",
      "headRepository": "raphaelrobert/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "90399ce722d70c741c1bd467a548af52c28cc7b1",
      "closedAt": "2020-05-14T16:11:03Z",
      "mergedAt": "2020-05-14T16:11:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a9e89a2fa93faf4618590077b517857c06192ea0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExOTYyMzU4",
          "commit": {
            "abbreviatedOid": "90399ce"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2020-05-14T16:10:59Z",
          "updatedAt": "2020-05-14T16:10:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5ODI2NjI3",
      "title": "Updated test-vectors.json",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/78",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The test vectors come from the latest version of `go-hpke`.\r\n\r\nThis does not update the test vectors in the spec itself. I don't know how those are generated, but I assume there is some script to automate the process.\r\n\r\nSolves #75 ",
      "createdAt": "2020-05-19T01:41:23Z",
      "updatedAt": "2020-05-19T15:36:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a9e89a2fa93faf4618590077b517857c06192ea0",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "test_vec",
      "headRefOid": "6a49ec56262760f7a9a4d486b5072a419c62a8e2",
      "closedAt": "2020-05-19T15:36:10Z",
      "mergedAt": "2020-05-19T15:36:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "325c94f111732d8fdab54caac26ceee364de8a69"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 79,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5ODUzMzY3",
      "title": "Defined DeriveKeyPair",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/79",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, HPKE exposes no way of deriving a key pair given random bytes. This functionality is necessary in MLS (in order to have multiple participants derive their ancestor nodes' secret keys). I propose the use of `UnmarshalSk` to do precisely this.\r\n\r\n`UnmarshalSk` need not be a total function. In NIST curves, for example, the `Octet-String-to-Field-Element` function (defined in [SECG](https://secg.org/sec1-v2.pdf)) will return \"invalid\" for inputs that represent integers that are greater than or equal to the modulus. I haven't written it anywhere, but I would like to recommend that any end users who want to call `UnmarshalSk` on some deterministically derived bytes use a KDF chain to do rejection sampling.",
      "createdAt": "2020-05-19T03:25:25Z",
      "updatedAt": "2020-06-10T17:58:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d1e58f3d89c3790fef15c756c6279d0811c6f7ab",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "unmarshal_sk",
      "headRefOid": "b3f9bd7644495a578d9cdbca3a2b5f489a7069b3",
      "closedAt": "2020-06-10T17:58:17Z",
      "mergedAt": "2020-06-10T17:58:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "10c447eb233e7ec057905af544c100288ddca7ea"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There might be a concern that this could just as well be implemented directly at the DHKEM level, and left out of the HPKE spec. The downside of this is that MLS would then have to depend on an HPKE implementation as well a compatible underlying DHKEM implementation.\r\n\r\nI believe that this abstraction is the only thing preventing an HPKE library from abstracting all KEM details away from MLS. This should vastly simplify implementation.",
          "createdAt": "2020-05-19T03:31:49Z",
          "updatedAt": "2020-05-19T03:31:49Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Following @Bren2010 's advice in https://github.com/mlswg/mls-protocol/pull/338, I reverted the `UnmarshalSk` idea. The problem is that `UnmarshalSk` is insufficient to provide a reliable way to generate a keypair. MLS should not have to rejection-sample a private key, as that might not work for some KEMs.\r\n\r\nInstead, I define the `DeriveKeyPair` function, which replaces `GenerateKeyPair`. This function \"knows\" how to reliably generate a private key, so MLS doesn't have to.\r\n\r\nIt works in the obvious way for the CFRG curves, and does rejection sampling for the NIST curves. The bitmask part is necessary because P-521 scalars are only 521 bits long. There's only 1 bit that can be legally set in the MSB. Without clearing the top 7 bits, the candidate key would be rejected with probability 254/256. This bitmask does not impact uniformity.\r\n\r\nFinally, rejection sampling 255 times has overwhelming probability of success. Of the curves above, the one with highest probability of candidate scalar rejection is P-256, with probability 2^(-32). The likelihood that this fails after 255 attempts is 2^(-8160).",
          "createdAt": "2020-05-19T19:27:38Z",
          "updatedAt": "2020-05-19T19:37:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb, can you please resolve the conflict?",
          "createdAt": "2020-05-19T22:21:00Z",
          "updatedAt": "2020-05-19T22:21:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation, please have a look!",
          "createdAt": "2020-05-19T23:11:05Z",
          "updatedAt": "2020-05-19T23:11:05Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another clarification I just realized while implementing: This addition means that there is some KEX functionality that is dependent on the choice of KDF. I think it's obvious that it's the DHKEM's KDF we use for `DeriveKeyPair`, but it could be clearer. It should be made clearer in general which KDF is being used at any time.",
          "createdAt": "2020-05-22T02:49:02Z",
          "updatedAt": "2020-05-22T02:49:02Z"
        },
        {
          "author": "ocheron",
          "authorAssociation": "NONE",
          "body": "For DHKEM implementations, you restrict the length of ikm to be Nsk.\r\nThis is needed for X25519/X448, using identity function.\r\n\r\nAt KEM level (the general interface), Nsk is also introduced but the length of ikm is not restricted.\r\nIs this intended?",
          "createdAt": "2020-06-01T19:38:50Z",
          "updatedAt": "2020-06-01T19:38:50Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I didn't really have a reason for this other than a general hesitation to overspecify the protocol. But now that I think about it, I think this would be good for consistency. It also shouldn't hurt security at all, since we're still requiring the appropriate amount of entropy.",
          "createdAt": "2020-06-01T20:36:22Z",
          "updatedAt": "2020-06-01T20:36:22Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Explanation of the last commit: \"partial public key validation\" is the same thing as \"full public key validation\", except for a missing low-order check on the input point. This check is irrelevant for prime-order curves such as the NIST P- curves.",
          "createdAt": "2020-06-02T20:36:15Z",
          "updatedAt": "2020-06-02T20:36:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODc0NTU0",
          "commit": {
            "abbreviatedOid": "15c027f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This seems like a reasonable change to me. Thanks!",
          "createdAt": "2020-05-19T22:44:18Z",
          "updatedAt": "2020-05-19T22:54:10Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "```suggestion\r\ndef DeriveKeyPair(ikm):\r\n  prk = LabeledExtract(zero(0), \"keypair\", ikm)\r\n  sk = \"invalid\"\r\n  counter = 1\r\n  while sk == \"invalid\":\r\n    label = concat(\"candidate \", encode_big_endian(counter, 1))\r\n    bytes = Expand(prk, label, Nsk)\r\n    bytes[Nsk-1] = bytes[Nsk-1] & bitmask\r\n    sk = Octet-String-to-Field-Element(bytes)\r\n    counter += 1\r\n  return (sk, pk(sk))\r\n```",
              "createdAt": "2020-05-19T22:44:18Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 138,
              "body": "```suggestion\r\nwhere bitmask is defined to be 0xFF for P-256 and P-384, and 0x01 for P-521, and\r\n`Octet-String-to-Field-Element` is as defined in {{SECG}}, Section 2.3.6.\r\n```",
              "createdAt": "2020-05-19T22:45:37Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTY4ODky",
          "commit": {
            "abbreviatedOid": "5c0cfa8"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T18:55:10Z",
          "updatedAt": "2020-06-02T18:55:11Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "The Unmarshal function defined by SECG can return the point at infinity. Worth considering if you want to explicitly disallow that.",
              "createdAt": "2020-06-02T18:55:11Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTc5NTA3",
          "commit": {
            "abbreviatedOid": "5c0cfa8"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T19:09:40Z",
          "updatedAt": "2020-06-02T19:09:40Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "This is what the current spec does, I'm just more explicit about it here.\r\n\r\nThat said, I can share some thoughts.\r\n* The Unmarshal procedure should not really be used for deriving keys, but for reconstructing saved keys from a previous session. If Unmarshal produces a bad key, then that means you somehow generated a bad key in a previous session or the key was tampered with.\r\n* The only way to generate a bad keypair is by giving to DeriveKeypair 0 or p (in the case of X25519), or an HKDF preimage of 0 (in the case of P- curves)\r\n* A point at infinity must be caught at the DH stage anyway\r\n\r\nWould it make sense to add an HKDF step to the X25519 DeriveKeyPair? It would be nice to claim that it's computationally infeasible to derive a bad keypair using DeriveKeyPair",
              "createdAt": "2020-06-02T19:09:40Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTkzMTMz",
          "commit": {
            "abbreviatedOid": "5c0cfa8"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T19:28:29Z",
          "updatedAt": "2020-06-02T19:28:30Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "I'm worried about an adversary sending the point at infinity maliciously. MLS previously disallowed infinity, but now it won't",
              "createdAt": "2020-06-02T19:28:29Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDAyMzUz",
          "commit": {
            "abbreviatedOid": "5c0cfa8"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T19:42:20Z",
          "updatedAt": "2020-06-02T19:42:21Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Are you specifically concerned about an adversary giving the point-at-infinity as a DH pubkey? Doesn't the \"Validation of Inputs and Outputs\" section below the \"DeriveKeyPair\" section cover this?",
              "createdAt": "2020-06-02T19:42:20Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDEwODc2",
          "commit": {
            "abbreviatedOid": "0d46e9c"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T19:54:58Z",
          "updatedAt": "2020-06-02T19:54:59Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Yes. Ah, I didn't see that before! Why is it \"one of the following checks\" and not \"both\"?",
              "createdAt": "2020-06-02T19:54:58Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDIwMzI0",
          "commit": {
            "abbreviatedOid": "0d46e9c"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T20:09:09Z",
          "updatedAt": "2020-06-02T20:09:10Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "The \"full public-key validation on all public key inputs\" includes a point-at-infinity check and a valid-point check. If you're guaranteed that the input point is valid and has prime order (this follows from non-identity because the P- curves are all prime order), then the two checks mentioned are equivalent.",
              "createdAt": "2020-06-02T20:09:09Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDI0ODU2",
          "commit": {
            "abbreviatedOid": "0d46e9c"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T20:15:58Z",
          "updatedAt": "2020-06-02T20:15:58Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "That's not clear to me. Probably worth re-iterating that \"full validation\" means \"coordinates are field elements, point is on curve, and point is not infinity\"",
              "createdAt": "2020-06-02T20:15:58Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDgxNzM3",
          "commit": {
            "abbreviatedOid": "ef0139f"
          },
          "author": "Bren2010",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-02T21:48:54Z",
          "updatedAt": "2020-06-02T21:48:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjg0MjMz",
          "commit": {
            "abbreviatedOid": "2c32a2f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-06-03T15:42:19Z",
          "updatedAt": "2020-06-03T18:02:23Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n  - DeriveKeyPair(ikm): Derive a key pair `(sk, pk)` from the byte string `ikm` of length `Nsk`\r\n```",
              "createdAt": "2020-06-03T15:42:19Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n  - Unmarshal(enc): Parse the byte string `enc` of length `Npk` to recover a\r\n```",
              "createdAt": "2020-06-03T15:42:53Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 110,
              "body": "```suggestion\r\nFor P-256, P-384 and P-521, the Marshal function of the\r\n```",
              "createdAt": "2020-06-03T15:44:04Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 115,
              "body": "```suggestion\r\nFor X25519 and X448, the Marshal and Unmarshal functions\r\n```",
              "createdAt": "2020-06-03T15:44:17Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nFor P-256, P-384 and P-521, the DeriveKeyPair function of the\r\n```",
              "createdAt": "2020-06-03T15:46:10Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 145,
              "body": "```suggestion\r\nFor X25519 and X448, the DeriveKeyPair function performs\r\n```",
              "createdAt": "2020-06-03T15:46:19Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 151,
              "body": "Why do we need to extract from `ikm = random(Nsk)`?",
              "createdAt": "2020-06-03T15:48:02Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 151,
              "body": "Also, this is... interesting. It's not clear to me whether we should clamp the output `sk`, per https://cr.yp.to/ecdh.html, or assume that x25519 implementations handle this for us per RFC7748. ",
              "createdAt": "2020-06-03T15:50:27Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODc3NTQ5",
          "commit": {
            "abbreviatedOid": "2c32a2f"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T19:47:40Z",
          "updatedAt": "2020-06-03T19:47:41Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "will clamp",
              "createdAt": "2020-06-03T19:47:41Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODg1MTc2",
          "commit": {
            "abbreviatedOid": "dd5f4ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T19:59:06Z",
          "updatedAt": "2020-06-03T19:59:06Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Let's leave it as-is for now, and wait to hear what others think? I'm fine to be in the rough here.",
              "createdAt": "2020-06-03T19:59:06Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjM4NTYw",
          "commit": {
            "abbreviatedOid": "dd5f4ae"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T13:31:54Z",
          "updatedAt": "2020-06-08T13:31:55Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "I am comfortable assuming RFC 7748 here, thus not doing clamping.",
              "createdAt": "2020-06-08T13:31:55Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjUxNzQx",
          "commit": {
            "abbreviatedOid": "7c4139c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T13:39:42Z",
          "updatedAt": "2020-06-08T13:49:23Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Where does this value come from?",
              "createdAt": "2020-06-08T13:39:42Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 151,
              "body": "We need `LabeledExtract` because `ikm` isn't guaranteed to be `random(Nsk)`.  For example, it might be some input from MLS.",
              "createdAt": "2020-06-08T13:41:10Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 160,
              "body": "Why is the `_keypair` necessary?  Suggest just using `desc`.",
              "createdAt": "2020-06-08T13:42:48Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            },
            {
              "originalPosition": 142,
              "body": "It seems like it would be clearer to use `sk == 0` instead of `sk < 1`, since `sk` is unsigned.",
              "createdAt": "2020-06-08T13:49:18Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjcyMzg3",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:00:29Z",
          "updatedAt": "2020-06-08T14:00:29Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "This is because the scalar size for P-521 is 521 bits, or 65 bytes plus 1 bit. In order to get a scalar in this range, we have to generate 66 bytes and clear the top 7 bits. Otherwise the rejection sampling will fail each iteration with probability 254/256.",
              "createdAt": "2020-06-08T14:00:29Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjgyODcx",
          "commit": {
            "abbreviatedOid": "aadb2d6"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:11:30Z",
          "updatedAt": "2020-06-08T14:11:30Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I changed this to fixed strings for each curve family. Thoughts?",
              "createdAt": "2020-06-08T14:11:30Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjgzNzUx",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:12:23Z",
          "updatedAt": "2020-06-08T14:12:23Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "Yeah, I forgot we meant to export this function for MLS. I'm fine with extract as is then.",
              "createdAt": "2020-06-08T14:12:23Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mjg2NTYy",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:15:20Z",
          "updatedAt": "2020-06-08T14:15:20Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Does this mean that `ikm` has at least `Nsk` bytes of entropy? (That would seem to contradict the need for extract, I think.)",
              "createdAt": "2020-06-08T14:15:20Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mjg3ODY3",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:16:38Z",
          "updatedAt": "2020-06-08T14:16:39Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Can we use the curve name instead of \"nistp\"?",
              "createdAt": "2020-06-08T14:16:39Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mjg4MTU4",
          "commit": {
            "abbreviatedOid": "90e8aaa"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T14:16:57Z",
          "updatedAt": "2020-06-08T14:16:57Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Same comment here: can we use the group name?",
              "createdAt": "2020-06-08T14:16:57Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Mzk5Njky",
          "commit": {
            "abbreviatedOid": "972da1e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-08T16:14:32Z",
          "updatedAt": "2020-06-08T16:14:32Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "(Chatted offline, to resolve with a slight tweak of text)",
              "createdAt": "2020-06-08T16:14:32Z",
              "updatedAt": "2020-06-08T16:21:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDEwODc5",
          "commit": {
            "abbreviatedOid": "b3f9bd7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-08T16:28:10Z",
          "updatedAt": "2020-06-08T16:28:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4Mjk5NzY4",
          "commit": {
            "abbreviatedOid": "b3f9bd7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-10T17:57:31Z",
          "updatedAt": "2020-06-10T17:57:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMTM4MDAx",
      "title": "Clarify between KEM and DH shared secret",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/80",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Quick draft of a pull request to make the distinction between DH shared secret and KEM shared secret clearer.",
      "createdAt": "2020-05-19T14:00:06Z",
      "updatedAt": "2020-05-19T14:59:45Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a9e89a2fa93faf4618590077b517857c06192ea0",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_shared_secrets",
      "headRefOid": "afe715d9627e073a0eddd9bd490d45809fe8f6d0",
      "closedAt": "2020-05-19T14:59:45Z",
      "mergedAt": "2020-05-19T14:59:45Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "46c36e13e85bcb4c8a5233c434778c6bd0bb97f4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NTM3NjQw",
          "commit": {
            "abbreviatedOid": "afe715d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T14:59:40Z",
          "updatedAt": "2020-05-19T14:59:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjA2MzUz",
      "title": "Replace `zero(Nh)` with `zero(0)` in ExtractAndExpand",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/81",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #76 and #77.\r\n\r\nFor future reference, here's the test vector formatting script: https://gist.github.com/chris-wood/26b2ad73ef934cf74f2709cd29555ce1\r\n\r\ncc @rozbb",
      "createdAt": "2020-05-19T15:47:23Z",
      "updatedAt": "2020-05-20T15:08:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "325c94f111732d8fdab54caac26ceee364de8a69",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/zero-salt-extract-and-expand",
      "headRefOid": "25374abc1dc3cf845bfd68d8badd167b70d86a2e",
      "closedAt": "2020-05-20T15:08:03Z",
      "mergedAt": "2020-05-20T15:08:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "bf2725770014b7cd242925635dbf602715fce966"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1Mzk1MzUx",
          "commit": {
            "abbreviatedOid": "04c58d2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-20T14:28:16Z",
          "updatedAt": "2020-05-20T14:28:47Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "\"empty **byte** string\"",
              "createdAt": "2020-05-20T14:28:16Z",
              "updatedAt": "2020-05-20T15:06:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NDM1MzA1",
          "commit": {
            "abbreviatedOid": "04c58d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-20T15:06:47Z",
          "updatedAt": "2020-05-20T15:06:47Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n  0x00000000` and `zero(0)` is the empty byte string.\r\n```",
              "createdAt": "2020-05-20T15:06:47Z",
              "updatedAt": "2020-05-20T15:06:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMjEyODk5",
      "title": "Simplify the KeySchedule signature by removing pkSm.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/82",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is not used in the context construction. It only signals that `mode`\r\nis one of the authenticated flavors. Removing it allows us to simplify\r\nthe VerifyMode function, too, as it only exists to ensure PSK parameters\r\nare consistent.\r\n\r\nCloses #71.",
      "createdAt": "2020-05-19T15:58:33Z",
      "updatedAt": "2020-05-20T14:29:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "325c94f111732d8fdab54caac26ceee364de8a69",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/simplify-keyschedule-signature",
      "headRefOid": "ea32940586c45a3227b83ca18663975b64a6df63",
      "closedAt": "2020-05-20T14:29:13Z",
      "mergedAt": "2020-05-20T14:29:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8af08a0ab00af8a55024263afc99749bed1e7c44"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1Mzk2MTg5",
          "commit": {
            "abbreviatedOid": "ea32940"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-20T14:29:06Z",
          "updatedAt": "2020-05-20T14:29:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwOTM3MDA2",
      "title": "Removed remaining instances of LabeledExtract(zero(Nh), ...)",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/99",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "By the same reasoning as https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/81, we shouldn't use `zero(Nh)` as a salt for `LabeledExtract`.",
      "createdAt": "2020-05-20T18:16:22Z",
      "updatedAt": "2020-05-22T01:21:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "bf2725770014b7cd242925635dbf602715fce966",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "zero-Nh",
      "headRefOid": "1e7c22a9c8fdec7dcbea78fc93fc3145e8a260aa",
      "closedAt": "2020-05-22T01:21:12Z",
      "mergedAt": "2020-05-22T01:21:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9a2c364839fa08c8eb8b3f714f5459c249f828ce"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 101,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIyMzQ0NzUw",
      "title": "Address most of the nits from Verisign's review.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/101",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #100, #97, #95, #93, #92, #91, #90, #89, #88, #87, #86, and #55. \r\n\r\nEdit: Updated to include #94 and #72.\r\n\r\nI'll update the test vectors (and their labels) in a separate change that aligns with a change in the cisco/go-hpke codebase. \r\n\r\ncc @blipp, @rozbb, @davidben for visibility",
      "createdAt": "2020-05-24T00:26:58Z",
      "updatedAt": "2020-05-28T17:26:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "9a2c364839fa08c8eb8b3f714f5459c249f828ce",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/verisign-nits",
      "headRefOid": "9d37303df9430d54867637168f0540c6c23a8eea",
      "closedAt": "2020-05-27T21:40:35Z",
      "mergedAt": "2020-05-27T21:40:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "881c5b6e49bf33e287b7f28f5da8b07180346e0f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb, @kjacobs-moz, @raphaelrobert: could you please check these test vectors? ",
          "createdAt": "2020-05-26T21:53:08Z",
          "updatedAt": "2020-05-26T21:53:08Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yup, passes for me.\r\n\r\nOne note: there a field in the JSON called `key_schedule_context`, and it's the only snakecase field",
          "createdAt": "2020-05-26T22:25:32Z",
          "updatedAt": "2020-05-26T22:26:18Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "NONE",
          "body": "I've updated my implementation and the Curve25519 vectors pass, but not P-curves (using base mode values from the draft). These fail as early as the computation of `zz`. \r\n\r\nI'm not sure if @rozbb's implementation supports P-curves yet... I assume this is a bug in my code, but will need to pick debugging back up tomorrow. ",
          "createdAt": "2020-05-27T01:38:52Z",
          "updatedAt": "2020-05-27T01:38:52Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can confirm that P-256 an X25519 both worked for me",
          "createdAt": "2020-05-27T01:45:09Z",
          "updatedAt": "2020-05-27T01:45:09Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "NONE",
          "body": "> I can confirm that P-256 an X25519 both worked for me\r\n\r\nThe issue was on my end, due to using the old (pre- 0cbca7cb11f37d433493b9f17905f351084a821e) shared secret representation.\r\n\r\nThe vectors seem to be correct \ud83d\udc4d.\r\n\r\n",
          "createdAt": "2020-05-27T04:23:24Z",
          "updatedAt": "2020-05-27T04:23:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzIwNjk2",
          "commit": {
            "abbreviatedOid": "055226d"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-24T01:42:59Z",
          "updatedAt": "2020-05-24T01:47:55Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "Isn't HPKE supposed to be more general than this? SIKE should be included as a possible KEM, for example.",
              "createdAt": "2020-05-24T01:42:59Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzIwODY5",
          "commit": {
            "abbreviatedOid": "055226d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-24T01:49:15Z",
          "updatedAt": "2020-05-24T01:49:15Z",
          "comments": [
            {
              "originalPosition": 197,
              "body": "It is, but this sentence pertains to what\u2019s currently specified (with a code point) in the document. ",
              "createdAt": "2020-05-24T01:49:15Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3Nzk0OTg4",
          "commit": {
            "abbreviatedOid": "055226d"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-25T16:05:19Z",
          "updatedAt": "2020-05-25T16:05:20Z",
          "comments": [
            {
              "originalPosition": 404,
              "body": "```Note that the internal Seal and Open calls inside corresponding to the context's AEAD algorithm.```\r\ncorresponding -> correspond ?",
              "createdAt": "2020-05-25T16:05:20Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3ODI5NzA3",
          "commit": {
            "abbreviatedOid": "055226d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-25T17:57:25Z",
          "updatedAt": "2020-05-25T17:57:25Z",
          "comments": [
            {
              "originalPosition": 403,
              "body": "```suggestion\r\nthe internal Seal and Open calls inside correspond to the context's AEAD\r\n```",
              "createdAt": "2020-05-25T17:57:25Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5Mzk4NTgz",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T16:24:48Z",
          "updatedAt": "2020-05-27T18:45:20Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "\"using ... based on ...\" seems redundant.  Reword to something like \"... primitives, such as ECDH, HKDF, and SHA2.\"  ",
              "createdAt": "2020-05-27T16:24:48Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 233,
              "body": "\"contained herein\" -> \"defined here\"",
              "createdAt": "2020-05-27T16:26:49Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 233,
              "body": "Also, why drop \"formally verified\"?  Since we did that.",
              "createdAt": "2020-05-27T16:27:14Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 264,
              "body": "I really don't care strongly about this, but it seems like in RFC 7748, `X*` is the group, and `Curve*` is the ECDH operation (largely just specifying the base point).  Since we're doing ECDH here, `Curve*` seems like the right answer.",
              "createdAt": "2020-05-27T18:33:29Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 446,
              "body": "This doesn't make sense.  The curve is a group. ",
              "createdAt": "2020-05-27T18:42:17Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 466,
              "body": "Same comment re group == curve.",
              "createdAt": "2020-05-27T18:43:00Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            },
            {
              "originalPosition": 477,
              "body": "Same comment, `X*` are the groups.",
              "createdAt": "2020-05-27T18:44:53Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTI5MzUx",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "davidben",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T19:08:18Z",
          "updatedAt": "2020-05-27T19:08:18Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "I think you've got it backwards, though both specify a base point. X* is a function from bytes to bytes, with group operations and serialization built in. curve* is a curve with base point.\r\n\r\nhttps://tools.ietf.org/html/rfc7748#section-4.1\r\n>   For the ~128-bit security level, the prime 2^255 - 19 is recommended\r\n>   for performance on a wide range of architectures.  Few primes of the\r\n>   form 2^c-s with s small exist between 2^250 and 2^521, and other\r\n>   choices of coefficient are not as competitive in performance.  This\r\n>   prime is congruent to 1 mod 4, and the derivation procedure in\r\n>   Appendix A results in the following Montgomery curve\r\n>   v^2 = u^3 + A*u^2 + u, called \"curve25519\":\r\n\r\nhttps://tools.ietf.org/html/rfc7748#section-5\r\n>   The \"X25519\" and \"X448\" functions perform scalar multiplication on\r\n>   the Montgomery form of the above curves.  (This is used when\r\n>   implementing Diffie-Hellman.)  The functions take a scalar and a\r\n>   u-coordinate as inputs and produce a u-coordinate as output.\r\n>   Although the functions work internally with integers, the inputs and\r\n>   outputs are 32-byte strings (for X25519) or 56-byte strings (for\r\n>   X448) and this specification defines their encoding.",
              "createdAt": "2020-05-27T19:08:18Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTMwNjI3",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "davidben",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T19:09:45Z",
          "updatedAt": "2020-05-27T19:09:46Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Also https://mailarchive.ietf.org/arch/msg/cfrg/-9LEdnzVrE5RORux3Oo_oDDRksU/",
              "createdAt": "2020-05-27T19:09:45Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTMxMDU1",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T19:10:22Z",
          "updatedAt": "2020-05-27T19:10:22Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Yeah, I think using x25519 is also more clear since there are small subgroups of curve25519.",
              "createdAt": "2020-05-27T19:10:22Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjA2Mjk5",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:03:04Z",
          "updatedAt": "2020-05-27T21:03:04Z",
          "comments": [
            {
              "originalPosition": 233,
              "body": "The \"formally verified\" bit was redundant with the remainder of the paragraph, which states that we did the analysis.",
              "createdAt": "2020-05-27T21:03:04Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjA2OTA5",
          "commit": {
            "abbreviatedOid": "9000051"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:03:59Z",
          "updatedAt": "2020-05-27T21:03:59Z",
          "comments": [
            {
              "originalPosition": 446,
              "body": "This is just for consistency with the X25519/curve25519 notation. I think this is more clear, and lets us speak in terms of DH groups rather than specific curves.",
              "createdAt": "2020-05-27T21:03:59Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjA3NDA0",
          "commit": {
            "abbreviatedOid": "79fff5f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:04:44Z",
          "updatedAt": "2020-05-27T21:04:44Z",
          "comments": [
            {
              "originalPosition": 466,
              "body": "Same as above!",
              "createdAt": "2020-05-27T21:04:44Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjEwMzQy",
          "commit": {
            "abbreviatedOid": "79fff5f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:09:16Z",
          "updatedAt": "2020-05-27T21:09:16Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "You guys are correct.  I was looking at the subheadings of Section 6 (ECDH), when I should have been looking at Section 4.  Comment resolved.",
              "createdAt": "2020-05-27T21:09:16Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjExNDEz",
          "commit": {
            "abbreviatedOid": "79fff5f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:10:55Z",
          "updatedAt": "2020-05-27T21:10:55Z",
          "comments": [
            {
              "originalPosition": 446,
              "body": "I don't think we need to distinguish between the curve group and the subgroup here.  It's not ambiguous.",
              "createdAt": "2020-05-27T21:10:55Z",
              "updatedAt": "2020-05-27T21:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjE1MDEy",
          "commit": {
            "abbreviatedOid": "9d37303"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-27T21:16:54Z",
          "updatedAt": "2020-05-27T21:16:55Z",
          "comments": [
            {
              "originalPosition": 446,
              "body": "Resolved with less text!",
              "createdAt": "2020-05-27T21:16:54Z",
              "updatedAt": "2020-05-27T21:16:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjE1MTM4",
          "commit": {
            "abbreviatedOid": "79fff5f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-27T21:17:06Z",
          "updatedAt": "2020-05-27T21:17:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzM1MjA4",
          "commit": {
            "abbreviatedOid": "9d37303"
          },
          "author": "davidben",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-28T17:26:34Z",
          "updatedAt": "2020-05-28T17:26:35Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "Hah. Those subheadings should probably have been X*. Ah well. :-)",
              "createdAt": "2020-05-28T17:26:34Z",
              "updatedAt": "2020-05-28T17:26:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 112,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NTAxNzU2",
      "title": "Address partial feedback raised during RGLC.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/112",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #111, #110, #109, #108, #107, #106, #105, #104, #103, and #102. \r\n\r\ncc @blipp, @kwantam, @dvorak42, @rozbb",
      "createdAt": "2020-06-16T22:33:01Z",
      "updatedAt": "2020-06-18T20:53:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0aea45455c89692fa569f8a27594d17498f4de40",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/rglc-feedback",
      "headRefOid": "10e21344b8de9303f1fa256b6f6b469d5a6e6bfe",
      "closedAt": "2020-06-18T20:53:36Z",
      "mergedAt": "2020-06-18T20:53:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b3cecc3de4419392979ea3217a2137d09694d618"
      },
      "comments": [
        {
          "author": "kwantam",
          "authorAssociation": "NONE",
          "body": ":+1: edits look great!",
          "createdAt": "2020-06-16T22:42:13Z",
          "updatedAt": "2020-06-16T22:42:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think the first point of #113 is not yet addressed. I commented over there https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/103#issuecomment-645650291.\n\nYeah, I\u2019ll deal with the KEM errors in a separate PR.\n\n> From #107, I think the first point \u201creference or citation for unknown key share attacks\u201d is not yet addressed. I don't know which reference would be best to add out of my head. Also, should the terminology \u201cunknown key-share attack\u201d or \u201cidentity mis-binding issue\u201d be used? I like the latter more.\n\nI opted to not include one since I couldn\u2019t find one either :-) I\u2019ll do another scan to see if I can come up with one.\n\n",
          "createdAt": "2020-06-17T22:41:19Z",
          "updatedAt": "2020-06-17T22:41:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation please have a look. (Also, @beurdouche, please have a look at the input limits!)",
          "createdAt": "2020-06-17T23:59:45Z",
          "updatedAt": "2020-06-17T23:59:45Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should the `exporter_context` in Secret Export also be limited to 65535 bytes, as done with `psk`, `pskID`, `info`?\r\n\r\nAlso, should it be noted that `L` in Secret Export is limited to `255*Nh` bytes, for the KDFs specified?",
          "createdAt": "2020-06-18T12:20:55Z",
          "updatedAt": "2020-06-18T12:20:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Should the `exporter_context` in Secret Export also be limited to 65535 bytes, as done with `psk`, `pskID`, `info`?\r\n\r\nThat\u2019s already done :-)\r\n\r\n> Also, should it be noted that `L` in Secret Export is limited to `255*Nh` bytes, for the KDFs specified?\r\n\r\nHmm, probably?\r\n\r\n",
          "createdAt": "2020-06-18T12:24:10Z",
          "updatedAt": "2020-06-18T12:24:10Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That\u2019s already done :-)\r\n\r\nAh, sorry, missed that. Great!\r\n\r\n> > Also, should it be noted that `L` in Secret Export is limited to `255*Nh` bytes, for the KDFs specified?\r\n> \r\n> Hmm, probably?\r\n\r\nLet's! Something like: \u201cThe maximum value for the `L` parameter is `255*Nh` for the KDFs defined in this document.\u201d\r\n\r\nEdited to add: That limit on L is due to the [HKDF standard](https://tools.ietf.org/html/rfc5869).",
          "createdAt": "2020-06-18T12:28:39Z",
          "updatedAt": "2020-06-18T12:32:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzY0Njcw",
          "commit": {
            "abbreviatedOid": "6965539"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think the first point of #113 is not yet addressed. I commented over there https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/103#issuecomment-645650291.\r\n\r\nFrom #107, I think the first point \u201creference or citation for unknown key share attacks\u201d is not yet addressed. I don't know which reference would be best to add out of my head. Also, should the terminology \u201cunknown key-share attack\u201d or \u201cidentity mis-binding issue\u201d be used? I like the latter more.",
          "createdAt": "2020-06-17T20:48:22Z",
          "updatedAt": "2020-06-17T22:24:10Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "`Seal` above says \u201cciphertext and tag `ct`\u201d, should this be used here, too? Just adding \u201cand tag\u201d might make the formulation weird, because the tag is not \u201cdecrypted\u201d.",
              "createdAt": "2020-06-17T20:48:22Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 109,
              "body": "Sometimes variables like Npk are wrapped in back ticks, sometimes not. It could be nice to make this consistent at some point (not necessarily in this PR, just noticed it in this moment).",
              "createdAt": "2020-06-17T20:51:56Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 114,
              "body": "In the general KEM definition above, it is not mentioned that Deserialize can fail. Should that be added there?",
              "createdAt": "2020-06-17T20:54:34Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 189,
              "body": "Replace \u201cGroup Name\u201d by \u201cGROUP\u201d, or \u201cGroup Name (GROUP)\u201d?",
              "createdAt": "2020-06-17T20:57:13Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 218,
              "body": "```suggestion\r\n  and the recipient (optional; default value `zero(0)`) of maximum\r\n```\r\nUh, I did not see this occurrence when I submitted #116. Would you mind adding this change with this PR, for the sake of fewer merge conflicts?",
              "createdAt": "2020-06-17T21:04:27Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 223,
              "body": "```suggestion\r\n```\r\n`pkSm` is no longer an input to KeySchedule.",
              "createdAt": "2020-06-17T21:07:11Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 255,
              "body": "Using `raise` instead of `return` when an error occurs could indeed be a good idea (as Richard mentioned it off-channel). I just realized we actually already have `raise` in `VerifyPSKInputs`!",
              "createdAt": "2020-06-17T21:15:53Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 347,
              "body": "Thanks for mentioning me so prominently :)",
              "createdAt": "2020-06-17T21:19:19Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 254,
              "body": "Suggestion, to make it clearer about which Seal and Open this is, and maybe failing with an error is more explicitly saying that no other value can be returned (like, not an error *and* the ciphertext): \u201cIf `Context.Seal` or `Context.Open` would cause the `seq` field to overflow, then the implementation MUST fail with an error.\u201d",
              "createdAt": "2020-06-17T22:22:41Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODM5MDg0",
          "commit": {
            "abbreviatedOid": "8ec9983"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Good! Only comment is on the `GROUP-` prefix. It's not a huge PITA but if it's not necessary I'd rather omit it.",
          "createdAt": "2020-06-17T23:17:30Z",
          "updatedAt": "2020-06-17T23:33:40Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "How necessary is the `GROUP` prefix? This complicates things a non-trivial but acceptable amount in implementation, since I'm trying to avoid allocation entirely.",
              "createdAt": "2020-06-17T23:17:30Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 221,
              "body": "I actually don't need a length limit on HKDF `info` inputs anymore in order to avoid allocation. Your call if you want to keep it or not.",
              "createdAt": "2020-06-17T23:27:30Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 225,
              "body": "Also don't need this limit anymore.",
              "createdAt": "2020-06-17T23:28:06Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 227,
              "body": "Ditto",
              "createdAt": "2020-06-17T23:28:14Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ4MDgw",
          "commit": {
            "abbreviatedOid": "844b3bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:43:30Z",
          "updatedAt": "2020-06-17T23:43:30Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "For consistency, yeah, it should. Good catch!",
              "createdAt": "2020-06-17T23:43:30Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ4MTcw",
          "commit": {
            "abbreviatedOid": "844b3bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:43:45Z",
          "updatedAt": "2020-06-17T23:43:46Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "Yep, good catch. I'll fix these and do a quick scan for others.",
              "createdAt": "2020-06-17T23:43:46Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ4MjIy",
          "commit": {
            "abbreviatedOid": "844b3bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:43:56Z",
          "updatedAt": "2020-06-17T23:43:56Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "Yep -- I'll add it.",
              "createdAt": "2020-06-17T23:43:56Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ5MzY0",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:47:16Z",
          "updatedAt": "2020-06-17T23:47:17Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "I inherited this from length restrictions on the TLS Exporter API.",
              "createdAt": "2020-06-17T23:47:17Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODQ5NDUy",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:47:34Z",
          "updatedAt": "2020-06-17T23:47:34Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "This one I pulled out of thin air. I can make it larger to match. :)",
              "createdAt": "2020-06-17T23:47:34Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODUwMDkx",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:49:43Z",
          "updatedAt": "2020-06-17T23:49:44Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Calling @kwantam! My take is that this is just good hygiene. Without the prefix, it's harder to reason about separation of these different ROs. ",
              "createdAt": "2020-06-17T23:49:43Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODUwMTY0",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:49:56Z",
          "updatedAt": "2020-06-17T23:49:57Z",
          "comments": [
            {
              "originalPosition": 254,
              "body": "That works for me -- I'll add it. Thanks!",
              "createdAt": "2020-06-17T23:49:56Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODUwOTIy",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:52:18Z",
          "updatedAt": "2020-06-17T23:52:19Z",
          "comments": [
            {
              "originalPosition": 255,
              "body": "Agreed. It's also a nice way to keep the return types clean. Namely, in the Seal/Open calls, we return two possible types: errors or plaintext/ciphertext. If we use `raise`, then we only return one possible type (plaintext or ciphertext). ",
              "createdAt": "2020-06-17T23:52:19Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODUwOTg4",
          "commit": {
            "abbreviatedOid": "8758596"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-17T23:52:29Z",
          "updatedAt": "2020-06-17T23:52:29Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "I went with the former -- thanks!",
              "createdAt": "2020-06-17T23:52:29Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODU1Njkw",
          "commit": {
            "abbreviatedOid": "5319e53"
          },
          "author": "kwantam",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T00:06:39Z",
          "updatedAt": "2020-06-18T00:06:40Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "As @chris-wood says, it makes it easier to reasonable about random oracle separation. It may be overkill (I think in my original comment I said something like \"this is probably paranoia, but...\").\r\n\r\nThe kind of thing one might worry about without `GROUP` is a case where it's possible to confuse serialized elements of two different groups. In this case it *could* be possible to construct two exchanges with identical `kemContext` inputs. (Not clear that's enough to construct an attack, but we can completely rule out attacks of this kind by including `GROUP`.)",
              "createdAt": "2020-06-18T00:06:39Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTU4ODI4",
          "commit": {
            "abbreviatedOid": "81904d4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T10:41:36Z",
          "updatedAt": "2020-06-18T10:41:37Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I agree with @chris-wood and @kwantam that binding `zz` explicitly to the underlying DH is important.\r\n\r\nWould it be easier for you to implement it avoiding allocation, @rozbb, if it was in the style of the context in KeySchedule? There, we include `kem_id`, `kdf_id`, `aead_id`, all as 2-byte fixed-sized values. Instead of doing \"GROUP-dh\", we could do:\r\n\r\n```\r\n  prk = LabeledExtract(zero(0), concat(I2OSP(kem_id, 2), \"dh\"), dh)\r\n  return LabeledExpand(prk, concat(I2OSP(kem_id, 2), \"prk\"), kemContext, Nzz)\r\n```\r\n\r\nThe `kem_id` already is unique per DHKEM, and also, it would avoid needing a separate table for the values of GROUP, because the table in the \u201cAlgorithm Identifiers\u201d Section already has the `kem_id`s.",
              "createdAt": "2020-06-18T10:41:36Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTY0NTkw",
          "commit": {
            "abbreviatedOid": "81904d4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T10:50:11Z",
          "updatedAt": "2020-06-18T10:50:12Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Ok, actually, I suggest the following for Encap and Decap:\r\n\r\n```\r\n  kemContext = concat(I2OSP(kem_id, 2), enc, pkRm)\r\n```\r\n\r\nand this for AuthEncap and AuthDecap:\r\n\r\n```\r\n  kemContext = concat(I2OSP(kem_id, 2), enc, pkRm, pkSm)\r\n```\r\n\r\nThen it is exactly in the same style as in KeySchedule. The added label `kem_id` always has two bytes. I think the LabeledExtract call in ExtractAndExpand does not need to have `kem_id` as a label, because the intermediary value `dh` is never exposed. The important thing is that `zz` is explicitly bound to the scheme's name, and for that it is enough to have it in `kemContext`. (I think we had a similar reasoning when we decided what to include where in KeySchedule's context)",
              "createdAt": "2020-06-18T10:50:12Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTg5OTAw",
          "commit": {
            "abbreviatedOid": "81904d4"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T11:28:45Z",
          "updatedAt": "2020-06-18T11:28:46Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "On the other hand, binding to the GROUP plays a similar role as the RFCXXX label which we do include in *both* LabeledExtract *and* LabeledExpand, even if the LabeledExtract results are never exposed. And this is about, as @kwantam said in #108, that the calls are orthogonal, which makes it easier to reason with separate random oracles for separate ciphersuites (and DHKEM is kind of a sub-standard inside this RFC, so it makes sense to have RFCXXXX *and* the DHKEM group as a label).\r\n\r\nSo I have a tendency for including `kem_id` in both, as I suggested in my first reply in this thread.\r\n\r\nWhat do you think?",
              "createdAt": "2020-06-18T11:28:45Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMjI5ODc1",
          "commit": {
            "abbreviatedOid": "81904d4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T12:26:49Z",
          "updatedAt": "2020-06-18T12:26:50Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "I like it! This has the same effect and is less text. Stand by for that change.",
              "createdAt": "2020-06-18T12:26:50Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMjQyMzIy",
          "commit": {
            "abbreviatedOid": "bc03f5a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T12:42:26Z",
          "updatedAt": "2020-06-18T12:42:26Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "@blipp fixed -- please have a look.",
              "createdAt": "2020-06-18T12:42:26Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMjg3MjEx",
          "commit": {
            "abbreviatedOid": "27e0cbc"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-06-18T13:33:35Z",
          "updatedAt": "2020-06-18T13:35:14Z",
          "comments": [
            {
              "originalPosition": 284,
              "body": "```suggestion\r\n(In the pseudocode below, `Context.IncrementSeq` fails with an error when `seq` overflows,\r\n```",
              "createdAt": "2020-06-18T13:33:35Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 317,
              "body": "```suggestion\r\nfunction. For the KDFs defined in this specification, `L` has a maximum value of\r\n`255*Nh`. Future specifications which define new KDFs MUST specify a bound for `L`.\r\n```",
              "createdAt": "2020-06-18T13:34:33Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMzkzMjQ1",
          "commit": {
            "abbreviatedOid": "6b89d8a"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T15:21:21Z",
          "updatedAt": "2020-06-18T15:21:22Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Yes, this is much cleaner! In fact, DeriveKeyPair should be using `kem_id` as well, instead of the `desc` string. I'll make the PR after this lands.",
              "createdAt": "2020-06-18T15:21:21Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjEzMTU2",
          "commit": {
            "abbreviatedOid": "b2186d2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of editorial things, otherwise lgtm",
          "createdAt": "2020-06-18T20:12:37Z",
          "updatedAt": "2020-06-18T20:19:36Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "I would drop this first clause, \"As is standard with AEAD interfaces\"",
              "createdAt": "2020-06-18T20:12:38Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 264,
              "body": "Disagree with collapsing all of these bullets.  If you want to group them, you could have top-level \"AEAD parameters\" and \"Export parameters\"",
              "createdAt": "2020-06-18T20:14:23Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            },
            {
              "originalPosition": 387,
              "body": "I would rephrase as: \"For X25519 and X448, public keys and DH outputs MUST be validated as described in {{RFC7748}}.  In particular, recipients MUST check whether the DH shared secret is the all-zero value and abort if so.\"",
              "createdAt": "2020-06-18T20:19:00Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjMyNTI5",
          "commit": {
            "abbreviatedOid": "b2186d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T20:43:19Z",
          "updatedAt": "2020-06-18T20:43:19Z",
          "comments": [
            {
              "originalPosition": 208,
              "body": "\ud83d\udc4d \r\n",
              "createdAt": "2020-06-18T20:43:19Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjMzMjY0",
          "commit": {
            "abbreviatedOid": "b2186d2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T20:44:31Z",
          "updatedAt": "2020-06-18T20:44:31Z",
          "comments": [
            {
              "originalPosition": 387,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-06-18T20:44:31Z",
              "updatedAt": "2020-06-18T20:49:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjM5MDA3",
          "commit": {
            "abbreviatedOid": "10e2134"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T20:53:28Z",
          "updatedAt": "2020-06-18T20:53:28Z",
          "comments": [
            {
              "originalPosition": 264,
              "body": "It felt cleaner, but I don't feel strongly about this. I made a slight variation that's closer to what we had.",
              "createdAt": "2020-06-18T20:53:28Z",
              "updatedAt": "2020-06-18T20:53:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2MDc3MDgy",
      "title": "Change default_psk to be the empty byte string, Remove unused default_pkSm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/116",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes the default_psk to be the empty string, i.e. zero(0), instead of zero(Nh).\r\n\r\nThis makes implementations easier, because then, in PSK and AuthPSK mode, to check that the psk provided is not equal to the default_psk, it will be enough to check that the psk is strictly longer than 0 bytes, instead of comparing Nh bytes.\r\n\r\nTODO: change VerifyPSKInputs to check the length, instead of using `!=`?",
      "createdAt": "2020-06-17T20:25:52Z",
      "updatedAt": "2020-06-17T20:28:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "10c447eb233e7ec057905af544c100288ddca7ea",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_default_psk",
      "headRefOid": "8432568363f1f2ca83b8c921748758e1295d6a16",
      "closedAt": "2020-06-17T20:28:34Z",
      "mergedAt": "2020-06-17T20:28:34Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0aea45455c89692fa569f8a27594d17498f4de40"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNzQ5NTU4",
          "commit": {
            "abbreviatedOid": "8432568"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-17T20:28:30Z",
          "updatedAt": "2020-06-17T20:28:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 117,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2NzI4OTY5",
      "title": "Add section on input limits for psk, pskID, info, exporter_context",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/117",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This adds concrete upper inclusive bounds for psk, pskID, info, and exporter_context that depend on the hash functions maximum input sizes and the constant labels we use in HPKE.\r\n\r\nComputations are documented in https://gist.github.com/blipp/9c748499b6216e9cdca75d24c5297657.\r\n\r\nThe F* spec confirms that these bounds go along with the limits of the KDFs and underlying hash functions, see [here](https://github.com/project-everest/hacl-star/blob/e645526214a9bb4133f6f46521271e8fda5c2d99/specs/Spec.Agile.HPKE.fsti#L264) and [here](https://github.com/project-everest/hacl-star/blob/e645526214a9bb4133f6f46521271e8fda5c2d99/specs/Spec.Agile.HPKE.fsti#L300).",
      "createdAt": "2020-06-18T19:49:18Z",
      "updatedAt": "2020-06-19T14:50:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0aea45455c89692fa569f8a27594d17498f4de40",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "input_limits",
      "headRefOid": "18178f1913c5e09689fdf2db13d722a7c2513457",
      "closedAt": "2020-06-19T14:50:01Z",
      "mergedAt": "2020-06-19T14:50:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "98087a20c9e1338078fc6c4970f88daf1f5b9062"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you think future specifications which specify new KDFs `MUST` or `SHOULD` indicate their bounds for variable-length inputs?",
          "createdAt": "2020-06-19T10:06:28Z",
          "updatedAt": "2020-06-19T10:06:28Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Do you think future specifications which specify new KDFs MUST or SHOULD indicate their bounds for variable-length inputs?\r\n\r\nI think `MUST`. :-)",
          "createdAt": "2020-06-19T14:48:24Z",
          "updatedAt": "2020-06-19T14:48:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjA1ODcy",
          "commit": {
            "abbreviatedOid": "9b9edf1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with some edits -- thanks!",
          "createdAt": "2020-06-18T20:01:15Z",
          "updatedAt": "2020-06-18T20:21:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nprecise limits on these lengths.\r\n```",
              "createdAt": "2020-06-18T20:01:15Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nused together with them. See {{kdf-input-length}} for exact limits on this length.\r\n```",
              "createdAt": "2020-06-18T20:01:34Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nis available for the inputs `psk`, `pskID`, `info`, `exporter_context`,\r\nthe variable-length parameters provided by HPKE applications.\r\nThe following table lists the maximum allowed lengths of these fields\r\n```",
              "createdAt": "2020-06-18T20:02:39Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n`LabeledExtract` were computed with the following expression:\r\n```",
              "createdAt": "2020-06-18T20:03:35Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\n~~~\r\nmax_size_hash_input - Nb - size_label_rfcXXXX - size_input_label\r\n~~~\r\n\r\nThe value for `exporter_context` which is an input to `LabeledExpand`\r\nwas computed with the following expression:\r\n```",
              "createdAt": "2020-06-18T20:20:56Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nmax_size_hash_input - Nb - Nh - size_label_rfcXXXX - size_input_label - 2 - 1\r\n```",
              "createdAt": "2020-06-18T20:21:11Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nof \"RFCXXXX \" in bytes and equals 8, and `size_input_label` is the size of\r\n```",
              "createdAt": "2020-06-18T20:21:41Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjU3NDE4",
          "commit": {
            "abbreviatedOid": "9b9edf1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T21:23:34Z",
          "updatedAt": "2020-06-18T21:27:30Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "While I guess it's worth knowing that these limits exist, they seem ... unlikely to ever be hit in reality.",
              "createdAt": "2020-06-18T21:23:35Z",
              "updatedAt": "2020-06-19T10:05:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzOTU2NDQ5",
          "commit": {
            "abbreviatedOid": "18178f1"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-19T10:05:43Z",
          "updatedAt": "2020-06-19T10:05:44Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "That's right. I added a couple of words to put it into perspective.",
              "createdAt": "2020-06-19T10:05:43Z",
              "updatedAt": "2020-06-19T10:05:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTM3NjE0",
          "commit": {
            "abbreviatedOid": "18178f1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-19T14:49:56Z",
          "updatedAt": "2020-06-19T14:49:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 118,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM2NzYxMzYy",
      "title": "Replace \"desc\" with I2OSP(kem_id, 2).",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/118",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @rozbb ",
      "createdAt": "2020-06-18T21:02:38Z",
      "updatedAt": "2020-06-18T21:30:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "b3cecc3de4419392979ea3217a2137d09694d618",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/derive-key-pair-desc",
      "headRefOid": "72e4e912bbc79ab34a6ee619649d57a8ef753380",
      "closedAt": "2020-06-18T21:30:47Z",
      "mergedAt": "2020-06-18T21:30:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cbb83fdedad444990351e9f6654f389ce83a1501"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjU1NjYz",
          "commit": {
            "abbreviatedOid": "72e4e91"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Excellent, I was about to propose this.  Glad someone else got to it first :)",
          "createdAt": "2020-06-18T21:20:35Z",
          "updatedAt": "2020-06-18T21:20:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjU2MDE3",
          "commit": {
            "abbreviatedOid": "72e4e91"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-18T21:21:12Z",
          "updatedAt": "2020-06-18T21:21:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 119,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MDYwNjUx",
      "title": "Clarify desired security properties",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/119",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is work in progress to address #98, added as a pull request already to have early feedback.",
      "createdAt": "2020-06-19T11:57:28Z",
      "updatedAt": "2020-06-26T21:39:46Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fb0d45e38435664b602c69953967c9c4485840ca",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_security_properties",
      "headRefOid": "4244901ca7c164126783049d412f934c8874b5a3",
      "closedAt": "2020-06-26T21:39:46Z",
      "mergedAt": "2020-06-26T21:39:46Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "012709f788ffbafdd99a6e777369f6101296c957"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "New suggestions, please review. We need to figure out how to formulate that the proofs are not yet analyzing encrypt-to-self and not yet all the curves.\r\n\r\nOh, and I am sorry for the force-pushs; I was experimenting with rebase, apparently unsuccessful.",
          "createdAt": "2020-06-23T13:18:53Z",
          "updatedAt": "2020-06-23T13:23:37Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation @chris-wood I added a reference to NaCl's box. Please see if this is how you want to phrase it.\r\n\r\nIntuitively it sounds like it, but I am not sure if for 0-RTT protocols/primitives, being vulnerable to KCI is equivalent to having reputability. In any way it is interesting how Box phrases it:\r\n\r\n\u201cThe crypto_box function is not meant to provide non-repudiation. On the contrary: the crypto_box function guarantees repudiability. A receiver can freely modify a boxed message, and therefore cannot convince third parties that this particular message came from the sender. The sender and receiver are nevertheless protected against forgeries by other parties. In the terminology of https://groups.google.com/group/sci.crypt/msg/ec5c18b23b11d82c, crypto_box uses \"public-key authenticators\" rather than \"public-key signatures.\"\r\n\r\nUsers who want public verifiability (or receiver-assisted public verifiability) should instead use signatures (or signcryption). Signature support is a high priority for NaCl; a signature API will be described in subsequent NaCl documentation.\u201d",
          "createdAt": "2020-06-25T18:52:21Z",
          "updatedAt": "2020-06-25T18:52:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Intuitively it sounds like it, but I am not sure if for 0-RTT protocols/primitives, being vulnerable to KCI is equivalent to having reputability. \r\n\r\nThat's a good observation -- thanks for adding it! Given that, I'm fine with this PR as is.",
          "createdAt": "2020-06-25T19:04:48Z",
          "updatedAt": "2020-06-25T19:04:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTY5ODAx",
          "commit": {
            "abbreviatedOid": "1d70001"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Good start! Is more text coming?",
          "createdAt": "2020-06-19T15:34:19Z",
          "updatedAt": "2020-06-19T15:36:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nassured that the sender held the corresponding PSK. See {{sec-properties}} for more details.\r\n```\r\n\r\n(We can leave discussion about confidentiality guarantees and properties to the security considerations section.)",
              "createdAt": "2020-06-19T15:34:19Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\nassured that the sender held the pre-shared key (PSK). The PSK is also improving the\r\n```\r\n\r\n(If this is the first time \"PSK\" occurs)",
              "createdAt": "2020-06-19T15:34:54Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 52,
              "body": "```suggestion\r\nauthenticate that the sender possessed a given PSK.\r\n```",
              "createdAt": "2020-06-19T15:35:01Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nThe PSK also improves confidentiality guarantees in certain adversary models, \r\nas described in more detail in {{sec-properties}}. We assume that both parties have\r\nbeen provisioned with both the PSK value `psk` and another byte string\r\n`pskID` that is used to identify which PSK should be used.\r\n```",
              "createdAt": "2020-06-19T15:35:57Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 71,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-06-19T15:36:13Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NjcyMDE4",
          "commit": {
            "abbreviatedOid": "f2422cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks great! Can we pull in some content from #123 here? Once done, I'm good with this to go.",
          "createdAt": "2020-06-25T16:40:56Z",
          "updatedAt": "2020-06-25T16:49:12Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "This isn't quite true (per the KCI problems noted in our offline thread) -- can we adjust this?",
              "createdAt": "2020-06-25T16:40:56Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 179,
              "body": "```suggestion\r\nrecipient keys are the same.\r\n```",
              "createdAt": "2020-06-25T16:43:24Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 201,
              "body": "```suggestion\r\nGiven these properties, pre-shared keys strengthen both the authentication and the \r\nsecrecy properties in certain adversary models. One particular example in which\r\n```",
              "createdAt": "2020-06-25T16:44:09Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 203,
              "body": "```suggestion\r\nnon-quantum-resistant KEM used with HPKE is broken by a\r\n```",
              "createdAt": "2020-06-25T16:44:34Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 202,
              "body": "```suggestion\r\nthis can be useful is a hybrid quantum setting: if a\r\n```",
              "createdAt": "2020-06-25T16:44:41Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 206,
              "body": "```suggestion\r\ncompromised, as described in {{WireGuard}}.\r\n```",
              "createdAt": "2020-06-25T16:44:52Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 216,
              "body": "```suggestion\r\nthe KEM and the AEAD. Analyzing the HPKE instantiation in this\r\ndocument therefore required verifying that the additional KDF calls \r\ndo not cause the IND-CCA2 property to fail, as well as verifying the \r\ntwo additional properties noted above (export key secrecy and \r\nsender authentication).\r\n```",
              "createdAt": "2020-06-25T16:46:00Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            },
            {
              "originalPosition": 222,
              "body": "```suggestion\r\nfollowing conditions {{HPKEAnalysis}}:\r\n```",
              "createdAt": "2020-06-25T16:47:18Z",
              "updatedAt": "2020-06-25T18:43:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3Nzc4ODE3",
          "commit": {
            "abbreviatedOid": "4244901"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T19:04:07Z",
          "updatedAt": "2020-06-25T19:04:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3OTA4ODMw",
          "commit": {
            "abbreviatedOid": "4244901"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T22:45:02Z",
          "updatedAt": "2020-06-25T22:46:45Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "Since there's only one difference, we could just have this as a paragraph: \"The primary difference from the base case is that the calls to ...\"",
              "createdAt": "2020-06-25T22:45:02Z",
              "updatedAt": "2020-06-25T22:46:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3OTA5OTA5",
          "commit": {
            "abbreviatedOid": "4244901"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T22:47:49Z",
          "updatedAt": "2020-06-25T22:47:50Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-06-25T22:47:49Z",
              "updatedAt": "2020-06-25T22:47:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjEwNzE2",
          "commit": {
            "abbreviatedOid": "4244901"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-26T21:39:31Z",
          "updatedAt": "2020-06-26T21:39:31Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "I'll make this change after merging!",
              "createdAt": "2020-06-26T21:39:31Z",
              "updatedAt": "2020-06-26T21:39:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM3MzAyNjAy",
      "title": "Clarify that DeriveKeyPair is a KEM function.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/120",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @rozbb ",
      "createdAt": "2020-06-19T21:28:45Z",
      "updatedAt": "2020-06-20T18:29:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "98087a20c9e1338078fc6c4970f88daf1f5b9062",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/dkp-to-kem",
      "headRefOid": "93415d303b34101873d7fde68f70b360b540a089",
      "closedAt": "2020-06-20T18:29:11Z",
      "mergedAt": "2020-06-20T18:29:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3e3224b52673898c6975ac3f523bb6e51a3bc8ad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDQ1Nzky",
          "commit": {
            "abbreviatedOid": "93415d3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-20T18:29:05Z",
          "updatedAt": "2020-06-20T18:29:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 121,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4MTkyMTgy",
      "title": "Clarify that not all KEMs can implement the full interface.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/121",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-22T21:41:33Z",
      "updatedAt": "2020-06-22T21:51:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3e3224b52673898c6975ac3f523bb6e51a3bc8ad",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/authencap",
      "headRefOid": "a0c9bb806990b2bf8b133df064bbf990d22ec48b",
      "closedAt": "2020-06-22T21:51:55Z",
      "mergedAt": "2020-06-22T21:51:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fb0d45e38435664b602c69953967c9c4485840ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1Mjk1OTY2",
          "commit": {
            "abbreviatedOid": "6518bd6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-22T21:45:07Z",
          "updatedAt": "2020-06-22T21:45:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nit: \"may\" is not the right verb.  Maybe \"are\".",
              "createdAt": "2020-06-22T21:45:07Z",
              "updatedAt": "2020-06-22T21:51:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1Mjk5Mzg5",
          "commit": {
            "abbreviatedOid": "a0c9bb8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-22T21:51:41Z",
          "updatedAt": "2020-06-22T21:51:42Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's better -- thanks.",
              "createdAt": "2020-06-22T21:51:41Z",
              "updatedAt": "2020-06-22T21:51:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4NTk0OTMy",
      "title": "Use LabeledExpand inside DeriveKeyPair",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/122",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For consistency it would be nice to use LabeledExpand everywhere.\r\n\r\ncc @rozbb ",
      "createdAt": "2020-06-23T14:05:36Z",
      "updatedAt": "2020-06-25T16:43:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fb0d45e38435664b602c69953967c9c4485840ca",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_derivekeypair_expand",
      "headRefOid": "9104206afcc3691faf5ac4e9eab1978c7bf41207",
      "closedAt": "2020-06-25T16:43:52Z",
      "mergedAt": "2020-06-25T16:43:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "783861e76ba88180b2c638083d3f459d04484a1e"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my first commit I forgot about X25519 and X448.\r\n\r\nI changed labels inside DHKEM's ExtractAndExpand to be more consistent with what we did elsewhere so far: have the label be basically the target variable name. Like label \u201cpsk_hash\u201d if we are computing `psk_hash`.\r\n\r\nI added labels for LabeledExtract inside DeriveKeyPair because these calls shall not collide with calls inside ExtractAndExpand. I am not really happy with \u201cdkp_prk\u201d (**D**erive**K**ey**P**air prk) but wanted it to be different from \u201cprk\u201d because that is already used inside ExtractAndExpand. Ideas? **Edited to add**: maybe the colon instead of an underscore will do to more intuitively separate the namespace for the label. Do you realize, we now have namespaces for labels!! :D",
          "createdAt": "2020-06-23T14:28:04Z",
          "updatedAt": "2020-06-23T14:44:24Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh also you can make the counter initial value equal to 0 if you'd like. I had no reason other than \"counter #0\" sounded weird to me",
          "createdAt": "2020-06-25T16:32:29Z",
          "updatedAt": "2020-06-25T16:32:29Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Excellent, thanks, I just pushed your suggestions.",
          "createdAt": "2020-06-25T16:34:05Z",
          "updatedAt": "2020-06-25T16:34:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODc0NzEz",
          "commit": {
            "abbreviatedOid": "5a3ce40"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-06-23T15:01:22Z",
          "updatedAt": "2020-06-23T15:02:32Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n  dkp_prk = LabeledExtract(zero(0), concat(I2OSP(kem_id, 2), \"dkp_prk\"), ikm)\r\n```",
              "createdAt": "2020-06-23T15:01:22Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n    bytes = LabeledExpand(dkp_prk, \"candidate\", I2OSP(counter, 1), Nsk)\r\n```",
              "createdAt": "2020-06-23T15:01:35Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 19,
              "body": "Can this loop more than 255 times? If so, the encoding of counter might wrap below.",
              "createdAt": "2020-06-23T15:02:01Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n  dkp_prk = LabeledExtract(zero(0), concat(I2OSP(kem_id, 2), \"dkp_prk\"), ikm)\r\n  sk = LabeledExpand(dkp_prk, \"sk\", zero(0), Nsk)\r\n```",
              "createdAt": "2020-06-23T15:02:26Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1ODg2NzYz",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-23T15:13:57Z",
          "updatedAt": "2020-06-23T15:13:57Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Very good question! Maybe @rozbb knows? I'll try to check later, too.",
              "createdAt": "2020-06-23T15:13:57Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1OTQ5NjY5",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-23T16:23:43Z",
          "updatedAt": "2020-06-23T16:23:43Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I'm pretty sure the probability of this looping more than 255 times is negligible. Nevertheless, maybe we can have a short-circuit in that case? That is, inside the loop:\r\n\r\n~~~\r\nif counter > 255:\r\n   raise DeriveKeyPairFailedException()\r\n~~~",
              "createdAt": "2020-06-23T16:23:43Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzI3OTgz",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T05:11:03Z",
          "updatedAt": "2020-06-24T05:15:33Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Indeed, the likelihood of this failing after 255 loops is 1/2^8160. I suppose if we're doing the range check on sk (which is within range with all-but-negligible probability), then it makes sense to do a counter check.\r\n\r\nThe `raise` should either raise a generic Exception with parens, or a specific exception (such as DeriveKeyPairFailed) without parens. I prefer `raise DeriveKeyPairError`, in keeping with other error names",
              "createdAt": "2020-06-24T05:11:03Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 16,
              "body": "Is there a downside of putting the kem_id in the salt parameter and omitting the concat operation? It'd be cleaner",
              "createdAt": "2020-06-24T05:14:37Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            },
            {
              "originalPosition": 32,
              "body": "Ditto here for putting kem_id in the salt.",
              "createdAt": "2020-06-24T05:14:59Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzMwNDM4",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T05:18:49Z",
          "updatedAt": "2020-06-24T05:18:49Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Maybe for the sake of consistency you namespace these as well. `eae_prk` and `eae_zz`",
              "createdAt": "2020-06-24T05:18:49Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NjA4ODMx",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T12:44:01Z",
          "updatedAt": "2020-06-24T12:44:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Yeah, I wondered that myself when implementing the change. ",
              "createdAt": "2020-06-24T12:44:01Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NjA5NTk2",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T12:45:06Z",
          "updatedAt": "2020-06-24T12:45:06Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I used `raise` since it matches the notation used elsewhere. I'd treat this sort of failure the same as a `Context.Seal` failure.",
              "createdAt": "2020-06-24T12:45:06Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTMyNzU2",
          "commit": {
            "abbreviatedOid": "92bf279"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:10:10Z",
          "updatedAt": "2020-06-25T14:10:11Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "[The `salt` parameter is supposed to be random](https://tools.ietf.org/html/rfc5869#section-2.2) and [independent of `ikm`](https://tools.ietf.org/html/rfc5869#section-3.4), so I believe we should not use it to put the constant `kem_id` there.",
              "createdAt": "2020-06-25T14:10:10Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTQ4ODY4",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:26:22Z",
          "updatedAt": "2020-06-25T14:26:23Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Added the check with the most recent commit. Are you fine with having the check directly at the beginning?\r\n\r\nDo you like adding the probability of failure? How was it calculated by the way?\r\n\r\nOh, and why does the counter start with 1? If it started with 0, we would win one trial before failing. Very improbable that this one more trial makes a difference, sure ;)",
              "createdAt": "2020-06-25T14:26:23Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTQ5Nzgx",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:27:20Z",
          "updatedAt": "2020-06-25T14:27:21Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I changed to `eae_prk`, but left zz untouched, because zz is unique, and we also did not namespace sk (because it is unique as well).",
              "createdAt": "2020-06-25T14:27:21Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTYyMjk2",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:39:21Z",
          "updatedAt": "2020-06-25T14:39:21Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Yeah, it would be \"misuse\", but I don't think it makes any difference internally. Anyway, fine to leave this as is!",
              "createdAt": "2020-06-25T14:39:21Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTYzMDI2",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T14:40:05Z",
          "updatedAt": "2020-06-25T14:40:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTczMTQz",
          "commit": {
            "abbreviatedOid": "eabe01a"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:50:24Z",
          "updatedAt": "2020-06-25T14:50:24Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I would just say \"negligible\", since the value varies from group to group.\r\n\r\nIf you're curious how I came to this number for P-256: the probability of one iteration failing is (2^256 - order)/2^256 = 2^-32. Then 255 iterations gives you that number.",
              "createdAt": "2020-06-25T14:50:24Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NTgxNzgy",
          "commit": {
            "abbreviatedOid": "8e6ff2c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T14:58:59Z",
          "updatedAt": "2020-06-25T14:58:59Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Oh right, thanks for this remark, I changed to \u201cnegligible\u201d.\r\n\r\nThanks for the clarification on how you computed the probability.",
              "createdAt": "2020-06-25T14:58:59Z",
              "updatedAt": "2020-06-25T16:33:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NjYzMDY5",
          "commit": {
            "abbreviatedOid": "8e6ff2c"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good! I would only tweak the wording slightly to say \"The precise likelihood of DeriveKeyPair failing with DeriveKeyPairError depends on the group being used, but it is negligibly small in all cases.\"",
          "createdAt": "2020-06-25T16:29:22Z",
          "updatedAt": "2020-06-25T16:30:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3Njc0MTg3",
          "commit": {
            "abbreviatedOid": "9104206"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T16:43:44Z",
          "updatedAt": "2020-06-25T16:43:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwMTM0MzQy",
      "title": "Note KCI problems with Auth and AuthPSK.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/123",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The NaCL/libsodium [Box API](https://libsodium.gitbook.io/doc/public-key_cryptography/authenticated_encryption)) has the same problem, so perhaps HPKE should acknowledge this and move on. Alternatively, we might consider either augmenting AuthEncap/AuthDecap to address this issue, or dropping the Auth and AuthPSK modes entirely. \r\n\r\ncc @jedisct1",
      "createdAt": "2020-06-25T16:35:01Z",
      "updatedAt": "2020-06-25T19:05:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fb0d45e38435664b602c69953967c9c4485840ca",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/kci-note",
      "headRefOid": "4021d811cf05c8c7d4c7b6134b3602554d7608e6",
      "closedAt": "2020-06-25T19:05:18Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In #119 I also made an attempt to mention KCI, see https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/119/files#diff-0ad9f9135e8a024768ba9765798d4738R1002. So we might merge, or take \u201cSecurity Properties\u201d as proposed in #119 and add a link to this new \u201cKey-Compromise Impersonation\u201d section (I like your suggestion to say that signatures could be used by the application to mitigate this).",
          "createdAt": "2020-06-25T16:42:04Z",
          "updatedAt": "2020-06-25T16:42:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I'm reviewing that now and just noticed it! Can we cite the paper I mention here for KCI, and then also mention the signature workaround?",
          "createdAt": "2020-06-25T16:48:12Z",
          "updatedAt": "2020-06-25T16:48:12Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This was moved to #119. Closing.",
          "createdAt": "2020-06-25T19:05:18Z",
          "updatedAt": "2020-06-25T19:05:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3Njc3Nzg5",
          "commit": {
            "abbreviatedOid": "4021d81"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T16:48:07Z",
          "updatedAt": "2020-06-25T16:48:12Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Do you want to note that predecessors such as libnacl Box also have this issue?",
              "createdAt": "2020-06-25T16:48:08Z",
              "updatedAt": "2020-06-25T16:48:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3Njc4OTky",
          "commit": {
            "abbreviatedOid": "4021d81"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T16:49:41Z",
          "updatedAt": "2020-06-25T16:49:42Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Yeah, let's do it. @blipp, can you do this in your PR?",
              "createdAt": "2020-06-25T16:49:42Z",
              "updatedAt": "2020-06-25T16:49:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 124,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwMzkxNTk2",
      "title": "Remove unnecessary KEM binding",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/124",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The KEM binding in LabeledExpand inside ExtractAndExpand is superfluous, since the KEM is already included in the LabeledExtract call. Further, KEM ID isn't included in a LabeledExpand call anywhere else in the spec.\r\n\r\nBesides that, I noticed the new lines were rendering long so I picked a multiline formatting style that looked good to me and applied it consistently.",
      "createdAt": "2020-06-26T05:38:34Z",
      "updatedAt": "2020-07-03T23:52:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "783861e76ba88180b2c638083d3f459d04484a1e",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "labeling-fixes",
      "headRefOid": "552a32e7ab2d95b78ff82679a1481e24fb90dd2a",
      "closedAt": "2020-07-03T23:52:00Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This raises an important point. I touched this topic briefly in https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/112#discussion_r442157565:\r\n\r\n \u201c[\u2026] binding to the [kem_id] plays a similar role as the RFCXXXX label which we do include in *both* LabeledExtract and LabeledExpand, even if the LabeledExtract results are never exposed. [\u2026] this is about [\u2026] that the calls are orthogonal, which makes it easier to reason with separate random oracles for separate ciphersuites (and DHKEM is kind of a sub-standard inside this RFC, so it makes sense to have RFCXXXX and the DHKEM group as a label).\u201d\r\n\r\nI thought about this again for a while today. I start thinking that we should just put the entire ciphersuite identifier as a label, along with \"RFCXXXX \". For a DHKEM, the \u201centire ciphersuite\u201d is only the `kem_id`, but for the remainder of HPKE, it is `kem_id`, `kdf_id`, `aead_id`.\r\n\r\n```\r\nciphersuite (KEM) = I2OSP(kem_id, 2)\r\n\r\nciphersuite (remainder) = concat(\r\n  I2OSP(kem_id, 2),\r\n  I2OSP(kdf_id, 2),\r\n  I2OSP(aead_id, 2))\r\n\r\ndef LabeledExtract(salt, label, IKM):\r\n  labeledIKM = concat(\"RFCXXXX \", ciphersuite, label, IKM)\r\n  return Extract(salt, labeledIKM)\r\n\r\ndef LabeledExpand(PRK, label, info, L):\r\n  labeledInfo = concat(I2OSP(L, 2), \"RFCXXXX \", ciphersuite, label, info)\r\n  return Expand(PRK, labeledInfo, L)\r\n```\r\n\r\nPackaging this into the KDF removes it as clutter from ExtractAndExpand and DeriveKeyPair, and would also simplify KeySchedule. So maybe this can unite advantages for both worlds: cleaner implementation, and good for proofs.\r\n\r\nI arrived here when thinking about why it is that we do not bind the following line to the ciphersuite:\r\n\r\n```\r\nsecret = LabeledExtract(psk_hash, \"secret\", zz)\r\n```\r\n\r\nwhile the 3 LabeledExpands in KeySchedule do have the ciphersuite within `key_schedule_context`, but then again the LabeledExpand in Context.Export does not have the ciphersuite explicitly. So again, just having the ciphersuite within LabeledExtract and LabeledExpand might make this all cleaner.",
          "createdAt": "2020-06-26T17:24:52Z",
          "updatedAt": "2020-06-26T17:24:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb this should be addressed by #127, so I'm closing as such. Please re-open if you disagree!",
          "createdAt": "2020-07-03T23:52:00Z",
          "updatedAt": "2020-07-03T23:52:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwNjg2NzQy",
      "title": "Add Ben as an author.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/125",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's about time I did this!",
      "createdAt": "2020-06-26T16:50:47Z",
      "updatedAt": "2020-06-26T18:23:53Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "783861e76ba88180b2c638083d3f459d04484a1e",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/add-ben",
      "headRefOid": "3baea1bdd5255daa1e8915f9f955f71767c3dd5e",
      "closedAt": "2020-06-26T18:23:53Z",
      "mergedAt": "2020-06-26T18:23:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2968b963d3bbb692da2b3be174ba3ae509360c27"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NDcxNjU5",
          "commit": {
            "abbreviatedOid": "cdbcf87"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you, really happy and honored to be on this team :)",
          "createdAt": "2020-06-26T17:27:34Z",
          "updatedAt": "2020-06-26T17:30:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n    org: Inria\r\n```\r\n\r\nLet's do `Inria`, because I only recently learned that this is the new preferred writing of the institute. And Karthik does not have `Paris`, so I'd drop that too for consistency.",
              "createdAt": "2020-06-26T17:27:35Z",
              "updatedAt": "2020-06-26T18:23:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQwODA3Njc0",
      "title": "Unify domain separation by including algorithm identifiers in each Extract and Expand call.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/126",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For DHKEM, the identifier is the KEM ID. For everything else, the identifier is\r\nthe combination of one-byte mode identifier and HPKE ciphersuite tuple.\r\n\r\nThis does more binding, in contrast to what's in #124.\r\n\r\ncc @blipp",
      "createdAt": "2020-06-26T22:13:25Z",
      "updatedAt": "2020-06-29T15:03:33Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0a5f53924207f33d7d10f20647dfc7b2263a7bfa",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/unify-separation",
      "headRefOid": "a74f88962ca46cb04d84e1073831644970f9f345",
      "closedAt": "2020-06-29T15:03:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I submitted an alternative approach with #127. It has the advantage that `Context.Export` also gets to use the `identifier`, which would need an API change if `identifier` is explicit.",
          "createdAt": "2020-06-29T14:59:55Z",
          "updatedAt": "2020-06-29T15:00:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "The proposal in #127 is cleaner -- closing!",
          "createdAt": "2020-06-29T15:03:33Z",
          "updatedAt": "2020-06-29T15:03:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjMwMzgz",
          "commit": {
            "abbreviatedOid": "a74f889"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T14:58:12Z",
          "updatedAt": "2020-06-29T14:58:13Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n  sk = LabeledExpand(dkp_prk, concat(I2OSP(kem_id, 2), \"sk\"), zero(0), Nsk)\r\n```",
              "createdAt": "2020-06-29T14:58:13Z",
              "updatedAt": "2020-06-29T14:58:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQxNDcxMzQy",
      "title": "Unify separation by implicitly including algorithm identifiers",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/127",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I would like to make an alternative proposition to #126, based on it.\r\n\r\nIn this proposition, `identifier` is used as implicit parameter to `LabeledExtract` and `LabeledExpand`. This can be justified because the document already assumes that `kem_id`, `kdf_id`, `aead_id` are implicitly encoded into the implementation. The advantage of having `identifier` implicit is that this removes clutter from the other function definitions; this might make implementation work easier because the calls to LabeledExtract and LabeledExpand then have fewer nested parameters.\r\n\r\nOn the question if `mode` should be in the identifier: if `mode` should be in the identifier, it is hard to let `identifier` be an implicit parameter, because the `mode` parameter is an explicit parameter (which is needed for `VerifyPSKInputs`). I thought about if we can find a reason why *not* including `mode` in the identifier is justified from a provable security point-of-view. I came to the conclusion this works out, because:\r\n\r\nThe first calls in `KeySchedule` are, from a variable dependencies point of view:\r\n```\r\n  psk_hash = LabeledExtract(zero(0), \"psk_hash\", psk)\r\n  secret = LabeledExtract(psk_hash, \"secret\", zz)\r\n```\r\n\r\nAll the following KDF calls include `mode` because it is in the `key_schedule_context`, so those are safe. Values of `secret` cannot collide between different modes, because:\r\n- `zz` is the same for the Base and PSK modes, but `psk_hash` is different for these modes (default_psk vs non-defaut)\r\n- `zz` is the same for the Auth and AuthPSK modes, but `psk_hash` is different for these modes (default_psk vs non-defaut)\r\n\r\nThis means we do not need to domain-separate by the mode in each call, because the two LabeledExtracts above already have a clear-enough dependency on the mode; which allows us to have `identifier` be implicit and have cleaner function definitions.",
      "createdAt": "2020-06-29T14:56:46Z",
      "updatedAt": "2020-07-03T23:51:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d7d2e75d773828134061c1a0c0704427cdad13bb",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_unify_separation",
      "headRefOid": "ee025a6039cbbd3aad7bcaf1a6bd41a5741bba5b",
      "closedAt": "2020-07-03T23:51:27Z",
      "mergedAt": "2020-07-03T23:51:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ba9dd084c17f661b9c50a115c1dba2e336374d42"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- I resolved the possible collision between the KEM KDF calls and the remainder of HPKE by adding `KEM` and `DEM` after `RFCXXXX `. I feel like this was overdue anyway.\r\n- I changed `identifier` to `suite_id`.\r\n- Regarding @bifurcation's comment\r\n> This seems likely to be confused. Would it be clearer to add the identifier as a parameter to these methods, and explicitly pass in the right one?\r\n\r\nHm, I am torn on this one. These two possibly *different* KDFs that are both referenced with the *same names* `LabeledExtract` and `LabeledExpand` have been in the document since we added a KDF in the KEM. Adding `suite_id` just makes this possible confusion problem more apparent I guess. The test vectors will catch it at the end, but if we can make the confusion less likely, it would be nice for the developers.\r\n\r\nI am fond of the idea to leave `suite_id` implicit, because making it explicit will clutter the calls to `LabeledExtract` and `LabeledExpand`. What else could we do? Separate names like `LabeledExtractKEM` and `LabeledExtractDEM`?",
          "createdAt": "2020-07-01T12:05:44Z",
          "updatedAt": "2020-07-01T12:05:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I am fond of the idea to leave suite_id implicit, because making it explicit will clutter the calls to LabeledExtract and LabeledExpand. What else could we do? Separate names like LabeledExtractKEM and LabeledExtractDEM?\r\n\r\nI'm not sure I see much difference between a separate name for the DHKEM LabeledExtract/Expand functions, and passing the suite_id in as a parameter to the existing LabeledExtract/Expand functions. On balance, I think I also prefer what's currently written (implicit parameters). ",
          "createdAt": "2020-07-01T16:50:53Z",
          "updatedAt": "2020-07-02T18:17:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjM2MjI1",
          "commit": {
            "abbreviatedOid": "8750089"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice! @bifurcation, please have a look.",
          "createdAt": "2020-06-29T15:04:16Z",
          "updatedAt": "2020-06-29T15:05:27Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-06-29T15:04:16Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzYyODE0",
          "commit": {
            "abbreviatedOid": "723333c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T17:38:59Z",
          "updatedAt": "2020-06-29T17:43:38Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "This seems likely to be confused.  Would it be clearer to add the identifier as a parameter to these methods, and explicitly pass in the right one?",
              "createdAt": "2020-06-29T17:38:59Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            },
            {
              "originalPosition": 27,
              "body": "Note that the suite ID is a different length than the individual KEM ID.  Do we need to worry about collision with the label?",
              "createdAt": "2020-06-29T17:40:04Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            },
            {
              "originalPosition": 80,
              "body": "`suite_id`  for consistency?",
              "createdAt": "2020-06-29T17:41:47Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5Mzc3MDkw",
          "commit": {
            "abbreviatedOid": "723333c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T17:59:13Z",
          "updatedAt": "2020-06-29T17:59:13Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "> Note that the suite ID is a different length than the individual KEM ID. Do we need to worry about collision with the label?\r\n\r\nUh, good one. Yes, theoretically `aead_id` could collide with the labels `eae_prk` and `zz`. Not for the AEADs in the current document though: `hex(ord(\"z\"))` is `0x7a` and `hex(ord(\"e\"))` is `0x65`, and all current AEADs have 0s in the first byte.\r\n\r\nWe could have the `suite_id` for the KEMs be `concat(I2OSP(kem_id, 2), zero(4))` to avoid that forever.",
              "createdAt": "2020-06-29T17:59:13Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMDA2NTkz",
          "commit": {
            "abbreviatedOid": "5ffb00c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One nit, otherwise LGTM.",
          "createdAt": "2020-07-02T20:42:39Z",
          "updatedAt": "2020-07-02T20:49:08Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Nit: I would use \"HPKE\" for the non-KEM thing.",
              "createdAt": "2020-07-02T20:42:39Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyMzE5NTA4",
          "commit": {
            "abbreviatedOid": "01834ff"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-03T10:33:28Z",
          "updatedAt": "2020-07-03T10:33:29Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Good point \u2013 I just made this change.",
              "createdAt": "2020-07-03T10:33:28Z",
              "updatedAt": "2020-07-03T20:25:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 129,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQxNTQzOTQy",
      "title": "Add GenerateKeyPair for use in Encap and AuthEncap.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/129",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #128.",
      "createdAt": "2020-06-29T17:12:07Z",
      "updatedAt": "2020-06-29T17:58:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0a5f53924207f33d7d10f20647dfc7b2263a7bfa",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/add-gkp",
      "headRefOid": "a4cded73cd66c52297b558cd2eb292351f65158f",
      "closedAt": "2020-06-29T17:58:27Z",
      "mergedAt": "2020-06-29T17:58:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d7d2e75d773828134061c1a0c0704427cdad13bb"
      },
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That changes makes a lot of sense. Maybe we could add some comment somewhere in the document saying why we need `DeriveKeyPair` (it is for static keys)?",
          "createdAt": "2020-06-29T17:20:54Z",
          "updatedAt": "2020-06-29T17:20:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Maybe we could add some comment somewhere in the document saying why we need DeriveKeyPair (it is for static keys)\r\n\r\nI'm inclined to leave that off for now, if only because the output of DKP and GKP is indistinguishable, so applications may use either as they see fit.",
          "createdAt": "2020-06-29T17:24:45Z",
          "updatedAt": "2020-06-29T17:56:36Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should remember to add test vectors for DeriveKeyPair \u2013 as it is not used in (Auth)Encap anymore, it is not covered by the current test vectors.",
          "createdAt": "2020-06-29T17:44:16Z",
          "updatedAt": "2020-06-29T17:44:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp -- I resolved this by just noting that folks can implemented GKP using DKP. ",
          "createdAt": "2020-06-29T17:55:15Z",
          "updatedAt": "2020-06-29T17:55:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzUxMTQz",
          "commit": {
            "abbreviatedOid": "34fe14e"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T17:22:53Z",
          "updatedAt": "2020-06-29T17:22:54Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n  - GenerateKeyPair(): Generate a key pair (skX, pkX)\r\n```",
              "createdAt": "2020-06-29T17:22:53Z",
              "updatedAt": "2020-06-29T17:56:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzUxNTI1",
          "commit": {
            "abbreviatedOid": "34fe14e"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T17:23:24Z",
          "updatedAt": "2020-06-29T17:23:25Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n- GenerateKeyPair(): Generate an ephemeral key pair `(skX, pkX)`\r\n```",
              "createdAt": "2020-06-29T17:23:24Z",
              "updatedAt": "2020-06-29T17:56:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5Mzc2NDA1",
          "commit": {
            "abbreviatedOid": "a4cded7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-29T17:58:16Z",
          "updatedAt": "2020-06-29T17:58:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 130,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ1NDgzNzgy",
      "title": "Clarify input types for pkR, pkS, enc",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/130",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It is implicitly clear from the body of (Auth)Encap and (Auth)Decap, that `pkR` and `pkS` are supposed to be deserialized public keys and `enc` a serialized public key. This suggested change makes it explicit.",
      "createdAt": "2020-07-07T15:20:23Z",
      "updatedAt": "2020-07-08T12:47:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ba9dd084c17f661b9c50a115c1dba2e336374d42",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_input_types",
      "headRefOid": "5058b4a3d56c0d653135e92de3af7a8ac6493d52",
      "closedAt": "2020-07-08T12:47:05Z",
      "mergedAt": "2020-07-08T12:47:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1c7c34dbbb4be02331d2cf77ecef4e06361c7ccd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzI4MTc0",
          "commit": {
            "abbreviatedOid": "5058b4a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-08T12:47:00Z",
          "updatedAt": "2020-07-08T12:47:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ1NjIxMjA2",
      "title": "Prepare for future KEMs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/131",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is work in progress and addresses #84 \u201cGuidance for future KEMs\u201d.\r\n\r\nNotes on public key length:\r\n- It seems that in SIKE, the uncompressed public key length is fixed, and [the compressed size is also fixed](https://hyp.is/-Ks_uMB1EeqREaPjYYE8nQ/eprint.iacr.org/2020/431.pdf), but smaller. I did not check all the NIST candidates so see if others do something similar. Especially I did not look if someone does variable size public keys, like, an entire range of sizes. Do you think we need to accommodate for this more explicitly? I made a small note down in `IANA Considerations/KEM Identifiers`.\r\n- In SIKE, Encaps and Decaps always take uncompressed public keys as inputs, so the caller is supposed to do the decompression, if necessary.\r\n- We do already say explicitly that for P256, P384, P521, HPKE uses **un**compressed public key encoding. I guess that is due to the current of implementations? It seems for post-quantum KEMs it is interesting to leave both possibilities open, uncompressed and compressed, because some devices might not have the computation power to do (de)compression.\r\n\r\nNotes on security requirements:\r\n- I removed the explicit requirement that `enc`, `pkR`, `pkS` must be included into the context of the KEM's key derivation. What we need is IND-CCA2 security, and if a KEM has that without these in the context, that is completely fine.\r\n\r\nDONE:\r\n- see if RSA fits into this already, as mentioned in #84.\r\n- I did not yet look at the \u201crelationship between the private key and the public key\u201d as mentioned in #84.\r\n\r\nTODO\r\n- See if any NIST candidates have different encodings for KEM ciphertexts\r\n- Do the proofs for the new security notions and update the text accordingly.\r\n- use these new notions in the main Security Considerations text?\r\n\r\nFeedback welcome especially on:\r\n- is it good to make `OPTIONAL` all-caps for GenerateKeyPair, DeriveKeyPair, AuthEncap, AuthDecap?\r\n- different public key sizes: do you think the formulations work?\r\n- It occurred to me that KEM ciphertexts might as well also have different encodings. I did not check yet if any of the NIST candidates do (this is a lot of reading work)",
      "createdAt": "2020-07-07T19:36:28Z",
      "updatedAt": "2020-10-22T17:19:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d7c239315247e59c2d563cb7c44c918552489e4a",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_kem_guidance",
      "headRefOid": "28b4d35cfdf297dd5f9a5e95ed39e3a70432256e",
      "closedAt": "2020-10-22T17:19:05Z",
      "mergedAt": "2020-10-22T17:19:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "61cefafead603f32dc19ed54db108a2e63a727f6"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> is it good to make OPTIONAL all-caps for GenerateKeyPair, DeriveKeyPair, AuthEncap, AuthDecap?\r\n\r\nI'm fine with all-caps, though I'm not sure GenerateKeyPair is optional. That seems to be pretty essential.\r\n\r\n> different public key sizes: do you think the formulations work?\r\n\r\nI'm not sure. I'd suggest Npk/Nenc representing maximum values, and the serialize/deserialize functions being able to parse inputs up to that size.\r\n\r\n> It occurred to me that KEM ciphertexts might as well also have different encodings. I did not check yet if any of the NIST candidates do (this is a lot of reading work)\r\n\r\nCertainly if public keys have different sizes then their encodings would too, right?",
          "createdAt": "2020-07-08T12:46:27Z",
          "updatedAt": "2020-07-08T12:46:27Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The plan is to define adapted security notions for the authenticated KEM interface inside the Section \u201cSecurity Requirements on a KEM used within HPKE\u201d. With a bit of luck this can be ready for Monday, but in the meantime, this version cites the already available definitions. The adapted security notions will be more optimal for HPKE.",
          "createdAt": "2020-07-10T19:43:00Z",
          "updatedAt": "2020-07-10T19:43:00Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "New draft which formulates a bit more careful the security requirements on a KEM: if there is a proof of the full HPKE with the new KEM, then that is fine, and we do not require any particular proofs on the KEM; we only indicate that if the KEM satisfies some security notion, then the existing compositions results provide some indication that this is fine for the entire HPKE, then.\r\n\r\nI do not think that the new security notions and composition proofs adapted to HPKE will be ready enough by tomorrow such that we could, with confidence, already define them in the document. I think citing this signcryption book from 2010 is the best we can do for now, and I'll discuss with the others if they know any other more fitting reference.",
          "createdAt": "2020-07-12T17:05:17Z",
          "updatedAt": "2020-07-12T17:05:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> New draft which formulates a bit more careful the security requirements on a KEM: if there is a proof of the full HPKE with the new KEM, then that is fine, and we do not require any particular proofs on the KEM; we only indicate that if the KEM satisfies some security notion, then the existing compositions results provide some indication that this is fine for the entire HPKE, then.\r\n\r\nThanks! I think this is a fine way to capture the requirements. ",
          "createdAt": "2020-07-13T15:00:16Z",
          "updatedAt": "2020-07-13T15:00:16Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On the particular point of variable-size keys: We should stick to fixed size here.  If we change, then we'll need proper injective encodings as opposed to just concatenating fixed-length things. And as long as there's a max size, the KEM-specific code in an HPKE implementation can always pad out to that size.",
          "createdAt": "2020-10-18T17:48:04Z",
          "updatedAt": "2020-10-18T17:48:04Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> On the particular point of variable-size keys: We should stick to fixed size here. If we change, then we'll need proper injective encodings as opposed to just concatenating fixed-length things. And as long as there's a max size, the KEM-specific code in an HPKE implementation can always pad out to that size.\r\n\r\n@blipp I proposed suggested changes to revert to fixed-sized keys, with text that suggests how future KEMs must choose one encoding to match that size. Can you please review (and resolve the conflicts) ASAP? (Richard will start a pass after those changes, or some variant thereof, are merged.)",
          "createdAt": "2020-10-21T03:16:51Z",
          "updatedAt": "2020-10-21T03:16:51Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp can we add a sentence describing what the Auth column in the registry table stands for?",
          "createdAt": "2020-10-22T16:06:40Z",
          "updatedAt": "2020-10-22T16:06:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzE1Njk0",
          "commit": {
            "abbreviatedOid": "db9b2c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "First pass complete. Good first start!",
          "createdAt": "2020-07-08T12:30:52Z",
          "updatedAt": "2020-07-08T12:44:45Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This seems like an implementation detail, so I'd remove it.",
              "createdAt": "2020-07-08T12:30:52Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 28,
              "body": "Hmm, this seems mandatory since it's used in Encap, no? Is the idea that future Encaps might not have a key generation function? If not, how would keys, well, be generated?",
              "createdAt": "2020-07-08T12:31:49Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 181,
              "body": "I'm not sure Insider-CCA-secure and insider-Auth-secure are common terms. We should probably define them.",
              "createdAt": "2020-07-08T12:41:22Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 205,
              "body": "Maybe this should be the maximum length of an encapsulated key? The text below (suggesting that there are different lengths that need to be specified) seems odd. Really this value is in place to help with allocations and whatnot, right?",
              "createdAt": "2020-07-08T12:42:58Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 209,
              "body": "Same suggestion here for maximum length.",
              "createdAt": "2020-07-08T12:43:09Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 124,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-07-08T12:43:26Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 35,
              "body": "Using a single constant to refer to multiple values seems error prone. Can we avoid this?",
              "createdAt": "2020-07-08T12:44:35Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzMxNDg2",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:51:14Z",
          "updatedAt": "2020-07-08T12:51:15Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "```suggestion\r\nSince an encapsulated key is a Diffie-Hellman public key in this KEM algorithm,\r\n`SerializePublicKey` and `SerializeCiphertext` are equivalent (`Npk` = `Nenc`).\r\nThus, we implement both using a single function called `Serialize`. `Deserialize`\r\nis implemented similarly.\r\n```",
              "createdAt": "2020-07-08T12:51:14Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzMxNTMx",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:51:17Z",
          "updatedAt": "2020-07-08T12:51:18Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I added this because #84 mentioned that for example RSA does not have this clear of a relation between public key and secret key; at least computing the public key from the secret key involves a lot of computation in RSA. We could mention it elsewhere in the document? Maybe just move the new text to the Future KEMs section?",
              "createdAt": "2020-07-08T12:51:17Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzMxOTE2",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:51:46Z",
          "updatedAt": "2020-07-08T12:51:46Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Should we this `SerializeEncapsulatedKey`, rather than ciphertext? (That would align better with the KEM vocabulary, I think.)",
              "createdAt": "2020-07-08T12:51:46Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzM1MzE0",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:55:54Z",
          "updatedAt": "2020-07-08T12:55:55Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "For DHKEM it is mandatory because it is used in Encap/Decap as you say. Other KEMs, and RSA for example, do not use it in Encap. For these KEMs, the HPKE implementation can receive the keys from outside (the higher-level application). The keys would then also be assumed to be generated by the application. The RFCs mentioning RSA KEMs https://tools.ietf.org/html/rfc5990 and https://tools.ietf.org/html/rfc8017 for example do not mention key generation at all.",
              "createdAt": "2020-07-08T12:55:54Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzM2Nzk4",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T12:57:38Z",
          "updatedAt": "2020-07-08T12:57:39Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "Yes, we should define them somehow. Similar notions have been around in Signcryption literature for a while, but it is true that they are not so commen, and also the notions I am working on with the others are a bit different. Should we define them in an appendix?",
              "createdAt": "2020-07-08T12:57:39Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzQwMTAz",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T13:01:33Z",
          "updatedAt": "2020-07-08T13:01:33Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Having said that, I agree that saying `OPTIONAL` if the DHKEMs defined in the document definitely require it, is odd. We could write optional in lowercase, or don't mention it in the Cryptographic Dependencies section at all and only leave the explanation in the Future KEMs section. Do you have a preference?",
              "createdAt": "2020-07-08T13:01:33Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzQxNDg3",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T13:03:15Z",
          "updatedAt": "2020-07-08T13:03:15Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": ":+1: ",
              "createdAt": "2020-07-08T13:03:15Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzQ0Mjcy",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T13:06:27Z",
          "updatedAt": "2020-07-08T13:06:27Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "I like your idea of the maximum length. For the NIST P-curves, the deserialize algorithm is actually specified this way: it takes up to the maximum length, and a condition inside decides if decompression is done, depending on the actually received size.",
              "createdAt": "2020-07-08T13:06:27Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NzQ0OTI4",
          "commit": {
            "abbreviatedOid": "ca45ea8"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T13:07:15Z",
          "updatedAt": "2020-07-08T13:07:15Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": ":+1: ",
              "createdAt": "2020-07-08T13:07:15Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0ODcxMTky",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:16:55Z",
          "updatedAt": "2020-07-08T15:16:55Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Moved to Future KEMs for now.",
              "createdAt": "2020-07-08T15:16:55Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0ODc2MzI5",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:22:30Z",
          "updatedAt": "2020-07-08T15:22:30Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I reverted all my changes related to making these functions optional, because:\r\n- For GenerateKeyPair, any KEM (and RSA too) can just write something like \u201cGenerateKeyPair is defined as in [reference]\u201d and fullfil the requirement easily like this.\r\n- DeriveKeyPair(ikm): here, I see two possibilities:\r\n  * any KEM (and also RSA) could just pass a complete keypair `sk, pk` to the function and let the function be the identity function\r\n  * any KEM (and also RSA) could pass whatever encoding of a complete keypair to the function and let the function be the deserialization of this encoding.\r\n\r\nDo we need to mention this in the document?",
              "createdAt": "2020-07-08T15:22:30Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTA0NjYx",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:53:54Z",
          "updatedAt": "2020-07-08T15:53:54Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "Eh... maybe? Or inline here?",
              "createdAt": "2020-07-08T15:53:54Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTA0ODkz",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:54:08Z",
          "updatedAt": "2020-07-08T15:54:08Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-07-08T15:54:08Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0OTA1NTM0",
          "commit": {
            "abbreviatedOid": "c79a5da"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T15:54:48Z",
          "updatedAt": "2020-07-08T15:54:49Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I don't think it's necessary. Thanks!",
              "createdAt": "2020-07-08T15:54:48Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2Nzk5NDc5",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-11T12:26:19Z",
          "updatedAt": "2020-07-11T12:31:56Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "This feels out of place in this section. Perhaps this should go underneath the KEM interface description? (That is, right below the list of functions.)",
              "createdAt": "2020-07-11T12:26:19Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 229,
              "body": "To clarify: does DHKEM achieve this notion?",
              "createdAt": "2020-07-11T12:27:40Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 230,
              "body": "I might remove this. I can't see a case where KCI resistance would not be desirable.",
              "createdAt": "2020-07-11T12:28:23Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 99,
              "body": "Some of these list items have a terminating period, and others don't. Can we add periods to all list items (here and above)?",
              "createdAt": "2020-07-11T12:29:46Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 19,
              "body": "I'm dubious about referencing signcryption... as I understand it, this is far more nascent than the other foundational work we cite.",
              "createdAt": "2020-07-11T12:31:56Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2Nzk5ODE2",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM modulo some nits!",
          "createdAt": "2020-07-11T12:32:05Z",
          "updatedAt": "2020-07-11T12:32:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODA5MDE5",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-11T15:15:41Z",
          "updatedAt": "2020-07-11T15:15:41Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "DHKEM is not \u201cmulti-user insider strongly unforgeable (sUF-CMA-secure)\u201d because of KCI.",
              "createdAt": "2020-07-11T15:15:41Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODA5MDIy",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-11T15:15:45Z",
          "updatedAt": "2020-07-11T15:15:45Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "True, but at the same time, DHKEM is not resistant against KCI and thus falls into this category (that's why I added this sentence).",
              "createdAt": "2020-07-11T15:15:45Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODA5MDI3",
          "commit": {
            "abbreviatedOid": "2ccc436"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-11T15:15:48Z",
          "updatedAt": "2020-07-11T15:15:48Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "It is right that it there is a lot of movement in the field of signcryption. That is part of the reason why notions adapted to HPKE are in the works. I'll inline the notions, then we see if this looks alright.",
              "createdAt": "2020-07-11T15:15:48Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzMwOTk0",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-13T14:57:39Z",
          "updatedAt": "2020-07-13T14:57:39Z",
          "comments": [
            {
              "originalPosition": 230,
              "body": "Doh, right, yes. Thanks!",
              "createdAt": "2020-07-13T14:57:39Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MTk2NzIz",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T17:53:08Z",
          "updatedAt": "2020-07-15T18:02:57Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "It seems like we can take a simpler approach here.  The only things **required by this document** are: `SerializePublicKey`, `Encap`, and `Decap`.  `Encap` is already supposed to produce a fixed-length encapsulated value, and `Decap` to consume it, so there is no need for separate serialization.  `DeserializePublickey` should just be deleted, since it's not used in this document.",
              "createdAt": "2020-07-15T17:53:09Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 88,
              "body": "Disagree with this change.  Making these values \"maximum\" implies that the fields they describe are variable-length, but `SerializePublicKey` and `Encap` both produce fixed-size values.  \r\n\r\nIf we do in fact need to have variable-length values, that will complicate encoding, so it would be preferable to keep things fixed.",
              "createdAt": "2020-07-15T17:55:17Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 124,
              "body": "This might depend on implementation details as well.",
              "createdAt": "2020-07-15T17:56:19Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 150,
              "body": "If you are going to name the errors above, name them here as well.  I would prefer to name them neither place, to be honest.",
              "createdAt": "2020-07-15T17:57:24Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 238,
              "body": "Having multiple different equivalent encodings seems like a bad idea.   Why are we accommodating this?",
              "createdAt": "2020-07-15T18:00:50Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 261,
              "body": "\"There are indications\" is quite vague.  What indications?\r\n\r\nOr do you mean \"the following criteria are sufficient to meet HPKE's security needs\"?",
              "createdAt": "2020-07-15T18:02:39Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjA3MTA1",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T18:05:39Z",
          "updatedAt": "2020-07-15T18:05:39Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "This change takes the complexity hit so that future documents don't need to. If we don't want this complexity, then I concur with the simplification above. (I don't think it's much complexity, so I'm OK adding it here.)",
              "createdAt": "2020-07-15T18:05:39Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjA3NTY2",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T18:06:15Z",
          "updatedAt": "2020-07-15T18:06:16Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "> Disagree with this change. Making these values \"maximum\" implies that the fields they describe are variable-length, but SerializePublicKey and Encap both produce fixed-size values.\r\n\r\nThat's correct -- they *may* be variable length for future KEMs. ",
              "createdAt": "2020-07-15T18:06:15Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjA3NjQy",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T18:06:21Z",
          "updatedAt": "2020-07-15T18:06:21Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "\ud83d\udc4d ",
              "createdAt": "2020-07-15T18:06:21Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjIxODkw",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T18:26:28Z",
          "updatedAt": "2020-07-15T18:26:28Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "I think this is just a presentation issue. It may be the case that future KEMs output encapsulated keys with non-fixed-length. So we can either (a) require that those KEMs normalize on a fixed length, or (b) acknowledge that they may be variable length here, right?",
              "createdAt": "2020-07-15T18:26:28Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjUwNjcz",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-15T19:06:40Z",
          "updatedAt": "2020-07-15T19:06:40Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "Yes, it basically means \"the following criteria are sufficient to meet HPKE's security needs\". However, there is no proof yet that these criteria are actually sufficient for HPKE. Hence \u201cindications\u201d.\r\n\r\nIn Section \u201cSecurity Considerations\u201d we already have the formulation \u201cThe results from {{CS01}} provide some indication that any IND-CCA2-secure KEM will suffice here, but are not conclusive given the differences in the schemes.\u201d; that is from where I borrowed \u201cthere are indications\u201d.\r\n\r\nThese indications come from `CS01` and `SigncryptionDZ10`, as listed in the list elements.\r\n\r\nWould it be better already if we said \u201c{{CS01}} and {{SigncryptionDZ10}} provide some indications that the following criteria are sufficient to meet HPKE's security needs\u201d?",
              "createdAt": "2020-07-15T19:06:40Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODU5MjYy",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T13:42:19Z",
          "updatedAt": "2020-07-16T13:42:20Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I like the simpler approach. I was not happy about the clutter I introduced with the other (De)Serialize functions.",
              "createdAt": "2020-07-16T13:42:20Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODY2NDY4",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T13:49:56Z",
          "updatedAt": "2020-07-16T13:49:57Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Also, while it has been pointed out to us that there is a post-quantum KEM that provides different encodings for public keys, nobody told us about a KEM with different encodings for encapsulated keys, so this was just an idea that theoretically this could be the case. I did not have time yet to look at all the post-quantum KEM proposals.\r\n\r\nAnyway, all this to say that I am fine with dropping this explicit definitions.",
              "createdAt": "2020-07-16T13:49:56Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODgwNzQ3",
          "commit": {
            "abbreviatedOid": "159db08"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T14:04:25Z",
          "updatedAt": "2020-07-16T14:04:26Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "The above error names vanished now except the errors from Seal and Open. Do you want to remove those names as well? We are using them in the pseudo code, so I guess not?",
              "createdAt": "2020-07-16T14:04:25Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODg5Nzcz",
          "commit": {
            "abbreviatedOid": "d39bacb"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T14:13:34Z",
          "updatedAt": "2020-07-16T14:13:35Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "We are accommodating this because of this review comment we got (https://github.com/cfrg/draft-irtf-cfrg-hpke/issues/84):\r\n\r\n```\r\nAssumptions about the length of the public key. It may not always be a\r\nfixed value, \"Npk\", for a KEM with a given set of parameters. The other\r\n(and unrelated) \"hybrid\" draft, draft-ietf-tls-hybrid-design, Section 3.2,\r\nmakes accommodation for public keys associated with a given set of\r\nparameters to vary in size.\r\n```\r\n\r\nHere is a quote from Section 3.2 from https://tools.ietf.org/html/draft-ietf-tls-hybrid-design-00\r\n```\r\nfor example, the SIKE key encapsulation mechanism permits\r\ncompressed or uncompressed public keys at each security level, and\r\nthe compressed and uncompressed formats are interoperable.\r\n```",
              "createdAt": "2020-07-16T14:13:34Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODkyMTIz",
          "commit": {
            "abbreviatedOid": "d39bacb"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-16T14:15:55Z",
          "updatedAt": "2020-07-16T14:15:56Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "I have no strong opinion on if we should require that those KEMs normalize on a fixed length or if we should just acknowledge the variable lengths. It might be beneficial to leave more freedom to future KEMs. I agree though that the current \u201cmaximum length\u201d formulations seem a bit messy.",
              "createdAt": "2020-07-16T14:15:55Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzM1MjY1",
          "commit": {
            "abbreviatedOid": "d335edc"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T18:59:00Z",
          "updatedAt": "2020-10-05T18:59:00Z",
          "comments": [
            {
              "originalPosition": 224,
              "body": "Signing only the KEM ciphertext would not solve the problem pointed out by the generic attack from ABHKLR20.",
              "createdAt": "2020-10-05T18:59:00Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMzM3NzYy",
          "commit": {
            "abbreviatedOid": "d335edc"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-05T19:02:22Z",
          "updatedAt": "2020-10-05T19:02:22Z",
          "comments": [
            {
              "originalPosition": 203,
              "body": "I removed this, because IND-CCA2 is not well-defined for the authenticated modes. ABHKLR20 uses different names (Outsider-CCA and Insider-CCA), so we could add them here, but there is no security notions for the PSK yet.",
              "createdAt": "2020-10-05T19:02:22Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwOTkxMjk2",
          "commit": {
            "abbreviatedOid": "2cd0b8d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks again, @blipp! I think this looks good. \r\n\r\n@bifurcation, please review so we can land this before 06.",
          "createdAt": "2020-10-17T14:53:18Z",
          "updatedAt": "2020-10-17T15:09:35Z",
          "comments": [
            {
              "originalPosition": 188,
              "body": "```suggestion\r\nAuth and AuthPSK modes are supported.\r\n```",
              "createdAt": "2020-10-17T14:53:18Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 218,
              "body": "```suggestion\r\nThe DHKEM variants defined in this document are\r\n```",
              "createdAt": "2020-10-17T14:56:03Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 233,
              "body": "```suggestion\r\nAs shown by {{ABHKLR20}}, key-compromise impersonation attacks are possible\r\nbecause KEM ciphertexts are not bound to HPKE messages. An adversary who \r\nknows a recipients private key, can decapsulate an observed KEM ciphertext, \r\ncompute the key schedule, and encrypt an arbitrary message that the recipient \r\nwill accept as coming from the original sender. Importantly, this is possible even \r\nwith a KEM that is resistant to key-compromise impersonation attacks. As a\r\nresult, mitigating this issue requires fundamental changes that are out-of-scope \r\nof this specification.\r\n```",
              "createdAt": "2020-10-17T14:58:43Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 242,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-10-17T14:59:23Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 239,
              "body": "Can we be more precise here? What specifically is \"HPKE message\"? Is it the tuple (enc, ciphertext), where ciphertext is application data encrypted under the HPKE-derived key?",
              "createdAt": "2020-10-17T15:00:53Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 316,
              "body": "```suggestion\r\nFurther, {{ABHKLR20}} proves composition theorems, showing that HPKE's\r\n```",
              "createdAt": "2020-10-17T15:02:28Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 322,
              "body": "```suggestion\r\nargument is the key, respectively. The assumption for the AEAD is\r\n```",
              "createdAt": "2020-10-17T15:03:01Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 358,
              "body": "I think this much is clear!\r\n\r\n```suggestion\r\nauthenticated KEM, guarantee the post-quantum security of HPKE's Auth mode.\r\n```",
              "createdAt": "2020-10-17T15:04:51Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 374,
              "body": "```suggestion\r\nThis means, for instance, that it would not be sufficient if the KEM\r\nshared secret is only uniformly random as an element of some set prior\r\nto its encoding as byte string.\r\n```",
              "createdAt": "2020-10-17T15:05:47Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjc2NTQw",
          "commit": {
            "abbreviatedOid": "2cd0b8d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T03:14:29Z",
          "updatedAt": "2020-10-21T03:14:29Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "```suggestion\r\nA KEM algorithm may support different encoding algorithms, with different output\r\nlengths, for KEM public keys. Such KEM algorithms MUST specify only one encoding\r\nalgorithm whose output length is `Npk`.\r\n```",
              "createdAt": "2020-10-21T03:14:29Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjc2NTkz",
          "commit": {
            "abbreviatedOid": "2cd0b8d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T03:14:39Z",
          "updatedAt": "2020-10-21T03:14:40Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "```suggestion\r\n  - `Npk`: The length in bytes of an encoded public key for this KEM\r\n```",
              "createdAt": "2020-10-21T03:14:40Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjc2Njcy",
          "commit": {
            "abbreviatedOid": "2cd0b8d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-21T03:14:55Z",
          "updatedAt": "2020-10-21T03:14:56Z",
          "comments": [
            {
              "originalPosition": 427,
              "body": "```suggestion\r\n* Npk: The length in bytes of an encoded public key for the algorithm\r\n```",
              "createdAt": "2020-10-21T03:14:55Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODExMDg0",
          "commit": {
            "abbreviatedOid": "45c2126"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple minor things, otherwise LGTM",
          "createdAt": "2020-10-22T14:47:18Z",
          "updatedAt": "2020-10-22T14:55:17Z",
          "comments": [
            {
              "originalPosition": 214,
              "body": "Should we add a column to the registry to reflect this?",
              "createdAt": "2020-10-22T14:47:19Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            },
            {
              "originalPosition": 252,
              "body": "```suggestion\r\nknows a recipient's private key can decapsulate an observed KEM ciphertext,\r\n```",
              "createdAt": "2020-10-22T14:47:57Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODc5OTY4",
          "commit": {
            "abbreviatedOid": "ec4606e"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T15:53:49Z",
          "updatedAt": "2020-10-22T15:53:49Z",
          "comments": [
            {
              "originalPosition": 214,
              "body": "I think this could be a good idea. I drafted one with the most recent commit.",
              "createdAt": "2020-10-22T15:53:49Z",
              "updatedAt": "2020-10-22T17:10:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0OTUzNjI4",
          "commit": {
            "abbreviatedOid": "28b4d35"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-22T17:18:55Z",
          "updatedAt": "2020-10-22T17:18:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 132,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTU0MDkw",
      "title": "Update test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/132",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @blipp, @rozbb, @dmcardle",
      "createdAt": "2020-07-10T17:20:10Z",
      "updatedAt": "2020-07-10T17:23:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "1c7c34dbbb4be02331d2cf77ecef4e06361c7ccd",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/update-vectors",
      "headRefOid": "567c64ea3a0a37950dbec88fdfbae894556de2be",
      "closedAt": "2020-07-10T17:23:00Z",
      "mergedAt": "2020-07-10T17:23:00Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bd80662476942d7d3c906a45a35d1e9700f5403b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 133,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NjA3Njg3",
      "title": "Removed zero function; all empty strings are \"\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/133",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With the most recent changes, the only time the `zero` function appears is as `zero(0)`. I replace this with the empty string `\"\"` without explanation. Not sure if there should be explanation, or if so, where.",
      "createdAt": "2020-07-10T19:27:07Z",
      "updatedAt": "2020-07-10T19:28:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "bd80662476942d7d3c906a45a35d1e9700f5403b",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "remove-zeros",
      "headRefOid": "2f17edc8d8e6407cbdb4e88efe592cfb3e323096",
      "closedAt": "2020-07-10T19:28:18Z",
      "mergedAt": "2020-07-10T19:28:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "372b02c3dd8fbc46c01d66ac661b6eba0d4e4311"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjUxNjgy",
          "commit": {
            "abbreviatedOid": "2f17edc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-10T19:28:13Z",
          "updatedAt": "2020-07-10T19:28:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3OTI3NDI2",
      "title": "Use email address that is available long-term",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/134",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "My Inria email address will become unavailable in roughly 2 years, so I thought I'd include one that is supposed to live longer.",
      "createdAt": "2020-07-12T17:06:47Z",
      "updatedAt": "2020-07-13T14:57:02Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "372b02c3dd8fbc46c01d66ac661b6eba0d4e4311",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_mail",
      "headRefOid": "8fea37b2bb859c954ad7a0ae5e27d427d4898cb1",
      "closedAt": "2020-07-13T14:57:02Z",
      "mergedAt": "2020-07-13T14:57:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "611686e3fb0b16c7348bce41c46151cf31a10dab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzMwMzM1",
          "commit": {
            "abbreviatedOid": "8fea37b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-13T14:56:57Z",
          "updatedAt": "2020-07-13T14:56:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 135,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUwNDYzNTQ1",
      "title": "Editorial changes, clarifications, small fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/135",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Did a full pass. Lots of changes for consistency's sake.\r\n\r\nI think the definition of \"ciphersuite\" was kinda awkward. It was never defined, though, so _something_ is needed.\r\n\r\nI think the \"at most two entities\" bit here is a bit awkward, but I think it was technically wrong as it stood (we're not guaranteed that every KEM admits KCI).",
      "createdAt": "2020-07-16T19:49:12Z",
      "updatedAt": "2020-07-23T19:04:35Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "36b737c9bbfeec2e90f3113684beb33e968c863c",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "lc-editorial",
      "headRefOid": "08c7b021e33996f4ed7591d0b8cdaafa8b53266a",
      "closedAt": "2020-07-23T19:04:35Z",
      "mergedAt": "2020-07-23T19:04:35Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fc0f59bf2f8c19b1a4275e06d49cc206b2d0d583"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Important note: this breaks test vectors. In unifying the naming convention, I changed the context string \"pskID_hash\" to \"psk_id_hash\"",
          "createdAt": "2020-07-17T18:26:08Z",
          "updatedAt": "2020-07-17T18:26:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! I'll review this ASAP.",
          "createdAt": "2020-07-17T21:58:27Z",
          "updatedAt": "2020-07-17T21:58:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 138,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU1OTY2Njc5",
      "title": "Replace \"RFCXXXX\" with version-specific label.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/138",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #137.",
      "createdAt": "2020-07-23T21:41:44Z",
      "updatedAt": "2020-07-27T13:27:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d101f3bd3507c5d0fa20239d3ec855d2752c75d9",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/version-label",
      "headRefOid": "f083491fb3f605caad4883299a767a4508048203",
      "closedAt": "2020-07-27T13:27:11Z",
      "mergedAt": "2020-07-27T13:27:11Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "12388b7204c3c87f6c4e33a82085aba7196aeab7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 140,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU5MTQ2NTY4",
      "title": "Update test vectors to use the -05 label version.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/140",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "And replace \"zz\" with \"shared_secret\" to address #139.\r\n\r\ncc @davidben",
      "createdAt": "2020-07-30T12:51:57Z",
      "updatedAt": "2020-07-30T16:56:11Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "12388b7204c3c87f6c4e33a82085aba7196aeab7",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/update-vectors-2",
      "headRefOid": "68eefc8308c1d975739aee846a587a6181d6461f",
      "closedAt": "2020-07-30T16:56:10Z",
      "mergedAt": "2020-07-30T16:56:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "47ab7da225f421bc32301f3eaa5ec842ab880047"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxMTcyNDgy",
      "title": "Clarify that the output of all DH operations is the x-coordinate for NIST curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/148",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-20T18:41:08Z",
      "updatedAt": "2020-08-20T18:44:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "47ab7da225f421bc32301f3eaa5ec842ab880047",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/dh-ss",
      "headRefOid": "cf94e30034ca7746ba75b7d23ebd79c0fb1465b4",
      "closedAt": "2020-08-20T18:44:13Z",
      "mergedAt": "2020-08-20T18:44:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "66684a8842fefd7cee2a8b52624693828934f1b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODg3NjQx",
          "commit": {
            "abbreviatedOid": "cf94e30"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-20T18:44:06Z",
          "updatedAt": "2020-08-20T18:44:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxMjExMjg4",
      "title": "Apply new test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/149",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From https://github.com/cisco/go-hpke/pull/36",
      "createdAt": "2020-08-20T20:00:18Z",
      "updatedAt": "2020-08-20T20:13:28Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "66684a8842fefd7cee2a8b52624693828934f1b8",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/new-dh-vectors",
      "headRefOid": "bdcaa1de6bceca33025d844db2a31ae3afe4d542",
      "closedAt": "2020-08-20T20:13:28Z",
      "mergedAt": "2020-08-20T20:13:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "403bf8ce2385549f6e29a6fcac7bd2c5a1b0a1bf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 150,
      "id": "MDExOlB1bGxSZXF1ZXN0NDczMTQ4NjUz",
      "title": "Editorial changes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/150",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Partly based on JP's review from June.",
      "createdAt": "2020-08-25T11:49:04Z",
      "updatedAt": "2020-09-23T14:46:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "403bf8ce2385549f6e29a6fcac7bd2c5a1b0a1bf",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_editorial",
      "headRefOid": "5cd2a7b39daf9da2e273daf1cb8e9eb7116c5ab8",
      "closedAt": "2020-09-23T14:46:58Z",
      "mergedAt": "2020-09-23T14:46:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9d55cc6b41cad7f5ec30812b032c9ed2954e3507"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NzQxNzcy",
          "commit": {
            "abbreviatedOid": "5cd2a7b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-23T14:46:53Z",
          "updatedAt": "2020-09-23T14:46:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0NDgwOTU4NTc5",
      "title": "Fix circular dependency in DeriveKeyPair",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/151",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "DeriveKeyPair is a method defined on KEMs, but it's implementation uses internal HPKE methods. This isn't necessary and can create a circular dependency between KEM implementations and HPKE",
      "createdAt": "2020-09-07T01:05:56Z",
      "updatedAt": "2020-09-07T14:11:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "403bf8ce2385549f6e29a6fcac7bd2c5a1b0a1bf",
      "headRepository": "Bren2010/draft-irtf-cfrg-hpke",
      "headRefName": "brendan/2020.9.0",
      "headRefOid": "dfae1d9d2415a4b65d057f84e068437612ba0990",
      "closedAt": "2020-09-07T14:11:59Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNTgwMTQ1",
          "commit": {
            "abbreviatedOid": "dfae1d9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "The editorial changes are fine, but please revert the Expand/Extract changes in both places. We specifically chose to use the Labeled variants for domain separation, as is required by the proofs. @blipp can provide more details if needed.",
          "createdAt": "2020-09-07T14:02:47Z",
          "updatedAt": "2020-09-07T14:02:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 158,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkxODQyNjgz",
      "title": "Remove designated verifier signature section.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/158",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #142.",
      "createdAt": "2020-09-23T14:56:53Z",
      "updatedAt": "2020-09-23T15:44:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "9d55cc6b41cad7f5ec30812b032c9ed2954e3507",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/remove-dvs",
      "headRefOid": "c22154bee1f102b3c78b2e346347a5f120f5019e",
      "closedAt": "2020-09-23T15:44:59Z",
      "mergedAt": "2020-09-23T15:44:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1b54eaffda3c8bdf92da9ec5b5e60f7f4f3355ee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0ODAwOTcw",
          "commit": {
            "abbreviatedOid": "c22154b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-23T15:44:53Z",
          "updatedAt": "2020-09-23T15:44:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 159,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkyMTAxMzgw",
      "title": "Require PSKs have at least 32 bytes of entropy.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/159",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #155.\r\n\r\nNote that we *could* replace the lower bound with `Nh` rather than `32`, but I think this is a bit too conservative. We currently allow PSKs that are less than `Nh` bytes in length, so using a constant `32` is not a regression. (I do agree that it's cleaner to just use `Nh`!)\r\n\r\ncc @blipp",
      "createdAt": "2020-09-23T23:48:46Z",
      "updatedAt": "2020-09-30T23:03:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "1b54eaffda3c8bdf92da9ec5b5e60f7f4f3355ee",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/psk-lower-limit",
      "headRefOid": "e261914492e1d1a6ec579f4af2c30d9fba4610df",
      "closedAt": "2020-09-30T23:03:05Z",
      "mergedAt": "2020-09-30T23:03:05Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "24f7e3111509cd97cb83eef831117cfb370ee228"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5NzExOTk5",
          "commit": {
            "abbreviatedOid": "3fda46c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Allowing PSKs with only 32 bytes seems fine and gives more freedom to the applications using HPKE (instead of requiring `Nh` bytes, which is `>= 32` bytes for all KDFs specified in this draft, and so, would indeed make the formulations cleaner).",
          "createdAt": "2020-09-30T18:40:53Z",
          "updatedAt": "2020-09-30T22:03:04Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThe PSK MUST have at least 32 bytes of entropy and SHOULD be of length `Nh`\r\n```",
              "createdAt": "2020-09-30T18:40:53Z",
              "updatedAt": "2020-09-30T22:11:33Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nThe PSK MUST have at least 32 bytes of entropy and SHOULD be of length `Nh`\r\n```",
              "createdAt": "2020-09-30T18:41:04Z",
              "updatedAt": "2020-09-30T22:11:33Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nentropy and SHOULD be of length `Nh` bytes or longer. Using a PSK longer than\r\n```",
              "createdAt": "2020-09-30T18:41:35Z",
              "updatedAt": "2020-09-30T22:11:33Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\nThe adversary knows the KEM shared secret `shared_secret` if it knows all\r\n```",
              "createdAt": "2020-09-30T18:46:40Z",
              "updatedAt": "2020-09-30T22:11:33Z"
            },
            {
              "originalPosition": 87,
              "body": "```suggestion\r\nattacker generates an HPKE ciphertext for each value in `S`, and submits\r\n```\r\nat least for me it would be clearer with \u201cfor\u201d, that it is separate ciphertexts.",
              "createdAt": "2020-09-30T18:50:11Z",
              "updatedAt": "2020-09-30T22:11:33Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\nk, the maximum message length in blocks. The PSK MUST therefore be chosen with\r\n```\r\nAn uppercase MUST probably does not hurt here, but it would probably also be ok to leave it in lowercase because we clarify the requirements before already.",
              "createdAt": "2020-09-30T18:52:25Z",
              "updatedAt": "2020-09-30T22:11:33Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\n32 bytes but shorter than `Nh` bytes is permitted. A PSK that is longer than\r\n`Nh` bytes or that has more than `Nh` bytes of entropy, respectively, does not\r\nprovide better security than a PSK with `Nh` bytes of entropy: The\r\neffectively used value is `psk_hash`, which has maximum `Nh` bytes of\r\nentropy.\r\n```\r\n\r\nKnowing `psk_hash` is equivalent to knowing `psk`, in this protocol. If we change to\r\n`secret = LabeledExtract(shared_secret, \"secret\", psk)`,\r\nthen we should delete this part (\u201cA PSK that is longer than, \u2026\u201d): the more entropy the psk, the harder the partition oracle attack will become to recover the psk.",
              "createdAt": "2020-09-30T21:58:18Z",
              "updatedAt": "2020-09-30T22:11:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODQ5NDU3",
          "commit": {
            "abbreviatedOid": "e261914"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-30T22:14:03Z",
          "updatedAt": "2020-09-30T22:14:03Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "I don't think this is necessary, so I'll skip this one.",
              "createdAt": "2020-09-30T22:14:03Z",
              "updatedAt": "2020-09-30T22:14:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODQ5NTYw",
          "commit": {
            "abbreviatedOid": "e261914"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-30T22:14:19Z",
          "updatedAt": "2020-09-30T22:14:19Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Let's cover that in a separate PR?",
              "createdAt": "2020-09-30T22:14:19Z",
              "updatedAt": "2020-09-30T22:14:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 160,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkyMTA0MzMy",
      "title": "Add a single-shot export API.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/160",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #157.\r\n\r\nI'll add test vectors in a followup PR.\r\n\r\ncc @blipp ",
      "createdAt": "2020-09-23T23:59:42Z",
      "updatedAt": "2020-09-25T14:39:34Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "1b54eaffda3c8bdf92da9ec5b5e60f7f4f3355ee",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/single-shot-export",
      "headRefOid": "479ca4e211f747a70061d3871601b07303869548",
      "closedAt": "2020-09-25T14:39:34Z",
      "mergedAt": "2020-09-25T14:39:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d7de7723b542093379394c0bfd316a5547c86767"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NDcxNTE3",
          "commit": {
            "abbreviatedOid": "c79b150"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T14:24:30Z",
          "updatedAt": "2020-09-25T14:24:31Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nApplications may also want to derive a secret known only to a given recipient. \r\nThis section provides templates for HPKE APIs that implement stateless\r\n```",
              "createdAt": "2020-09-25T14:24:30Z",
              "updatedAt": "2020-09-25T14:24:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NDg0Nzcx",
          "commit": {
            "abbreviatedOid": "479ca4e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-25T14:39:29Z",
          "updatedAt": "2020-09-25T14:39:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1ODM3OTg3",
      "title": "Use shared_secret as salt and psk as ikm in LabeledExtract",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/162",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "**Summary**:\r\n\r\nWhile working on formal composition proofs for HPKE, a problem for applicability of the proofs in a post-quantum setting came up. Here, composition proof means a proof of HPKE assuming some general abstracted KEM.\r\n\r\nThis pull requests proposes a small change to the `KeySchedule` which resolves this proof issue and at the same time simplifies KeySchedule by removing one call to LabeledExtract. After the change, the protocol would be cryptographically cleaner, and also a tiny bit faster, and one line less to implement.\r\n\r\n**Rationale**:\r\n\r\nCurrently, the `KeySchedule` contains the following computation:\r\n\r\n```\r\nsecret = LabeledExtract(psk_hash, \"secret\", shared_secret)\r\n```\r\n\r\nFrequently, HKDF-Extract is modeled as a random oracle. However, we would like to avoid using the random oracle model in the remainder of HPKE (a.k.a. the DEM part/the non-KEM part) and instead use a standard model assumption like PRF. Then, the composition proof will much more likely stay valid in a quantum setting: someone proving once-and-for-all that some PRF is post-quantum secure seems much easier than specifically re-analyzing HPKE in a quantum random oracle model. (papers like [On Quantum Indifferentiability](https://eprint.iacr.org/2018/257.pdf) suggest that quantum random oracles are a real headache.)\r\n\r\nAs a first guess, we would like to model the Extract call as a PRF, with its second parameter `shared_secret` being the key. However, LabeledExtract prefixes `shared_secret` with some labels, let's recall the definition:\r\n\r\n```\r\ndef LabeledExtract(salt, label, ikm):\r\n  labeled_ikm = concat(\"HPKE-05 \", suite_id, label, ikm)\r\n  return Extract(salt, labeled_ikm)\r\n```\r\n\r\nThis means the value that goes into Extract as `labeled_ikm` is not from a uniformly random distribution. Thus, we cannot use a PRF assumption, because there is no uniformly random key. What's left would be a \"seedless extractor\" assumption, which only requires that there is enough entropy in the ikm. Such a seedless extractor is a pretty idealized object and thus morally very close to the random oracle assumption. Actually, the theorems justifying that HMAC is such an extractor usually use a random oracle assumption on an underlying compression function. This is unpleasant because this practically makes the HPKE composition proof rely on a random oracle assumption, which means this proof would not stay valid in a quantum setting.\r\n\r\n**The mitigation**: a mitigation would be to replace these two lines:\r\n\r\n```\r\npsk_hash = LabeledExtract(\"\", \"psk_hash\", psk)\r\nsecret = LabeledExtract(psk_hash, \"secret\", shared_secret)\r\n```\r\n\r\nby\r\n\r\n```\r\nsecret = LabeledExtract(shared_secret, \"secret\", psk)\r\n```\r\n\r\nthat resolves the issue for the proof, because: the first parameter goes directly into Extract's first parameter without prefix, and thus we could use a PRF assumption.\r\n\r\nAdditionally, we get rid of hashing `psk` to `psk_hash`:\r\n- `shared_secret` does not exceed the block size of any of the KDFs specified in the RFC (`shared_secret` is at most 64 bytes long (for SHA512), and the block size of SHA256 is 64 bytes), so we don't need the hashing step to squeeze it below the block size.\r\n- in the second parameter of Extract, there is no length restriction to `psk`\r\n\r\nThis proposed change stays a valid use case of HKDF-Extract: we want to extract the entropy from the psk, and the psk is not necessarily from a uniform distribution (as we do not require that in the draft, and it would maybe too restrictive indeed). Also, HKDF-Extract does allow to use a salt that is secret and random.\r\n\r\nFrom a more global view point: In DHKEM, we already feed the DH shared secret through a random oracle (HKDF) to achieve a uniformly random value on the bitstrings of a fixed length, so it would be cryptographically cleaner to use this property in the following (by keying a PRF with it), instead of requiring a second random oracle.",
      "createdAt": "2020-09-30T23:12:26Z",
      "updatedAt": "2020-10-01T16:27:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "24f7e3111509cd97cb83eef831117cfb370ee228",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_extract",
      "headRefOid": "d0f6937b6d00726208353564ebd9b2d5cda8ac69",
      "closedAt": "2020-10-01T16:25:17Z",
      "mergedAt": "2020-10-01T16:25:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "bc851fc335f75f14beab7a58fe6ade9a652d8d4f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> @chris-wood IIRC we had made the change to psk_hash based on some feedback that a fixed length value could be easier to handle for some implementations. Don't know if that's still applicable.\r\n\r\nI *think* that was for the `psk_id` (to avoid dynamically allocating memory for the `concat` call), and the `psk` hash was to ensure that the PSK always had the proper length when passed to `Extract` as a salt. But now it's the `ikm`, which is passed to a `concat` call inside `LabeledExtract`, so we still have to dynamically allocate memory (or at least cap the size of the PSK, which might be reasonable for an implementation to do).\r\n\r\nSince the size of `shared_secret` *should* be fixed length (for all KEMs in this document), one thing we might consider is swapping the order arguments to LabeledExtract, e.g., \r\n\r\n```\r\nsecret = LabeledExtract(psk, \"secret\", shared_secret)\r\n```\r\n\r\ninstead of this\r\n\r\n```\r\nsecret = LabeledExtract(shared_secret, \"secret\", psk)\r\n```",
          "createdAt": "2020-10-01T14:29:05Z",
          "updatedAt": "2020-10-01T14:29:05Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">     1. @chris-wood IIRC we had made the change to psk_hash based on some feedback that a fixed length value could be easier to handle for some implementations.  Don't know if that's still applicable.\r\n\r\nExtending on Chris' post on this aspect, he hit send first while I was still typing: From my cryptographic point of view, we introduced psk_hash to ensure that the first parameter of Extract is shorter than the underlying hash function's block size, which is necessary when modeling Extract as a random oracle. If we are no longer modeling _this_ Extract call as random oracle, this requirement is no longer applicable.\r\n\r\nshared_secret, as the new first parameter of Extract, has a fixed length for a fixed KEM; sizes vary between KEMs. I don't know if that's enough for implementations that need fixed length.\r\n\r\nI also recall that the fixed-size requirement was for the parameters of the concat call:\r\n\r\n```\r\nkey_schedule_context = concat(mode, psk_id_hash, info_hash)\r\n```\r\n\r\n\r\nRegarding Chris' proposal of doing\r\n```\r\nsecret = LabeledExtract(psk, \"secret\", shared_secret)\r\n```\r\nso basically just getting rid of the psk_hash: The cryptographic reasoning behind this pull request requires that shared_secret is the first parameter of LabeledExtract, otherwise it does not work. Said differently: We need the uniformly random value to be left as it is without labels. The third parameter of LabeledExtract is prefixed with labels, the first one is left alone. That's why we suggest to put shared_secret in the first parameter. shared_secret is the uniformly random value, psk just has high entropy, but is not uniformly random (and also is not there in all modes, and shared_secret is there in all modes).\r\n\r\n>     2. It's less important, but I wonder if we should revert the `psk_id_hash` and `info_hash` hashes as well.  Basically, those are trading hash invocations for `i2osp` calls and dynamic memory allocation.  (And this may be what the above-referenced review was focused on.)\r\n\r\nJust as a reminder: We are modeling Extract as a random oracle in the KEM, so we still cannot use Hash() directly.\r\n\r\nBut yes, if the fixed-size requirement is for some reason no longer applicable for the implementors who brought this up, then it would be fine for me to use a different injective encoding for the keyschedule_context. (Removed my example of `concat(mode, \"psk_id\", psk_id, \"info\", info)` because it is not injective, psk_id=\"info\", info=\"\" and psk_id=\"\", info=\"info\" result in the same bitstring)",
          "createdAt": "2020-10-01T14:38:56Z",
          "updatedAt": "2020-10-01T14:47:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp as Richard points out, this PR either requires implementations to do dynamic memory allocation, or to cap their PSK input lengths. My proposal (which I don't like for the reasons you point out) does fix that. So we have to decide whether or not we care about dynamic memory allocation in the key schedule. (My take is that it's reasonable to put a cap on the PSK length, so this isn't really a problem in practice, and we can merge your PR as-is.) @bifurcation, thoughts?",
          "createdAt": "2020-10-01T16:10:19Z",
          "updatedAt": "2020-10-01T16:10:19Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am confused, I am not sure if I understand right which non-fixed-size parts we are discussing.\r\n\r\nThe current state of the draft is\r\n\r\n```\r\n  psk_hash = LabeledExtract(\"\", \"psk_hash\", psk)\r\n\r\n  secret = LabeledExtract(psk_hash, \"secret\", shared_secret)\r\n```\r\n\r\nand this PR suggests changing to\r\n\r\n```\r\n  secret = LabeledExtract(shared_secret, \"secret\", psk)\r\n```\r\n\r\nIn both cases, the entire psk goes into the third parameter of LabeledExtract. I guess if it was fine before, it should still be fine then? Also, the calls\r\n\r\n```\r\n  psk_id_hash = LabeledExtract(\"\", \"psk_id_hash\", psk_id)\r\n  info_hash = LabeledExtract(\"\", \"info_hash\", info)\r\n```\r\n\r\nallow arbitrary bitstring inputs psk_id and info into the third parameter of LabeledExtract, and it doesn't seem that it was a problem so far.",
          "createdAt": "2020-10-01T16:19:01Z",
          "updatedAt": "2020-10-01T16:19:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, duh, right, we already lost dynamic memory allocation. So maybe we should just take Richard's suggestion and drop the additional hash for `psk_id` and `info`. ",
          "createdAt": "2020-10-01T16:21:16Z",
          "updatedAt": "2020-10-01T16:21:16Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is it maybe at least helpful for implementations that if we hash psk_id and info, then keyschedule_context is fixed-size, and so the three LabeledExpand calls do not need any dynamic memory allocation?\r\n\r\n```\r\n  key = LabeledExpand(secret, \"key\", key_schedule_context, Nk)\r\n  nonce = LabeledExpand(secret, \"nonce\", key_schedule_context, Nn)\r\n  exporter_secret = LabeledExpand(secret, \"exp\", key_schedule_context, Nh)\r\n```",
          "createdAt": "2020-10-01T16:22:52Z",
          "updatedAt": "2020-10-01T16:22:52Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "My point is that we either care about dynamic memory allocation, or we don't. I don't really see much value in making `key_schedule_context` fixed-size if we still require mallocs elsewhere. \r\n\r\nBut that said, let's just address this in a separate PR.",
          "createdAt": "2020-10-01T16:24:36Z",
          "updatedAt": "2020-10-01T16:24:36Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So this PR would change from having 3 LabeledExtract calls with dynamic memory allocation (for psk_id, info, psk) and 1 LabeledExtract call with no dynamic memory allocation, to having only 3 LabeledExtract calls but all of which are with dynamic memory allocation (for psk_id, info, psk).\r\n\r\nFor reference, it is this:\r\n```\r\n  psk_id_hash = LabeledExtract(\"\", \"psk_id_hash\", psk_id)  // dynamic\r\n  info_hash = LabeledExtract(\"\", \"info_hash\", info) // dynamic\r\n  key_schedule_context = concat(mode, psk_id_hash, info_hash) // fixed\r\n\r\n  psk_hash = LabeledExtract(\"\", \"psk_hash\", psk) // dynamic\r\n\r\n  secret = LabeledExtract(psk_hash, \"secret\", shared_secret) // fixed\r\n```\r\n\r\nvs\r\n```\r\n  psk_id_hash = LabeledExtract(\"\", \"psk_id_hash\", psk_id)  // dynamic\r\n  info_hash = LabeledExtract(\"\", \"info_hash\", info) // dynamic\r\n  key_schedule_context = concat(mode, psk_id_hash, info_hash) // fixed\r\n\r\n  secret = LabeledExtract(shared_secret, \"secret\", psk) // dynamic\r\n```\r\n\r\n\r\n> My point is that we either care about dynamic memory allocation, or we don't. I don't really see much value in making `key_schedule_context` fixed-size if we still require mallocs elsewhere.\r\n\r\nOh ok, I see \u2013 I don't have the necessary implementation experience to judge this from my side.\r\n\r\n> But that said, let's just address this in a separate PR.\r\n\r\nAgreed, thanks for merging!",
          "createdAt": "2020-10-01T16:27:37Z",
          "updatedAt": "2020-10-01T16:27:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5OTQwNzE0",
          "commit": {
            "abbreviatedOid": "d0f6937"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for writing this up, @blipp! This looks good to me. And if it helps analysis, even better.",
          "createdAt": "2020-10-01T00:32:10Z",
          "updatedAt": "2020-10-01T00:32:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwMzg2MTQx",
          "commit": {
            "abbreviatedOid": "d0f6937"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall, this looks fine to me.  Just to confirm a few minor points:\r\n\r\n1. @chris-wood IIRC we had made the change to psk_hash based on some feedback that a fixed length value could be easier to handle for some implementations.  Don't know if that's still applicable.\r\n\r\n2. It's less important, but I wonder if we should revert the `psk_id_hash` and `info_hash` hashes as well.  Basically, those are trading hash invocations for `i2osp` calls and dynamic memory allocation.  (And this may be what the above-referenced review was focused on.)",
          "createdAt": "2020-10-01T14:08:30Z",
          "updatedAt": "2020-10-01T14:08:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2ODU3MDAx",
      "title": "Add missing parameter to AuthDecap",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/163",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-20T14:35:43Z",
      "updatedAt": "2020-10-21T03:03:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "bc851fc335f75f14beab7a58fe6ade9a652d8d4f",
      "headRepository": "uhoreg/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "3ecc7b36dc9294c7af07a031632b0df1875bdc50",
      "closedAt": "2020-10-21T03:03:53Z",
      "mergedAt": "2020-10-21T03:03:53Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d7c239315247e59c2d563cb7c44c918552489e4a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMjczMzEw",
          "commit": {
            "abbreviatedOid": "3ecc7b3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Nice catch!",
          "createdAt": "2020-10-21T03:03:49Z",
          "updatedAt": "2020-10-21T03:03:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3OTA5MDM1",
      "title": "Prepare final changes for RGLC.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/164",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #152, #144, #146, #143, #141.\r\n\r\nI'll update the test vectors (and address #154 and #147) in a followup PR. \r\n\r\ncc @cjpatton (for the IV change), @davidben, @blipp, @rozbb, @fredericjacobs, @kjacobs-moz",
      "createdAt": "2020-10-21T22:56:15Z",
      "updatedAt": "2020-10-23T18:04:08Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d7c239315247e59c2d563cb7c44c918552489e4a",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/rglc-prep",
      "headRefOid": "ea70e9f7351e65d8e41dda1fb906a0719a8239bf",
      "closedAt": "2020-10-23T18:04:08Z",
      "mergedAt": "2020-10-23T18:04:07Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c05b7bada5aef346b3c2d77c0c24d0c024b16480"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzIwMzMw",
          "commit": {
            "abbreviatedOid": "66c5236"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-22T02:41:46Z",
          "updatedAt": "2020-10-22T14:38:20Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I'm OK with deprecating \"nonce\", but if we're going to do it, let's be thorough. Suggest the following wording:\r\n\r\n- `base_iv` is the thing the KDF produces\r\n- `iv` is the thing that gets fed to the AEAD\r\n\r\n```suggestion\r\n  - `Niv`: The length in bytes of an initialization vector for this algorithm\r\n```\r\n\r\n(No need to distinguish between base IV and IV here, it's OK if they just happen to be the same length.)",
              "createdAt": "2020-10-22T02:41:47Z",
              "updatedAt": "2020-10-23T00:32:36Z"
            },
            {
              "originalPosition": 154,
              "body": "Line wrapping.\r\n\r\n```suggestion\r\n~~~~~\r\nP-256:\r\n0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\r\n\r\nP-384: \r\n0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf\r\n  581a0db248b0a77aecec196accc52973\r\n\r\nP-521:\r\n0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n  fa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409\r\n~~~~~\r\n```",
              "createdAt": "2020-10-22T14:35:03Z",
              "updatedAt": "2020-10-23T00:32:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODExMzU0",
          "commit": {
            "abbreviatedOid": "66c5236"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:47:32Z",
          "updatedAt": "2020-10-22T14:47:33Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I agree that we only need one length.\r\n\r\nI am less sure about removing the word \"nonce\" completely, because the AEADs we use call it nonce. Citing from the original feedback #152, it was suggested to align with TLS: \u201cin TLS 1.3 for example, the \"nonce\" is the initialization vector XORed with a sequence number.\u201d ",
              "createdAt": "2020-10-22T14:47:32Z",
              "updatedAt": "2020-10-23T00:32:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MjA3MjMx",
          "commit": {
            "abbreviatedOid": "ea70e9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T00:33:02Z",
          "updatedAt": "2020-10-23T00:33:02Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "@bifurcation I converged on `base_nonce` and `nonce` for the KDF output and AEAD input, respectively. ",
              "createdAt": "2020-10-23T00:33:02Z",
              "updatedAt": "2020-10-23T00:33:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MjYyNTI3",
          "commit": {
            "abbreviatedOid": "ea70e9f"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T04:09:12Z",
          "updatedAt": "2020-10-23T04:09:12Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "In a new PR I use `order` one or two more times in different sections. This brings up the question of where, if anywhere, to include these constants. How important is it that these be here?",
              "createdAt": "2020-10-23T04:09:12Z",
              "updatedAt": "2020-10-23T04:09:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzQ1MzA2",
          "commit": {
            "abbreviatedOid": "ea70e9f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T14:55:12Z",
          "updatedAt": "2020-10-23T14:55:13Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "I think it's fine to keep them here (for now). We can move them around if needed as a future editorial nit.",
              "createdAt": "2020-10-23T14:55:12Z",
              "updatedAt": "2020-10-23T14:55:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODkxNjI0",
          "commit": {
            "abbreviatedOid": "ea70e9f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T18:03:56Z",
          "updatedAt": "2020-10-23T18:03:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 165,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3OTg1OTA0",
      "title": "Implemented SerializeSk/DeserializeSk",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/165",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "# Rationale\r\n\r\nI'm sorry for pushing this harder, but hear me out: this is better than the current workaround, which is making users carry the IKM they seeded their `DeriveKeyPair()` with.\r\n\r\n1. If a user literally ever uses `GenerateKeyPair()`, or uses `DeriveKeyPair()` and fails to save their IKM for any reason, they are badly and unnecessarily inconvenienced. They can continue to use their secret key for as long as their program runs, but they have no way to save the state of their own program.\r\n2. Ok, maybe a library anticipates this and decides to carry the IKM along with the secret key, or maybe it decides to expose some serialize/deserialize functionality that's compatible with everyone else using that library. Then great for that library! But should have something that _all_ libraries are guaranteed to do.\r\n3. This functionality is already implemented and exposed by `go-hpke` and `rust-hpke`, minus some validation checks.\r\n\r\nTo reiterate a point in 1, because I think it's a weird consequence of the current API: **if you use `GenerateKeyPair()`, you have no way to save your keypair.**\r\n\r\n# Specifics\r\n\r\n* I changed \"secret key\" to \"private key\" for consistency and because the latter is by far the more common term\r\n* I made the `SerializeSk()` routines canonicalize their outputs because 1. it's easy, and 2. users might have some unfounded expectations about equality of secret keys (\"I'll just check if this secret key is in my local database by doing a bytestring equality test\"). Canonicalizing makes these expectations true.\r\n* Aside for the purpose of canonicalization, I made the P-curve privkey serialization routine do a reduction mod `order` because SECG explicitly assumes that the secret key is an integer in the range `[0, order-1]`, but the HPKE spec makes no such assertion about P-curve privkeys\r\n* I made 0 an invalid secret key because there's literally no valid way to use a 0 secret key. Any DH op you do will produce the point at infinity, which MUST be treated as an error. So we may as well catch it as early as possible for easier debugging",
      "createdAt": "2020-10-22T03:25:27Z",
      "updatedAt": "2020-10-23T18:02:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "2bc1482f8c98ed698f8c8f57e4162691fc2d4d54",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "serializesk",
      "headRefOid": "8badd0ffa9c45abc91041b530017bd1b4ad6c03a",
      "closedAt": "2020-10-23T18:02:10Z",
      "mergedAt": "2020-10-23T18:02:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9a9bdcb07dff52c64003f0635f56f379fe090e1f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb thanks! Since the API is not strictly needed for the protocol, and really only helpful for implementations, can we remove `SerializeSk` from the KEM interface and just specify it in an appendix (as you've done)? (We should also then revert the `SerializePk` name change, too.)",
          "createdAt": "2020-10-22T15:47:21Z",
          "updatedAt": "2020-10-22T15:47:35Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed. Should be a bit cleaner now",
          "createdAt": "2020-10-23T03:42:17Z",
          "updatedAt": "2020-10-23T03:42:17Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb I renamed the functions to align with `SerializePublicKey`. I'll tidy up the `order` references after this lands. @bifurcation, please have a look!",
          "createdAt": "2020-10-23T15:00:23Z",
          "updatedAt": "2020-10-23T15:00:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzQxNjQx",
          "commit": {
            "abbreviatedOid": "6a0ae76"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T14:51:18Z",
          "updatedAt": "2020-10-23T14:58:21Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n- `SerializePrivateKey(sk)`: Produce a byte string of length `Nsk` encoding the private\r\n```",
              "createdAt": "2020-10-23T14:51:18Z",
              "updatedAt": "2020-10-23T14:59:37Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n- `DeserializePrivateKey(enc)`: Parse a byte string of length `Nsk` to recover a\r\n```",
              "createdAt": "2020-10-23T14:51:25Z",
              "updatedAt": "2020-10-23T14:59:37Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\n### SerializePrivateKey/DeserializePrivateKey {#serialize-sk}\r\n```",
              "createdAt": "2020-10-23T14:51:52Z",
              "updatedAt": "2020-10-23T14:59:37Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nFor P-256, P-384 and P-521, the `SerializePrivateKey()` function of the KEM performs\r\n```",
              "createdAt": "2020-10-23T14:52:09Z",
              "updatedAt": "2020-10-23T14:59:37Z"
            },
            {
              "originalPosition": 45,
              "body": "```suggestion\r\nfound in section D.1.2 of {{NISTCurves}}. `DeserializePrivateKey()` performs the\r\n```",
              "createdAt": "2020-10-23T14:52:21Z",
              "updatedAt": "2020-10-23T14:59:37Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nrepresentation, so little processing has to be done. The `SerializePrivateKey()`\r\n```",
              "createdAt": "2020-10-23T14:52:29Z",
              "updatedAt": "2020-10-23T14:59:37Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\n`DeserializePrivateKey()` function is the identity function.\r\n```",
              "createdAt": "2020-10-23T14:52:39Z",
              "updatedAt": "2020-10-23T14:59:37Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nFor P-256, P-384 and P-521, `DeserializePrivateKey()` MUST check that the given integer\r\n```",
              "createdAt": "2020-10-23T14:52:47Z",
              "updatedAt": "2020-10-23T14:59:37Z"
            },
            {
              "originalPosition": 72,
              "body": "```suggestion\r\nFor X25519 and X448, `DeserializePrivateKey()` MUST check that the given integer, after\r\n```",
              "createdAt": "2020-10-23T14:52:56Z",
              "updatedAt": "2020-10-23T14:59:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODg5ODU5",
          "commit": {
            "abbreviatedOid": "8badd0f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T18:01:18Z",
          "updatedAt": "2020-10-23T18:01:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA4OTEzMjA1",
      "title": "Add plaintext length hiding to non-goals",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/166",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addressing this email on the CFRG ml https://mailarchive.ietf.org/arch/msg/cfrg/67D-qlKwuGsGY_H_ImGoTWnGjnM/\r\n\r\nAlso, fixing two problems with the build I had at least locally:\r\n- apparently it's not ok to cite two references in one `{{\u2026}}`\r\n- apparently it's not ok to have code/typewriter text in section headings",
      "createdAt": "2020-10-23T11:49:40Z",
      "updatedAt": "2020-10-23T14:50:36Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "2bc1482f8c98ed698f8c8f57e4162691fc2d4d54",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_length",
      "headRefOid": "6b617d8f0bc2fda470e22d211f73b8419571c233",
      "closedAt": "2020-10-23T14:50:36Z",
      "mergedAt": "2020-10-23T14:50:36Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b5525046de9c01da373f3163865b4c6444f00cbf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NzQwNDAx",
          "commit": {
            "abbreviatedOid": "6d16959"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T14:49:59Z",
          "updatedAt": "2020-10-23T14:50:19Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n* Hiding plaintext length - AEAD ciphertexts produced by HPKE do not\r\n  hide the plaintext length. Applications requiring this level of\r\n  privacy should use a suitable padding mechanism. See\r\n  {{?I-D.ietf-tls-esni}} and {{?RFC8467}} for examples of protocol-specific\r\n  padding policies.\r\n```",
              "createdAt": "2020-10-23T14:49:59Z",
              "updatedAt": "2020-10-23T14:50:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5MjIwNjc3",
      "title": "Recompute input length restrictions",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/167",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We reduced `size_label_rfcXXXX` by one.\r\n\r\nSince last time the limits were computed,\r\n- we changed `pskID_hash` to `psk_id_hash`, which is why the limits do not change for `info`.\r\n- `psk` is now used with label `secret` and not `psk_hash` anymore. Apparently I made an error last time, too, because I cannot explain why the limits were 89, 153 and 153. Now, I made a fresh computation using a spreadsheet and not my brain to compute sums, so it should be fine now.",
      "createdAt": "2020-10-23T21:15:20Z",
      "updatedAt": "2020-10-23T22:44:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c05b7bada5aef346b3c2d77c0c24d0c024b16480",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_input_restr",
      "headRefOid": "b58daff40b2d7a09abac2ce10cf023e48c0b7d3e",
      "closedAt": "2020-10-23T22:44:09Z",
      "mergedAt": "2020-10-23T22:44:09Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "108cb6d020df307af3c90aa25b0d11125ab866a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5MjQ3ODM5",
      "title": "Weakened privkey validation requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/168",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Turns out checking `sk.is_zero()` in curve25519/curve448 is not always easy",
      "createdAt": "2020-10-23T22:40:41Z",
      "updatedAt": "2020-10-23T22:44:27Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c05b7bada5aef346b3c2d77c0c24d0c024b16480",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "serializesk-tweaks",
      "headRefOid": "26ddf075b9fce684df6859f0991522bce6911c49",
      "closedAt": "2020-10-23T22:44:27Z",
      "mergedAt": "2020-10-23T22:44:27Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4e4f2f813a7d60a25a27b05536b5805d175c4db2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDQ2ODc1",
          "commit": {
            "abbreviatedOid": "26ddf07"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T22:41:35Z",
          "updatedAt": "2020-10-23T22:41:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDQ3MzM5",
          "commit": {
            "abbreviatedOid": "26ddf07"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T22:43:10Z",
          "updatedAt": "2020-10-23T22:43:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA5MjU1ODcz",
      "title": "Apply final (?) test vectors.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/169",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-23T22:48:24Z",
      "updatedAt": "2020-10-23T22:49:03Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4e4f2f813a7d60a25a27b05536b5805d175c4db2",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/final-vectors",
      "headRefOid": "797b849a53f741cb03c8030610e6ed155ef739ca",
      "closedAt": "2020-10-23T22:49:03Z",
      "mergedAt": "2020-10-23T22:49:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e7038eae3da100affaa927c019b4f9ec8e6324e4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 171,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE1NzM1MTY5",
      "title": "Add BoringSSL to implementation list",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/171",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adding BoringSSL as per #170.\r\n\r\ncc @davidben",
      "createdAt": "2020-11-05T01:39:33Z",
      "updatedAt": "2020-11-05T02:42:07Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "60bd276d48ea4797972b13dadd16fd247e990c81",
      "headRepository": "dmcardle/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "300a01e17e8f96d55e17aa98c27d6fdbbf4398bc",
      "closedAt": "2020-11-05T02:41:55Z",
      "mergedAt": "2020-11-05T02:41:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b913949eb7b80f0b8b0f02bbf988b70ae9f00393"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @dmcardle!",
          "createdAt": "2020-11-05T02:42:07Z",
          "updatedAt": "2020-11-05T02:42:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzODg2NTk5",
          "commit": {
            "abbreviatedOid": "300a01e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-05T02:41:51Z",
          "updatedAt": "2020-11-05T02:41:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 172,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE2MTkxMzE1",
      "title": "Add NSS to list of implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/172",
      "state": "MERGED",
      "author": "kjacobs-moz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adds reference to NSS implementation, per #170.",
      "createdAt": "2020-11-05T16:37:40Z",
      "updatedAt": "2020-11-05T17:05:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "b913949eb7b80f0b8b0f02bbf988b70ae9f00393",
      "headRepository": "kjacobs-moz/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "ac4d8b003f6ceab46fcc751dec2d398d84043c01",
      "closedAt": "2020-11-05T17:05:55Z",
      "mergedAt": "2020-11-05T17:05:55Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0f5baba9dafdecbe05444de6e59c005dd02c5534"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDc2NDky",
          "commit": {
            "abbreviatedOid": "ac4d8b0"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-05T17:05:50Z",
          "updatedAt": "2020-11-05T17:05:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 173,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE4NDAwNzg1",
      "title": "Add hpke-rs",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/173",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I have another implementation of HPKE in Rust on top of evercrypt/hacl* used in MLS.",
      "createdAt": "2020-11-10T10:54:43Z",
      "updatedAt": "2020-11-17T06:17:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "f80409c00b5eca904d6c7cf51b74422af61dfbef",
      "headRepository": "franziskuskiefer/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "72e63b66b96a3fab548a84a34e896f3327e9fdf0",
      "closedAt": "2020-11-17T00:54:18Z",
      "mergedAt": "2020-11-17T00:54:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c09a07085140a0368d387a4a0ffd0fa7f2f84601"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! ",
          "createdAt": "2020-11-17T00:54:14Z",
          "updatedAt": "2020-11-17T00:54:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 174,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyMDIzNDkw",
      "title": "Add happykey to list of implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/174",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-16T22:52:53Z",
      "updatedAt": "2020-11-17T00:53:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0f5baba9dafdecbe05444de6e59c005dd02c5534",
      "headRepository": "sftcd/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "1718458179c170afecd221e44ed9788bf6516799",
      "closedAt": "2020-11-17T00:53:38Z",
      "mergedAt": "2020-11-17T00:53:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f80409c00b5eca904d6c7cf51b74422af61dfbef"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxOTQxMjU3",
          "commit": {
            "abbreviatedOid": "1718458"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks! \ud83d\udcaf ",
          "createdAt": "2020-11-17T00:53:34Z",
          "updatedAt": "2020-11-17T00:53:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI0MDE3NjUz",
      "title": "Update README.md",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/175",
      "state": "MERGED",
      "author": "danharkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Please add hpke-wrap to the list of implementations\r\n",
      "createdAt": "2020-11-19T15:02:42Z",
      "updatedAt": "2020-11-20T06:40:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c09a07085140a0368d387a4a0ffd0fa7f2f84601",
      "headRepository": "danharkins/draft-irtf-cfrg-hpke",
      "headRefName": "danharkins/hpke-hash",
      "headRefOid": "c31ef6cc708e85e1b5d192c2049ab986239839ae",
      "closedAt": "2020-11-20T06:40:44Z",
      "mergedAt": "2020-11-20T06:40:44Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3bb167263c4775a7cd7a0f7905b11f9d8d1527db"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1MTQ5MDAy",
          "commit": {
            "abbreviatedOid": "c31ef6c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-20T06:40:39Z",
          "updatedAt": "2020-11-20T06:40:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 177,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI4ODIzMzA2",
      "title": "Added some clarification to validation things",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/177",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Nothing big here",
      "createdAt": "2020-11-28T00:45:52Z",
      "updatedAt": "2020-12-01T17:37:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3bb167263c4775a7cd7a0f7905b11f9d8d1527db",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "validation-tweaks",
      "headRefOid": "58d42515a8f254cb80426a2b8142bd0706ce0962",
      "closedAt": "2020-12-01T17:37:52Z",
      "mergedAt": "2020-12-01T17:37:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f0d5e93b9cf33107b9b305d033afa7636f5be883"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMTQwODEz",
          "commit": {
            "abbreviatedOid": "2856194"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-01T17:36:44Z",
          "updatedAt": "2020-12-01T17:37:34Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n  byte strings in big-endian byte order.\r\n```",
              "createdAt": "2020-12-01T17:36:45Z",
              "updatedAt": "2020-12-01T17:37:47Z"
            },
            {
              "originalPosition": 16,
              "body": "```suggestion\r\nAs per {{SECG}}, P-256, P-384, and P-521 private keys are field elements in the\r\n```",
              "createdAt": "2020-12-01T17:36:59Z",
              "updatedAt": "2020-12-01T17:37:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 178,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwNDA2MjUx",
      "title": "Fix editorial issues based on Stanislav's feedback",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/178",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also, fix idnit issues outside of the test vectors.\r\n\r\ncc @blipp ",
      "createdAt": "2020-12-01T16:00:11Z",
      "updatedAt": "2020-12-02T15:10:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "58761fae29f35a719a7419e886b5256294a3d752",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/stanislav-nits",
      "headRefOid": "513b99b487cff419f7e96d6f10c4332815fbe75b",
      "closedAt": "2020-12-02T15:10:31Z",
      "mergedAt": "2020-12-02T15:10:31Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a7a331895564c9517fb8a9be42e40b3a98019188"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODE5NjM1",
          "commit": {
            "abbreviatedOid": "79da759"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-02T13:12:15Z",
          "updatedAt": "2020-12-02T13:12:15Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "Good catch!",
              "createdAt": "2020-12-02T13:12:15Z",
              "updatedAt": "2020-12-02T14:34:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODE5OTEz",
          "commit": {
            "abbreviatedOid": "79da759"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-02T13:12:37Z",
          "updatedAt": "2020-12-02T13:12:37Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "```suggestion\r\nJo\u00ebl Alwen,\r\n```",
              "createdAt": "2020-12-02T13:12:37Z",
              "updatedAt": "2020-12-02T14:34:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODIxNTU0",
          "commit": {
            "abbreviatedOid": "79da759"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-02T13:14:41Z",
          "updatedAt": "2020-12-02T13:14:41Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "I'd like to add\r\n```\r\nBruno Blanchet,\r\nEduard Hauck,\r\nDoreen Riepel,\r\n```\r\nCould you please add them to this PR? :) (at the right spot according to alphabetic order)",
              "createdAt": "2020-12-02T13:14:41Z",
              "updatedAt": "2020-12-02T14:34:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODk0MjAz",
          "commit": {
            "abbreviatedOid": "a4b51f3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-02T14:33:41Z",
          "updatedAt": "2020-12-02T14:33:41Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "Done!",
              "createdAt": "2020-12-02T14:33:41Z",
              "updatedAt": "2020-12-02T14:34:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyOTMzMTc4",
          "commit": {
            "abbreviatedOid": "513b99b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-02T15:10:26Z",
          "updatedAt": "2020-12-02T15:10:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 179,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwNDY3NDAy",
      "title": "Add DeserializePublicKey to match SerializePublicKey.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/179",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #176.\r\n\r\ncc @blipp ",
      "createdAt": "2020-12-01T17:40:01Z",
      "updatedAt": "2020-12-02T14:29:26Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "f0d5e93b9cf33107b9b305d033afa7636f5be883",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/add-deserialize-public-key",
      "headRefOid": "941ebc3f0075669d089963069edf260c8bb11f38",
      "closedAt": "2020-12-02T14:29:26Z",
      "mergedAt": "2020-12-02T14:29:26Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1a25ab6c0a882695c5ac99e6f2241b2792c826ae"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODE4MDYw",
          "commit": {
            "abbreviatedOid": "39a3314"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-02T13:10:21Z",
          "updatedAt": "2020-12-02T13:10:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n  - `DeserializePublicKey(pkXm)`: Parse a byte string of length `Npk` to recover a\r\n    public key. This function can raise a `DeserializeError` error upon `pkXm`\r\n    deserialization failure.\r\n```\r\n\r\n`enc` is used to denote an encapsulation of a KEM shared secret. Here we're talking about a public key. (An not in all KEMs is `enc` a serialized (ephemeral) public key.) In DHKEM we add `m` to denote a serialized value, so we could do the same here. Although `m` comes from the time when we still used \u201cMarshal\u201d instead of \u201cSerialize\u201d. I don't know if it's still worth to change that to a `s` for example.",
              "createdAt": "2020-12-02T13:10:21Z",
              "updatedAt": "2020-12-02T14:26:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 180,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxMDAyMTY1",
      "title": "Add link to eprint and update title",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/180",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The eprint is now public, so this PR adds a link and updates the paper's title.",
      "createdAt": "2020-12-02T13:03:17Z",
      "updatedAt": "2020-12-02T14:29:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "f0d5e93b9cf33107b9b305d033afa7636f5be883",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_paper",
      "headRefOid": "3e871cd3bbaf61674638808005796693e9fb085d",
      "closedAt": "2020-12-02T14:29:43Z",
      "mergedAt": "2020-12-02T14:29:43Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "58761fae29f35a719a7419e886b5256294a3d752"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODkwMDA1",
          "commit": {
            "abbreviatedOid": "3e871cd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-02T14:29:39Z",
          "updatedAt": "2020-12-02T14:29:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 181,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxMDE4MzM1",
      "title": "Two more editorial fixes",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/181",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-02T13:30:35Z",
      "updatedAt": "2020-12-02T14:25:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "f0d5e93b9cf33107b9b305d033afa7636f5be883",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "stanislav_feedback",
      "headRefOid": "d5123f6451090c27fb4f0930d5b3b5759f7d5b22",
      "closedAt": "2020-12-02T14:25:52Z",
      "mergedAt": "2020-12-02T14:25:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c555dd80664a088005ade4d86b13db9fd5100f5c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODg1NjY0",
          "commit": {
            "abbreviatedOid": "8457690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-02T14:25:22Z",
          "updatedAt": "2020-12-02T14:25:23Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n  key `skX`.\r\n```",
              "createdAt": "2020-12-02T14:25:22Z",
              "updatedAt": "2020-12-02T14:25:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyODg2MDY3",
          "commit": {
            "abbreviatedOid": "8457690"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-02T14:25:45Z",
          "updatedAt": "2020-12-02T14:25:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 182,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxOTg5NTEw",
      "title": "DNH: changes to support compact representation for NIST curves",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/182",
      "state": "CLOSED",
      "author": "danharkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi, I brought this up on the cfrg list and it kind of died so I figured I'd give you an idea of what I'm talking about. Please see the proposed changes. Basically, the change is that for the NIST curves the encapsulated public key is just the x-coordinate. That's what gets produced by Serialize() and that's what Deserialize() expects. As a result Nenc seemed kind of unnecessary so I got rid of it.\r\n\r\nI implemented this and the Diffie-Hellman shared secrets matched (as they should) but the kem_context is different so everything derived from the Diffie-Hellman secret is different. So new test vectors. Updating the test vectors is a PITA so I didn't do all of them but I will if you agree with this PR.",
      "createdAt": "2020-12-03T18:30:20Z",
      "updatedAt": "2021-02-16T16:47:05Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a7a331895564c9517fb8a9be42e40b3a98019188",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "4d6a9f6e5b6f3b8dea6ac9ab44bf057c462f55b1",
      "closedAt": "2021-02-16T16:47:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing with the resolution to use a new KEM for compact point representations.",
          "createdAt": "2021-02-16T16:47:05Z",
          "updatedAt": "2021-02-16T16:47:05Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 183,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM0Mjc0ODE5",
      "title": "Automatic spell and grammar check",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/183",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I ran https://languagetool.org/ over the text.\r\n\r\n`widely used`: https://www.grammar.com/compound-adjectives/\r\n\r\n[`implementers`](https://www.google.com/search?hl=en&q=implementer+site%3Aietf.org) seems to be used more in IETF documents than [`implementors`](https://www.google.com/search?hl=en&q=implementor+site%3Aietf.org).",
      "createdAt": "2020-12-08T08:36:43Z",
      "updatedAt": "2020-12-08T23:47:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a7a331895564c9517fb8a9be42e40b3a98019188",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_spell_grammar",
      "headRefOid": "0c1586bd49cd0fb8e735c5ffabc12532ed76dc5f",
      "closedAt": "2020-12-08T23:47:10Z",
      "mergedAt": "2020-12-08T23:47:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cdbef9a2539d80669bc86d8719dcb8d3fa77c768"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzI4MDY1",
          "commit": {
            "abbreviatedOid": "0c1586b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-08T23:47:00Z",
          "updatedAt": "2020-12-08T23:47:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM0Mjg1Njkw",
      "title": "Add HACL* implementation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/184",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-08T08:46:48Z",
      "updatedAt": "2020-12-08T23:46:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a7a331895564c9517fb8a9be42e40b3a98019188",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_implem",
      "headRefOid": "5ed9ae7c4c2b4ee5ec413f952e599fa81be2ccb7",
      "closedAt": "2020-12-08T23:46:06Z",
      "mergedAt": "2020-12-08T23:46:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "829a6b0bad070fed8bc4e6ab7080e9ef3a04e319"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzI3NjM2",
          "commit": {
            "abbreviatedOid": "5ed9ae7"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-08T23:46:00Z",
          "updatedAt": "2020-12-08T23:46:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM0Nzk3NTA3",
      "title": "Adds CIRCL Go implementation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/186",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "go get github.com/cloudflare/circl",
      "createdAt": "2020-12-08T23:42:00Z",
      "updatedAt": "2020-12-08T23:45:43Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "a7a331895564c9517fb8a9be42e40b3a98019188",
      "headRepository": "armfazh/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "62f48839a0a12232b3b3facc255d0fbbee83a7eb",
      "closedAt": "2020-12-08T23:45:43Z",
      "mergedAt": "2020-12-08T23:45:42Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e400fc373d478a0a7a2712f64cc558f278e593fb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzI3NDY1",
          "commit": {
            "abbreviatedOid": "62f4883"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-08T23:45:34Z",
          "updatedAt": "2020-12-08T23:45:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM2MzQzODcx",
      "title": "Add hpke-compact, another implementation in Go",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/188",
      "state": "MERGED",
      "author": "jedisct1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Another Go implementation, but that one doesn't depend on CIRCL.",
      "createdAt": "2020-12-10T23:45:23Z",
      "updatedAt": "2020-12-11T23:14:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "cdbef9a2539d80669bc86d8719dcb8d3fa77c768",
      "headRepository": "jedisct1/draft-irtf-cfrg-hpke",
      "headRefName": "patch-3",
      "headRefOid": "a69430388ab298a85bf39b9c667dac74715261b6",
      "closedAt": "2020-12-11T23:14:41Z",
      "mergedAt": "2020-12-11T23:14:41Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "92d74de80ab25a365476c69724ab0125402d1696"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 190,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM3NDA0MDc2",
      "title": "Add go-hpke-compact to the list of implementations.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/190",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @jedisct1 :-)",
      "createdAt": "2020-12-11T21:04:27Z",
      "updatedAt": "2020-12-11T23:14:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "cdbef9a2539d80669bc86d8719dcb8d3fa77c768",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/add-go-hpke-compact",
      "headRefOid": "327c5fe2e5ce1297fa1f3a06e1c3234c21c34dcc",
      "closedAt": "2020-12-11T23:14:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Duplicate of #188 :)",
          "createdAt": "2020-12-11T23:01:13Z",
          "updatedAt": "2020-12-11T23:01:13Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops, missed that! ",
          "createdAt": "2020-12-11T23:14:52Z",
          "updatedAt": "2020-12-11T23:14:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 191,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM4MzIwNTQ5",
      "title": "Add bidirectional response encryption example.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/191",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm not sure we should say much more here, since the number and length of all exported and subsequently derived secrets depends on the application. This should be sufficient to demonstrate the basic idea. \r\n\r\ncc @jedisct1, @blipp ",
      "createdAt": "2020-12-12T17:20:33Z",
      "updatedAt": "2020-12-14T21:43:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "92d74de80ab25a365476c69724ab0125402d1696",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/add-bidirectional-note",
      "headRefOid": "79c5ac95981ce95197be4d73ed9b8f7293a959e5",
      "closedAt": "2020-12-14T21:43:37Z",
      "mergedAt": "2020-12-14T21:43:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3239dcf63fd6367208b422833a64ef2ca4cfd707"
      },
      "comments": [
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me!",
          "createdAt": "2020-12-12T18:00:25Z",
          "updatedAt": "2020-12-12T18:00:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I kept the additional Extract step because I would expect applications to include additional context in the secret derivation. I\u2019m not sure we need to say much there, though, so your first suggestion is fine with me.",
          "createdAt": "2020-12-12T18:59:50Z",
          "updatedAt": "2020-12-12T18:59:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Context (like for example an application name), is not randomness that needs to be spread \u2013 an Expand is enough to bind the result to the context.\n\nUnrelated, but I'd like to dig into this. Is there a substantial difference between passing context as Extract's salt vs Expand's info parameter? (HKDF does suggest that info is more appropriate for this use case.)\n",
          "createdAt": "2020-12-12T19:14:58Z",
          "updatedAt": "2020-12-12T19:14:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwODUzMjMz",
          "commit": {
            "abbreviatedOid": "c6145f2"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "I think this is a good suggestion, and I like the text. Two alternative suggestions for the specific example because I think we do not need an Extract step (there is no new keying material from which we need to extract randomness).",
          "createdAt": "2020-12-12T18:52:33Z",
          "updatedAt": "2020-12-12T18:57:06Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Instead of redoing an Extract + Expand iteration, I'd suggest a more lightweight example:\r\n\r\n```suggestion\r\n~~~\r\nkey = context.Export(\"response key\", Nk)\r\nnonce = context.Export(\"response nonce\", Nn)\r\n~~~\r\n```\r\nor if we can somehow express splitting of bitstrings in our pseudocode:\r\n\r\n```suggestion\r\n~~~\r\nkey, nonce = context.Export(\"response\", Nk + Nn)\r\n~~~\r\n```",
              "createdAt": "2020-12-12T18:52:33Z",
              "updatedAt": "2020-12-14T21:40:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwODU0MDc1",
          "commit": {
            "abbreviatedOid": "a148bbc"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me now!\r\n\r\nContext (like for example an application name), is not randomness that needs to be spread \u2013 an Expand is enough to bind the result to the context.",
          "createdAt": "2020-12-12T19:04:49Z",
          "updatedAt": "2020-12-12T19:04:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxODk0OTQ4",
          "commit": {
            "abbreviatedOid": "a148bbc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-12-14T21:09:40Z",
          "updatedAt": "2020-12-14T21:09:50Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\ncase.\r\n\r\nNote that the HPKE's limitations with regard to sender authentication become limits on receiver authentication in this context.  In particular, in the base mode, there is no authentication of the remote party at all.  Even in the Auth mode, where the remote party has proven that they hold a specific private key, this authentication is still subject to Key-Compromise Impersonation, as discussed in {{key-compromise-impersonation}}.\r\n```",
              "createdAt": "2020-12-14T21:09:40Z",
              "updatedAt": "2020-12-14T21:40:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxOTE1MDgy",
          "commit": {
            "abbreviatedOid": "bff04bf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-14T21:39:20Z",
          "updatedAt": "2020-12-14T21:39:21Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\nNote that HPKE's limitations with regard to sender authentication\r\n```",
              "createdAt": "2020-12-14T21:39:20Z",
              "updatedAt": "2020-12-14T21:40:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxOTE1Njc5",
          "commit": {
            "abbreviatedOid": "90df33d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-14T21:40:10Z",
          "updatedAt": "2020-12-14T21:40:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 192,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5NjA5NDM0",
      "title": "Provide encryption and decryption API separation with different contexts",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/192",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Encryption is unidirectional. This change makes it so that sender contexts\r\nonly have an encryption API, and decryption contexts have a decryption API.\r\nThis hopefully hedges against confusion and context reuse, which may lead\r\nto accidental key and nonce reuse.\r\n\r\nCloses #187.\r\n\r\ncc @jedisct1, @blipp ",
      "createdAt": "2020-12-14T15:52:58Z",
      "updatedAt": "2020-12-14T21:45:49Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3239dcf63fd6367208b422833a64ef2ca4cfd707",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/context-api-separation",
      "headRefOid": "13577d41c91f37fc0d3a2b52043ff751aba3a6ee",
      "closedAt": "2020-12-14T21:45:48Z",
      "mergedAt": "2020-12-14T21:45:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f94377849016e355715ab5330744b17b7db6a744"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxODg4NTg2",
          "commit": {
            "abbreviatedOid": "f5cca38"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't love how we've re-invented inheritance here :)  But it's a sensible division, and one implemented in the Go example stack, so I'm OK with it.",
          "createdAt": "2020-12-14T21:00:28Z",
          "updatedAt": "2020-12-14T21:00:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM5NjI2MDYy",
      "title": "Reserve 0xFFFF for export-only applications.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/193",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #185.\r\n\r\ncc @jedisct1, @blipp ",
      "createdAt": "2020-12-14T16:05:51Z",
      "updatedAt": "2020-12-14T21:26:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "92d74de80ab25a365476c69724ab0125402d1696",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/reserve-aead-id",
      "headRefOid": "a08917f79c81437dbdb0bd62a0406d62d5017b7c",
      "closedAt": "2020-12-14T21:26:00Z",
      "mergedAt": "2020-12-14T21:26:00Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ece39d43f412783ab2ec87fd02fddbd23ee53765"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxODkwOTY2",
          "commit": {
            "abbreviatedOid": "0bbd289"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-12-14T21:04:04Z",
          "updatedAt": "2020-12-14T21:04:30Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n| 0xFFFF | Export-only      | N/A | N/A | [[RFCXXXX]] |\r\n```\r\n\r\n[\"Reserved\" has a special meaning with IANA](https://tools.ietf.org/html/rfc8126#section-6).  It means that a value is neither assigned nor available for assignment.  This one should be assigned.",
              "createdAt": "2020-12-14T21:04:04Z",
              "updatedAt": "2020-12-14T21:11:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxOTA2MDA3",
          "commit": {
            "abbreviatedOid": "a08917f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-14T21:25:52Z",
          "updatedAt": "2020-12-14T21:25:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQwMTIxNjU0",
      "title": "Unify to recipient, other editorial nits",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/194",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-15T09:54:06Z",
      "updatedAt": "2020-12-15T15:04:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "f94377849016e355715ab5330744b17b7db6a744",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_editorial2",
      "headRefOid": "77960e35a9815ef859cdfee3cdbbf34f0e16fe87",
      "closedAt": "2020-12-15T15:04:30Z",
      "mergedAt": "2020-12-15T15:04:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "6b61d9cba99d3f3098f22fea52a25b0573bb1a33"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNTUzMDAz",
          "commit": {
            "abbreviatedOid": "77960e3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-15T15:04:25Z",
          "updatedAt": "2020-12-15T15:04:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQwMzE5OTk2",
      "title": "Update test vectors to -07.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/195",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change fixes some editorial issues and then updates the test vectors. It also adds new export-only test vectors for the `0xFFFF` AEAD ID. \r\n\r\ncc @blipp ",
      "createdAt": "2020-12-15T15:07:50Z",
      "updatedAt": "2020-12-16T23:00:22Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "6b61d9cba99d3f3098f22fea52a25b0573bb1a33",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/new-test-vectors",
      "headRefOid": "4ce52cf9d05a7645e58e372a17b8ef6119245944",
      "closedAt": "2020-12-16T14:18:21Z",
      "mergedAt": "2020-12-16T14:18:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8eb61be8e092a9560106d7ef489181c467b44664"
      },
      "comments": [
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The new test vectors are matching what I get with the new label strings.",
          "createdAt": "2020-12-15T18:52:45Z",
          "updatedAt": "2020-12-15T18:52:45Z"
        },
        {
          "author": "kjacobs-moz",
          "authorAssociation": "CONTRIBUTOR",
          "body": "These vectors are also passing in NSS (with the same testing limitations noted in https://github.com/cisco/go-hpke/pull/49#issuecomment-745388276).",
          "createdAt": "2020-12-16T00:33:19Z",
          "updatedAt": "2020-12-16T00:33:19Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Everything that's implemented (including ExportOnly now) is passing in my impl",
          "createdAt": "2020-12-16T02:22:03Z",
          "updatedAt": "2020-12-16T02:22:03Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 15/12/2020 15:08, Christopher Wood wrote:\n> This change fixes some editorial issues and then updates the test\n> vectors. It also adds new export-only test vectors for the `0xFFFF`\n> AEAD ID.\nI've not implemented the 0xffff stuff, but having updated the\nlabels, my code seems to be ok with the new test vectors. Do\nI need to submit a PR or can someone do the 06->07 change for\nhappykey in the implementation status table?\n\nS.\n\n",
          "createdAt": "2020-12-16T21:57:55Z",
          "updatedAt": "2020-12-16T21:57:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @sftcd! I'll update the happykey reference.",
          "createdAt": "2020-12-16T23:00:22Z",
          "updatedAt": "2020-12-16T23:00:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxMjgyNDgx",
      "title": "Update draft version for HPKE-Compact",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/196",
      "state": "MERGED",
      "author": "jedisct1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-16T16:19:59Z",
      "updatedAt": "2020-12-17T00:15:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8eb61be8e092a9560106d7ef489181c467b44664",
      "headRepository": "jedisct1/draft-irtf-cfrg-hpke",
      "headRefName": "patch-4",
      "headRefOid": "610d5ea63538326d5a64a1a1de0f1e734ebee7c2",
      "closedAt": "2020-12-16T23:06:22Z",
      "mergedAt": "2020-12-16T23:06:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f498ca39d5d7952313548ad60f742a04477ac484"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTU3NTI3",
          "commit": {
            "abbreviatedOid": "610d5ea"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-16T23:06:19Z",
          "updatedAt": "2020-12-16T23:06:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxNDk0NzY4",
      "title": "Updated draft compliance version of rust-hpke",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/197",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-16T23:13:53Z",
      "updatedAt": "2020-12-16T23:14:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "f498ca39d5d7952313548ad60f742a04477ac484",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "daedfbd240045fb179dcd6d87b6c9c44a664ec70",
      "closedAt": "2020-12-16T23:14:32Z",
      "mergedAt": "2020-12-16T23:14:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "99e2857b31f9a235ef0a9d0d9250330ddf753918"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTYxNDg5",
          "commit": {
            "abbreviatedOid": "daedfbd"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-16T23:14:27Z",
          "updatedAt": "2020-12-16T23:14:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQyMDA5MTEz",
      "title": "Bump CIRCL version to 07",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/198",
      "state": "MERGED",
      "author": "cjpatton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "CIRCL now implements draft-07 in full except for the new AEAD code point for \"Export Only\" mode. This is forthcoming:\r\nhttps://github.com/cloudflare/circl/pull/205",
      "createdAt": "2020-12-17T17:17:25Z",
      "updatedAt": "2020-12-17T17:23:40Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "99e2857b31f9a235ef0a9d0d9250330ddf753918",
      "headRepository": "cjpatton/draft-irtf-cfrg-hpke",
      "headRefName": "bumph-circl-07",
      "headRefOid": "0324d388b8d262c82c4aea0f5de64ed79a2a3926",
      "closedAt": "2020-12-17T17:23:40Z",
      "mergedAt": "2020-12-17T17:23:40Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "30323ec90b42ca371080dbb3b7faa8dfdd439955"
      },
      "comments": [
        {
          "author": "cjpatton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc/ @chris-wood",
          "createdAt": "2020-12-17T17:17:45Z",
          "updatedAt": "2020-12-17T17:17:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0ODIxNzEy",
          "commit": {
            "abbreviatedOid": "0324d38"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-17T17:23:35Z",
          "updatedAt": "2020-12-17T17:23:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 199,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQyNzQzNTcy",
      "title": "update hpke-wrap version",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/199",
      "state": "MERGED",
      "author": "danharkins",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "current with -07 now",
      "createdAt": "2020-12-18T19:51:23Z",
      "updatedAt": "2020-12-19T03:58:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "30323ec90b42ca371080dbb3b7faa8dfdd439955",
      "headRepository": "danharkins/draft-irtf-cfrg-hpke",
      "headRefName": "master",
      "headRefOid": "3d574e879c3f24de1d37d7b7788fdc844a3a1af8",
      "closedAt": "2020-12-19T03:58:20Z",
      "mergedAt": "2020-12-19T03:58:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "93702b25b2a62208c1f575ee3c7ae1740bd3c22e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUxMzE3NTMy",
      "title": "Update BoringSSL entry in README.md to draft-07",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/200",
      "state": "MERGED",
      "author": "dmcardle",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Table maintenance, as requested :) \r\n\r\n@chris-wood",
      "createdAt": "2021-01-07T21:38:44Z",
      "updatedAt": "2021-01-07T22:11:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "93702b25b2a62208c1f575ee3c7ae1740bd3c22e",
      "headRepository": "dmcardle/draft-irtf-cfrg-hpke",
      "headRefName": "dmcardle-update-readme-bssl",
      "headRefOid": "e7426026765f751704ba1de58fb704e4d3871d2e",
      "closedAt": "2021-01-07T22:11:01Z",
      "mergedAt": "2021-01-07T22:11:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "65b994a98ba729ed8c6b80ca96e0fe85006f3ab0"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2021-01-07T22:10:52Z",
          "updatedAt": "2021-01-07T22:10:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUxNTQ4NDI0",
      "title": "Update hpke-rs compatibility",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/201",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I guess I should update the version here as well. ",
      "createdAt": "2021-01-08T06:54:52Z",
      "updatedAt": "2021-01-25T15:08:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "65b994a98ba729ed8c6b80ca96e0fe85006f3ab0",
      "headRepository": "franziskuskiefer/draft-irtf-cfrg-hpke",
      "headRefName": "patch-2",
      "headRefOid": "50f46c3df25f702930580dd2fa7d9ee95ff80b4d",
      "closedAt": "2021-01-25T15:08:38Z",
      "mergedAt": "2021-01-25T15:08:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "753a010c04b1adfc1671e140ad87661393fc1d5b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYxNDM4NTg3",
      "title": "NSS does -07 as of today",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/203",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-26T00:02:52Z",
      "updatedAt": "2021-01-26T00:07:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "753a010c04b1adfc1671e140ad87661393fc1d5b",
      "headRepository": "martinthomson/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "9afc3fce7cb8378f5e3bb9c6f100b3eda8103728",
      "closedAt": "2021-01-26T00:07:29Z",
      "mergedAt": "2021-01-26T00:07:29Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0373bd8afe75a9c92cabbc37db87031041721b0b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 204,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY4ODY2ODA5",
      "title": "Fix the version string. Apply other editorial suggestions from Colin.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/204",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This breaks draft version and test vector coupling, which is problematic for protocols and implementations tracking updates to this draft. Given the maturity of this draft, we now is an appropriate time to break this dependency. No wire format changes will be made going forward (of course absent analysis that suggests the need for changes).\r\n\r\ncc @blipp ",
      "createdAt": "2021-02-06T23:09:03Z",
      "updatedAt": "2021-02-09T20:08:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0373bd8afe75a9c92cabbc37db87031041721b0b",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/editor-prep",
      "headRefOid": "9694e5eb2731ace5eb10dc067cfa794a980d2835",
      "closedAt": "2021-02-09T20:08:56Z",
      "mergedAt": "2021-02-09T20:08:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3aa0a78f4ffab36b92cde00741591d09a98cbfcc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2NTI3ODQ0",
          "commit": {
            "abbreviatedOid": "2593c31"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good to me overall! See three comments below. ",
          "createdAt": "2021-02-09T13:12:29Z",
          "updatedAt": "2021-02-09T13:27:51Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "```suggestion\r\n  the private key `skX` and public key `pkY` to produce a Diffie-Hellman shared secret of\r\n```\r\nThe Diffie-Hellman was deleted in front of shared secret, was this on purpose? At other occurrences we seem to carefully distinguish between \u201cDiffie-Hellman shared secret\u201d and \u201cKEM shared secret\u201d, so it seems good to do it here, too.",
              "createdAt": "2021-02-09T13:17:17Z",
              "updatedAt": "2021-02-09T20:07:53Z"
            },
            {
              "originalPosition": 142,
              "body": "I like how the proposal reduced text repetition. One nit:\r\n\r\nIn the pseudo-code we still use `Serialize` and `Deserialize`, that are no longer defined. Switch to `SerializePublicKey()` and `DeserializePublicKey()` in the pseudo-code?",
              "createdAt": "2021-02-09T13:18:42Z",
              "updatedAt": "2021-02-09T20:07:53Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n- `OS2IP(x)`: Convert byte string `x` to a non-negative integer as\r\n  described in {{!RFC8017}}, assuming big-endian byte order.\r\n```\r\nMention big-endian also for OS2IP?",
              "createdAt": "2021-02-09T13:23:33Z",
              "updatedAt": "2021-02-09T20:07:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2NTQ1NDg1",
          "commit": {
            "abbreviatedOid": "b4f4d08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-09T13:32:09Z",
          "updatedAt": "2021-02-09T13:32:09Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "I intentionally removed it, since it seems obvious from context. But I'm fine adding it back. ",
              "createdAt": "2021-02-09T13:32:09Z",
              "updatedAt": "2021-02-09T20:07:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2NTQ2NzQ1",
          "commit": {
            "abbreviatedOid": "b4f4d08"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-09T13:33:33Z",
          "updatedAt": "2021-02-09T13:33:33Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Fixed and pushed.",
              "createdAt": "2021-02-09T13:33:33Z",
              "updatedAt": "2021-02-09T20:07:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2NTYyMzA4",
          "commit": {
            "abbreviatedOid": "0e0bcca"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-09T13:50:10Z",
          "updatedAt": "2021-02-09T13:50:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2NjI4NjQz",
          "commit": {
            "abbreviatedOid": "0e0bcca"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Two nits, otherwise LGTM.",
          "createdAt": "2021-02-09T14:50:28Z",
          "updatedAt": "2021-02-09T15:01:50Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "This should be a dynamic cross-reference.  If you check the kramdown docs, there is a way to attach a label to the table and use `{{label}}` here.",
              "createdAt": "2021-02-09T14:50:28Z",
              "updatedAt": "2021-02-09T20:07:53Z"
            },
            {
              "originalPosition": 117,
              "body": "Why don't we need the removed methods any more?  Is this just to avoid pass-through?",
              "createdAt": "2021-02-09T15:01:41Z",
              "updatedAt": "2021-02-09T20:07:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2OTU0MDk3",
          "commit": {
            "abbreviatedOid": "0e0bcca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-09T20:02:28Z",
          "updatedAt": "2021-02-09T20:02:28Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Yeah, these methods are already on the KEM interface, and the text clarifies that these functions produce keys in the group. ",
              "createdAt": "2021-02-09T20:02:28Z",
              "updatedAt": "2021-02-09T20:07:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2OTU4NDA0",
          "commit": {
            "abbreviatedOid": "9694e5e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-09T20:08:01Z",
          "updatedAt": "2021-02-09T20:08:01Z",
          "comments": [
            {
              "originalPosition": 218,
              "body": "Good call -- fixed!",
              "createdAt": "2021-02-09T20:08:01Z",
              "updatedAt": "2021-02-09T20:08:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 205,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcyOTQwNDY2",
      "title": "HPKE fixes benign malleability attacks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/205",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-13T13:54:49Z",
      "updatedAt": "2021-02-15T17:23:37Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3aa0a78f4ffab36b92cde00741591d09a98cbfcc",
      "headRepository": "emanjon/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "9f9c45b3790f2484c491dfce08d8a20707776d2f",
      "closedAt": "2021-02-15T17:23:37Z",
      "mergedAt": "2021-02-15T17:23:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ff81e8cc6b25bb05765487ebdc77d237b1641b36"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2021-02-15T17:23:34Z",
          "updatedAt": "2021-02-15T17:23:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNjU4NDU5",
          "commit": {
            "abbreviatedOid": "e84ebc4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-15T17:23:05Z",
          "updatedAt": "2021-02-15T17:23:24Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nHPKE mitigates malleability problems (called benign malleability {{SECG}}) in prior\r\npublic key encryption standards based on ECIES by including all public keys in the\r\ncontext key schedule.\r\n```",
              "createdAt": "2021-02-15T17:23:05Z",
              "updatedAt": "2021-02-15T17:23:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczNzA1Njc2",
      "title": "Apply final test vectors",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/208",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change updates the test vectors using the new (decoupled) version string. This should be the last time the vectors change for this particular specification.\r\n\r\ncc @martinthomson, @jedisct1, @dmcardle, @kjacobs-moz, @sftcd, @rozbb, @blipp, @fredericjacobs, @ttaubert, @armfazh, @franziskuskiefer",
      "createdAt": "2021-02-15T17:29:05Z",
      "updatedAt": "2021-02-16T00:09:56Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ff81e8cc6b25bb05765487ebdc77d237b1641b36",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/last-vectors",
      "headRefOid": "d65d960cda42acac7c4735eff113cebc06745793",
      "closedAt": "2021-02-15T19:03:31Z",
      "mergedAt": "2021-02-15T19:03:31Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7f7cfd9ca9203b1749fcf988dc17b67184749be5"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Are you certain these vectors use the HPKE-v1 tag\r\n\r\nI thought I had generated them with the right tag. Stand by.",
          "createdAt": "2021-02-15T17:44:29Z",
          "updatedAt": "2021-02-15T17:44:29Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry, I made a silly mistake. All tests passing \ud83d\ude05",
          "createdAt": "2021-02-15T17:45:16Z",
          "updatedAt": "2021-02-15T17:45:16Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Hah, well, I re-generated and re-applied them anyway. @rozbb, please take another look.",
          "createdAt": "2021-02-15T17:47:06Z",
          "updatedAt": "2021-02-15T17:47:06Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yup, all passing (which, again, is everything that doesn't use P521 or X448). Sorry about that",
          "createdAt": "2021-02-15T17:51:34Z",
          "updatedAt": "2021-02-15T17:51:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yup, all passing (which, again, is everything that doesn't use P521 or X448). \r\n\r\nGreat -- thanks!\r\n\r\n> Sorry about that\r\n\r\nNo worries. You still win 1st place for fastest-to-verify. :-)",
          "createdAt": "2021-02-15T17:53:55Z",
          "updatedAt": "2021-02-15T17:53:55Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've confirmed those vectors that use mode 0 or 1, X25519, SHA-2, and AES-128-GCM or ChaCha20Poly1305 in NSS.",
          "createdAt": "2021-02-16T00:09:56Z",
          "updatedAt": "2021-02-16T00:09:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzA0ODg4",
          "commit": {
            "abbreviatedOid": "d65d960"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-15T19:03:05Z",
          "updatedAt": "2021-02-15T19:03:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzkyODk1",
          "commit": {
            "abbreviatedOid": "d65d960"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-15T23:00:43Z",
          "updatedAt": "2021-02-15T23:01:00Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Note that this file isn't a JSON file, despite the name.  Maybe https://raw.githubusercontent.com/cfrg/draft-irtf-cfrg-hpke/779d0285fe0e9407abb549ba0104e831d9677164/test-vectors.json instead?\r\n",
              "createdAt": "2021-02-15T23:00:43Z",
              "updatedAt": "2021-02-15T23:01:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczNzU2NTM3",
      "title": "Clarify / expand ordering requirements",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/209",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As suggested by Dan Harkins [on the mailing list](https://mailarchive.ietf.org/arch/msg/cfrg/UxQLsxrea7HVwWey9T2KyKdB8oY/).",
      "createdAt": "2021-02-15T19:36:24Z",
      "updatedAt": "2021-02-15T20:33:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "7f7cfd9ca9203b1749fcf988dc17b67184749be5",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "multi-shot",
      "headRefOid": "95b8b0b8073517c168f75c4a262d36263536163f",
      "closedAt": "2021-02-15T20:33:06Z",
      "mergedAt": "2021-02-15T20:33:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3b0cc76d0d51b1879c9b42e9ebd73c3f85fa8cb2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNzE5NDky",
          "commit": {
            "abbreviatedOid": "e5af264"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with some nits!",
          "createdAt": "2021-02-15T19:39:44Z",
          "updatedAt": "2021-02-15T19:41:23Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n`Open()` / `Seal()` on the same context MUST enforce the ordering property\r\n```",
              "createdAt": "2021-02-15T19:39:44Z",
              "updatedAt": "2021-02-15T20:31:46Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\na message has been lost.  When an unrecoverable loss is detected, the application MUST discard\r\n```",
              "createdAt": "2021-02-15T19:40:31Z",
              "updatedAt": "2021-02-15T20:31:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc0NTgxMDEx",
      "title": "Key reuse is bad mkay",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/210",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I considered adding this to Section 8.2 instead, but this seems most\r\nappropriate.\r\n\r\nCloses #202.",
      "createdAt": "2021-02-17T01:28:35Z",
      "updatedAt": "2021-04-12T14:30:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3b0cc76d0d51b1879c9b42e9ebd73c3f85fa8cb2",
      "headRepository": "martinthomson/draft-irtf-cfrg-hpke",
      "headRefName": "no-key-reuse",
      "headRefOid": "bbfaa2edb5eee602183a90248be5387aa6c1334a",
      "closedAt": "2021-04-12T14:30:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not sure what you mean by `Senders ensure that the shared secret is unique for each context by choosing a unique value for input keying material`? Is this about the randomness used for each individual invocation of `(Auth)Encap()`?\r\n\r\nConcerning `ikm`, I suggest we replace your suggestion by something more general:\r\n\r\n```\r\nA value `ikm` MUST NOT be used more than once with `DeriveKeyPair()` and MUST NOT be reused elsewhere,\r\nin particular not for other invocations of `DeriveKeyPair()`, be it for the same or a different KEM.\r\n```\r\n\r\nWould this cover your concerns?\r\n\r\n(I wonder if we should add text about using keypairs for different modes (Base, PSK, Auth, AuthPSK). It could be good to either be sure that this kind of reuse is cryptographically ok, or prohibit it in the RFC.)",
          "createdAt": "2021-03-02T17:37:51Z",
          "updatedAt": "2021-03-02T17:37:51Z"
        },
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@martinthomson  I made a proposal in a separate PR, #215.",
          "createdAt": "2021-03-24T10:47:23Z",
          "updatedAt": "2021-03-24T10:47:23Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3OTUyOTEw",
      "title": "rust-hpke implements draft-08",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/211",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is true as of https://github.com/rozbb/rust-hpke/commit/b58a99adb605ecb8eeba1520108c586d742494cc and crate version 0.5",
      "createdAt": "2021-02-22T21:29:14Z",
      "updatedAt": "2021-02-22T23:57:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "e9e9b0ae6196ea8cb098343db534e3187b348c40",
      "headRepository": "rozbb/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "dc72100fef8cb98d877b3afe74a89cbac87bd5bc",
      "closedAt": "2021-02-22T23:57:17Z",
      "mergedAt": "2021-02-22T23:57:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4d230ea13ea4eabb5a8bf959507c57dde0f9eac9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1ODkyMDU1",
          "commit": {
            "abbreviatedOid": "dc72100"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-22T23:57:13Z",
          "updatedAt": "2021-02-22T23:57:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 212,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgzMTE0MTky",
      "title": "Rework advice on domain separation after comment by Martin Thomson",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/212",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Link to email: https://mailarchive.ietf.org/arch/msg/cfrg/PhsZ5LeVal1CNCvOt3OqIYkgBhw/",
      "createdAt": "2021-03-02T15:18:41Z",
      "updatedAt": "2021-03-24T13:21:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4d230ea13ea4eabb5a8bf959507c57dde0f9eac9",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_domainsep_clarify",
      "headRefOid": "59ac68f0474d2febf9948a3331ad77b5c0e3ef93",
      "closedAt": "2021-03-24T13:21:32Z",
      "mergedAt": "2021-03-24T13:21:32Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b4299a09415653e582d38216711eeda7bfafdc6c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMzMwMTk3",
          "commit": {
            "abbreviatedOid": "672a8f9"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @blipp. This looks good to me.",
          "createdAt": "2021-03-02T22:27:02Z",
          "updatedAt": "2021-03-02T22:27:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMzQ3MTI0",
          "commit": {
            "abbreviatedOid": "672a8f9"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for putting this together.  (And thanks for pointing to the prefix-free text that is there already.)\r\n\r\nJust a concern about a possible ambiguity in interpretation of the new text.",
          "createdAt": "2021-03-02T22:51:29Z",
          "updatedAt": "2021-03-02T22:52:19Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Are you saying that prefix-free applies to all labels passed to `LabeledE...()`?  That is, a label for one function cannot be a prefix for the other function?  I don't think that is necessary.  If you said that, is there a risk that the choice of length for `LabeledExpand()` causes this property to be violated?",
              "createdAt": "2021-03-02T22:51:29Z",
              "updatedAt": "2021-03-05T16:41:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyOTE1NTA1",
          "commit": {
            "abbreviatedOid": "672a8f9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-03T13:54:17Z",
          "updatedAt": "2021-03-03T13:54:48Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "It's also not totally clear to me what \"prefix-free\" means here.  I think you mean \"no label is a prefix of another within the set\"?  As opposed to something like, \"no two labels share a non-empty common prefix\".  Assuming that, an extra parenthetical of the form \"(A set is \"prefix-free\" if ...)\" would be helpful here.",
              "createdAt": "2021-03-03T13:54:17Z",
              "updatedAt": "2021-03-05T16:41:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyOTE5MzEx",
          "commit": {
            "abbreviatedOid": "672a8f9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-03T13:58:01Z",
          "updatedAt": "2021-03-03T13:58:08Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "\"Respect the definition\" seems vague for a MUST.  And since there's already a MUST above, it doesn't seem like another requirement here is necessary.  Maybe just note that this that (required) construction helps assure this property.",
              "createdAt": "2021-03-03T13:58:01Z",
              "updatedAt": "2021-03-05T16:41:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1NDA3NjA1",
          "commit": {
            "abbreviatedOid": "59ac68f"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T16:42:55Z",
          "updatedAt": "2021-03-05T16:42:55Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "@martinthomson Thanks, you are right. The advice was overly restrictive.\r\n\r\nBecause of the shift of two bytes at the beginning of the label, the domains of Extract and Expand are already separated (`KE` is different from `HP`):\r\n```\r\nHPKE-v1...\r\nLLHPKE-v1...\r\n```\r\n\r\nBecause of the start of the `suite_id`, the domains of Extract and Expand in the KEM vs the remainder of HPKE are already separated:\r\n```\r\nKEMID\r\nHPKEIDIDID\r\n```\r\n\r\nSo indeed, the labels for one function could be the prefix of the one of another function, and it would not invalidate the security theorems.\r\n\r\nI rephrased the first and second paragraph accordingly.\r\n\r\n@bifurcation I added a definition of prefix-free following your suggestion, thanks.\r\n\r\n",
              "createdAt": "2021-03-05T16:42:55Z",
              "updatedAt": "2021-03-05T16:42:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg2OTYwMDY3",
      "title": "Add input length restrictions for DeriveKeyPair's ikm",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/213",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I am in the process of completing the FStar implementation of HPKE, and realized that DeriveKeyPair's `ikm` parameter also has an input limit. This PR adds the appropriate line to the table.",
      "createdAt": "2021-03-08T17:26:58Z",
      "updatedAt": "2021-04-12T14:30:31Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4d230ea13ea4eabb5a8bf959507c57dde0f9eac9",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_ikm_limit",
      "headRefOid": "0368c9e503d3fef8dfe4151426fa4630d01383e5",
      "closedAt": "2021-04-12T14:30:31Z",
      "mergedAt": "2021-04-12T14:30:31Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3e6ec3528ed828074f75ab444739194c105df23e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NzE2MDg0",
          "commit": {
            "abbreviatedOid": "0368c9e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I would have probably phrased this differently, but this is fine!",
          "createdAt": "2021-03-24T13:28:23Z",
          "updatedAt": "2021-03-24T13:28:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 214,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkwMTg5NTU2",
      "title": "happykey updated to draft-08",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/214",
      "state": "MERGED",
      "author": "sftcd",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "That was surprisingly easy:-)",
      "createdAt": "2021-03-10T21:45:18Z",
      "updatedAt": "2021-03-24T13:21:47Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4d230ea13ea4eabb5a8bf959507c57dde0f9eac9",
      "headRepository": "sftcd/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "7ced8b64b09dcb5534912ab3d2343dc244451a46",
      "closedAt": "2021-03-24T13:21:47Z",
      "mergedAt": "2021-03-24T13:21:47Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5d804d107006f795cd2feccb9626e837980b1e79"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2021-03-24T13:21:43Z",
          "updatedAt": "2021-03-24T13:21:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 215,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk5NTgwNjYz",
      "title": "About KEM Key Reuse",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/215",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Polished alternative to #210.\r\n\r\nProving security when using multiple modes in parallel should be doable with the models and CryptoVerif files prepared so far. However, I cannot spend time on it before May.\r\n\r\nReusing `ikm` elsewhere would be really inconvenient for proofs: at some point _we have_ to assume that _something_ is freshly random and not reused anywhere else, and I think drawing that line at the kind of root entry point, the KEM key pair, is good.\r\n\r\nCloses #210.",
      "createdAt": "2021-03-24T10:45:55Z",
      "updatedAt": "2021-04-12T14:30:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4d230ea13ea4eabb5a8bf959507c57dde0f9eac9",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_ikm_reuse",
      "headRefOid": "c22e6c68f2b1c2162742c31b042bea138544dacb",
      "closedAt": "2021-04-12T14:30:12Z",
      "mergedAt": "2021-04-12T14:30:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ea619ca73c8c660572eb49ad4f2021eb70c9bb87"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE5NzE3MDgz",
          "commit": {
            "abbreviatedOid": "4947a86"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-24T13:29:15Z",
          "updatedAt": "2021-03-24T13:30:30Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nKEM shared secret or its encapsulation MUST NOT be reused elsewhere.\r\n```",
              "createdAt": "2021-03-24T13:29:15Z",
              "updatedAt": "2021-04-06T11:45:15Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nAs a sender or recipient KEM key pair works with all modes, it can\r\n```",
              "createdAt": "2021-03-24T13:30:14Z",
              "updatedAt": "2021-04-06T11:45:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwMzM1MDI4",
          "commit": {
            "abbreviatedOid": "c85d562"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "WFM",
          "createdAt": "2021-03-25T00:32:43Z",
          "updatedAt": "2021-03-25T00:36:05Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nwriting; {{HPKEAnalysis}} and {{ABHKLR20}} only analyze isolated modes.\r\n```",
              "createdAt": "2021-03-25T00:32:44Z",
              "updatedAt": "2021-04-06T11:45:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 216,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA0MjgwODE2",
      "title": "HPKE-compact supports draft-08",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/216",
      "state": "MERGED",
      "author": "jedisct1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-30T19:11:32Z",
      "updatedAt": "2021-03-31T07:25:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "5d804d107006f795cd2feccb9626e837980b1e79",
      "headRepository": "jedisct1/draft-irtf-cfrg-hpke",
      "headRefName": "patch-4",
      "headRefOid": "b02c60c023ba9bb34bf87f5f68ae1eca8a599a52",
      "closedAt": "2021-03-30T22:49:33Z",
      "mergedAt": "2021-03-30T22:49:33Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ac26f9ad82d55134bce03f621a96264bd6009a40"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI0NzY0MzE5",
          "commit": {
            "abbreviatedOid": "b02c60c"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-03-30T22:49:30Z",
          "updatedAt": "2021-03-30T22:49:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 217,
      "id": "MDExOlB1bGxSZXF1ZXN0NjE5NDE0Mjc1",
      "title": "Address Frank's feedback.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/217",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @blipp, @jedisct1 ",
      "createdAt": "2021-04-20T15:14:43Z",
      "updatedAt": "2021-04-20T22:00:30Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3e6ec3528ed828074f75ab444739194c105df23e",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/frank-review",
      "headRefOid": "ceb70aba9908e1f5c03ba37320ee1f5f87a8c412",
      "closedAt": "2021-04-20T22:00:30Z",
      "mergedAt": "2021-04-20T22:00:30Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cd168424dbf7a8921825ac9c24864f06dc040599"
      },
      "comments": [
        {
          "author": "jedisct1",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perfect!\n\nThanks a lot for addressing these!",
          "createdAt": "2021-04-20T15:57:06Z",
          "updatedAt": "2021-04-20T15:57:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwMTM1MjY1",
          "commit": {
            "abbreviatedOid": "6385b30"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks Chris, this looks good to me. Two minor comments in the limits paragraph, because sometimes we say that it is in bytes, and sometimes we don't.",
          "createdAt": "2021-04-20T15:48:36Z",
          "updatedAt": "2021-04-20T15:50:45Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "```suggestion\r\n`suite_id` in bytes and equals 5 for DHKEM (relevant for `ikm`) and 10 for the\r\n```",
              "createdAt": "2021-04-20T15:48:58Z",
              "updatedAt": "2021-04-20T15:51:43Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\nand `size_input_label` is the size in bytes of the label used as parameter to\r\n```",
              "createdAt": "2021-04-20T15:49:51Z",
              "updatedAt": "2021-04-20T15:51:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjQwNDU2ODcw",
          "commit": {
            "abbreviatedOid": "ceb70ab"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-20T21:55:13Z",
          "updatedAt": "2021-04-20T21:55:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 220,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ2NzMyNjY1",
      "title": "Update hpke-rs to 08 in README.md",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/220",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-05-18T13:02:38Z",
      "updatedAt": "2021-05-20T17:10:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "cd168424dbf7a8921825ac9c24864f06dc040599",
      "headRepository": "franziskuskiefer/draft-irtf-cfrg-hpke",
      "headRefName": "patch-3",
      "headRefOid": "79f8e2264455fee705b400c836dbb3affe7ea57d",
      "closedAt": "2021-05-20T17:10:38Z",
      "mergedAt": "2021-05-20T17:10:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "2e23e57abff41f900347adf0072d088c20f2e64f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 222,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUwNjE2OTQz",
      "title": "Unify around recipient.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/222",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #219.",
      "createdAt": "2021-05-22T11:59:45Z",
      "updatedAt": "2021-05-24T13:31:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "2e23e57abff41f900347adf0072d088c20f2e64f",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/unify-recipient",
      "headRefOid": "1eb941873d759ee2b55927e413aaafe399330828",
      "closedAt": "2021-05-24T13:31:52Z",
      "mergedAt": "2021-05-24T13:31:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1f37ecd930e3e8c928572466dc076ffe076ba72a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 223,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUwNjM1NDQ3",
      "title": "Update BoringSSL in implementation table.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/223",
      "state": "MERGED",
      "author": "davidben",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We've since updated to draft-08. We've also removed the PSK mode since it's not used in ECH (or anything else, as far as I can tell). Also update the link to the now exported header file.",
      "createdAt": "2021-05-22T14:22:41Z",
      "updatedAt": "2021-05-24T13:31:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "2e23e57abff41f900347adf0072d088c20f2e64f",
      "headRepository": "davidben/draft-irtf-cfrg-hpke",
      "headRefName": "update-bssl",
      "headRefOid": "8812c6df36c6239778469de1a7954ed7086b3983",
      "closedAt": "2021-05-24T13:31:38Z",
      "mergedAt": "2021-05-24T13:31:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "636c02721a78f2d0a8349177e54a9ec0599ea400"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY2NzM4NzAy",
          "commit": {
            "abbreviatedOid": "8812c6d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-24T13:31:34Z",
          "updatedAt": "2021-05-24T13:31:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUxMzY2NDM2",
      "title": "Clarify test vectors fields.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/224",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "~Opening as a draft for now until the corresponding test vector rename PR (https://github.com/cisco/go-hpke/pull/54) lands. I'll update the test vectors in this PR afterwards.~\r\n\r\ncc @kaduk, @fredericjacobs\r\n\r\nCloses #218.",
      "createdAt": "2021-05-24T14:11:56Z",
      "updatedAt": "2021-05-26T17:22:19Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "1f37ecd930e3e8c928572466dc076ffe076ba72a",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/clarify-test-vector-fields",
      "headRefOid": "5627aa4fa7cedc3809d95dcc63eeed51e0ec1fe2",
      "closedAt": "2021-05-26T17:22:19Z",
      "mergedAt": "2021-05-26T17:22:19Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0f5f56eaac5584b11bc464f54f47fb1b659ec4db"
      },
      "comments": [
        {
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "body": "Looks good to me!",
          "createdAt": "2021-05-26T17:00:43Z",
          "updatedAt": "2021-05-26T17:00:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3OTYyNzg5",
          "commit": {
            "abbreviatedOid": "4d151c3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-25T15:15:38Z",
          "updatedAt": "2021-05-25T15:15:39Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n1. Configuration information and private key material: This includes the `mode`, `info` string, HPKE\r\n   ciphersuite identifiers (`kem_id`, `kdf_id`, `aead_id`), and all\r\n```",
              "createdAt": "2021-05-25T15:15:39Z",
              "updatedAt": "2021-05-25T15:15:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MjYwOTkz",
          "commit": {
            "abbreviatedOid": "ef3a35c"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T16:31:59Z",
          "updatedAt": "2021-05-26T16:35:29Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n   sender, recipient, and ephemeral key material. For each role X,\r\n```",
              "createdAt": "2021-05-26T16:31:59Z",
              "updatedAt": "2021-05-26T16:35:29Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n   where X is one of S, R, or E as sender, recipient, and ephemeral,\r\n```",
              "createdAt": "2021-05-26T16:32:22Z",
              "updatedAt": "2021-05-26T16:35:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MzE0NjA1",
          "commit": {
            "abbreviatedOid": "ef3a35c"
          },
          "author": "FredericJacobs",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T17:00:28Z",
          "updatedAt": "2021-05-26T17:00:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 225,
      "id": "MDExOlB1bGxSZXF1ZXN0NjUxNTU2MzQ3",
      "title": "Add some API consideration text.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/225",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Opening as a draft for now. I don't think this text is perfect, but I hope the _direction_ is clear. In general, I'm trying to say that errors can change as a function of the algorithms in use, and users of HPKE should account for that. \r\n\r\ncc @davidben, @jedisct1, @blipp, @rozbb, @franziskuskiefer, @fredericjacobs, @martinthomson (from the issue)\r\n\r\nCloses #221 (?)",
      "createdAt": "2021-05-24T19:02:04Z",
      "updatedAt": "2021-05-26T17:25:52Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "1f37ecd930e3e8c928572466dc076ffe076ba72a",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/on-apis",
      "headRefOid": "a589f42388117cb0e10fd0f5a1af74ee2e1f37b3",
      "closedAt": "2021-05-26T17:21:37Z",
      "mergedAt": "2021-05-26T17:21:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "67dc1067624954695fdf97fc1fc14eca7cf46097"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Right now Sec. 4 mentions some of the explicit errors, but not all. I wonder how this new section should relate to the errors mentioned in Sec 4 and if there should have a complete overview/list of all the explicit errors.\r\n\r\nThat's not a bad idea. The explicit errors in the document are sort of scattered throughout the text. Listing them in one place might be useful. ",
          "createdAt": "2021-05-25T12:12:58Z",
          "updatedAt": "2021-05-25T12:12:58Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @blipp! I applied your suggestions. ",
          "createdAt": "2021-05-25T22:35:25Z",
          "updatedAt": "2021-05-25T22:35:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben, @bifurcation, @franziskuskiefer: please re-review if you can! @martinthomson, your eyes here would also be welcome. ",
          "createdAt": "2021-05-25T22:39:53Z",
          "updatedAt": "2021-05-25T22:39:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Belated LGTM.)",
          "createdAt": "2021-05-26T17:25:52Z",
          "updatedAt": "2021-05-26T17:25:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MTExMzQ0",
          "commit": {
            "abbreviatedOid": "cb730af"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T19:38:48Z",
          "updatedAt": "2021-05-24T19:38:48Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nuntil AEAD decryption at the recipient. As another example, DHKEM's `AuthDecap()`\r\n```\r\n(clarify that we are still talking about DHKEM, as some future KEMs might be able to detect wrong sender public keys explicitly)",
              "createdAt": "2021-05-24T19:38:48Z",
              "updatedAt": "2021-05-24T19:38:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjE0NTI3",
          "commit": {
            "abbreviatedOid": "303e5de"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T21:43:55Z",
          "updatedAt": "2021-05-24T21:47:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Nit: Are Seal() and Export() necessarily fallible? I guess Seal() is vaguely fallible at counter overflow, or if you pick EXPORT_ONLY. Export() seems infallible from the specification's perspective. (Of course, it may be fallible in the implementation if, say, allocation fails. But that's an implementation-specific detail.)",
              "createdAt": "2021-05-24T21:43:56Z",
              "updatedAt": "2021-05-24T21:47:52Z"
            },
            {
              "originalPosition": 32,
              "body": "(I may just be misreading this. I'm not entirely clear on which errors are considered explicit vs implicit here.) It sounds like this sentence, with the rest of the paragraph, is saying that the analysis only holds for DH-based KEMs because non-DH-based KEMs may have implicit errors. But the text above suggests that DH-based KEMs *do* have implicit errors.",
              "createdAt": "2021-05-24T21:47:46Z",
              "updatedAt": "2021-05-24T21:47:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjI2OTUx",
          "commit": {
            "abbreviatedOid": "303e5de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T22:03:22Z",
          "updatedAt": "2021-05-24T22:03:22Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "They're both fallible if the input sizes [are simply enormous](https://cfrg.github.io/draft-irtf-cfrg-hpke/draft-irtf-cfrg-hpke.html#name-input-length-restrictions), so I just bundled them all together here. (But that may not be too different from a `malloc` failure \ud83e\udd37.) I dunno. This seems not wrong, so I'm inclined to keep it. ",
              "createdAt": "2021-05-24T22:03:22Z",
              "updatedAt": "2021-05-24T22:03:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjI4NzU0",
          "commit": {
            "abbreviatedOid": "303e5de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T22:04:39Z",
          "updatedAt": "2021-05-24T22:04:40Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "It's... tricky :-) I'll leave it to @blipp to clarify precisely what is true about the analysis.",
              "createdAt": "2021-05-24T22:04:39Z",
              "updatedAt": "2021-05-24T22:04:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3MjQ5MjYz",
          "commit": {
            "abbreviatedOid": "303e5de"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-24T22:42:45Z",
          "updatedAt": "2021-05-24T22:42:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Hehehe, fair enough, although I don't think you typically have that much address space. :-)",
              "createdAt": "2021-05-24T22:42:45Z",
              "updatedAt": "2021-05-24T22:42:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3NDg1MTA0",
          "commit": {
            "abbreviatedOid": "303e5de"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Right now Sec. 4 mentions some of the explicit errors, but not all. I wonder how this new section should relate to the errors mentioned in Sec 4 and if there should have a complete overview/list of all the explicit errors.",
          "createdAt": "2021-05-25T07:33:55Z",
          "updatedAt": "2021-05-25T07:33:55Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3OTcwNzQ2",
          "commit": {
            "abbreviatedOid": "8b0400f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-25T15:20:46Z",
          "updatedAt": "2021-05-25T15:22:28Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "This is super vague.  What are you actual actually trying to say here?",
              "createdAt": "2021-05-25T15:20:46Z",
              "updatedAt": "2021-05-25T15:22:28Z"
            },
            {
              "originalPosition": 50,
              "body": "I would emphasize that this is not an exhaustive list.  For example, an implementation might simply run out of memory.",
              "createdAt": "2021-05-25T15:21:38Z",
              "updatedAt": "2021-05-25T15:22:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY3OTc1MTg4",
          "commit": {
            "abbreviatedOid": "8b0400f"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-25T15:24:31Z",
          "updatedAt": "2021-05-25T15:24:31Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "As in the PR description, I'm trying to say \"don't expect only certain types of errors in certain types of places -- be prepared to handle errors anywhere.\" It would be a shame if an API couldn't adopt a new ciphersuite because their error handling doesn't permit it, for example. ",
              "createdAt": "2021-05-25T15:24:31Z",
              "updatedAt": "2021-05-25T15:24:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4MDUwOTY1",
          "commit": {
            "abbreviatedOid": "03f667d"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-25T16:21:17Z",
          "updatedAt": "2021-05-25T22:11:14Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "```suggestion\r\n- `ValidationError`: KEM input or output validation failure; {{dhkem}}.\r\n```\r\n(to make clear that an all-zero DH result is also a ValidationError)",
              "createdAt": "2021-05-25T16:21:17Z",
              "updatedAt": "2021-05-25T22:11:14Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n`OpenError` when trying to decrypt a ciphertext.\r\n```",
              "createdAt": "2021-05-25T16:22:39Z",
              "updatedAt": "2021-05-25T22:11:14Z"
            },
            {
              "originalPosition": 32,
              "body": "This preliminary analysis is only about HPKE with DHKEM. DHKEM is \u201cperfectly correct\u201d, i.e. a valid encapsulation will be successfully decapsulated with probability 1. So, in some sense the analysis indeed assumes that there is no implicit error, but also it is not really an assumption, because we know that DH works that way.\r\n\r\nI'd suggest that we do not add this sentence here, but instead add a sentence two paragraphs further down, in the paragraph that discusses the composition theorems proved in the Eurocrypt paper:\r\n\r\n> Further, [ABHKLR20] proves composition theorems, showing that HPKE's Auth mode fulfills the security notions of authenticated public key encryption for all KDFs and AEAD schemes specified in this document, given any authenticated KEM satisfying the previously defined security notions for authenticated KEMs. **The theorems assume that the KEM is perfectly correct; it could easily be adapted to work with KEMs that have a non-zero but negligible probability for decryption failure.** The assumptions on the KDF are that Extract() and Expand() can be modeled as pseudorandom functions wherein the first argument is the key, respectively. The assumption for the AEAD is IND-CPA and IND-CTXT security.\r\n\r\nI will see if I can actually already adapt the composition proofs in CryptoVerif that way and will report back, but I think this is just a technical detail. It boils down to adding one game hop that turns the non-perfectly-correct KEM into a perfectly correct KEM, and accounting for the (negligible) probability that the adversary can detect this change.\r\n\r\nOn a related note: both analyses do _not_ explicitly model the all-zero/point-at-infinity check of the DH result. However, the theorems are valid for _both_ implementations that do or do not contain this check. (the reason is that it is predictable for the adversary if the DH result will be all-zero, and therefore the adversary could do this check itself before querying the KEM oracle)",
              "createdAt": "2021-05-25T22:11:02Z",
              "updatedAt": "2021-05-25T22:12:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4NDMwMDM1",
          "commit": {
            "abbreviatedOid": "ca9d254"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-25T22:38:39Z",
          "updatedAt": "2021-05-25T22:38:40Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "```suggestion\r\nthey could easily be adapted to work with KEMs that have a non-zero but negligible\r\n```",
              "createdAt": "2021-05-25T22:38:40Z",
              "updatedAt": "2021-05-25T22:38:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY4NjcxOTEx",
          "commit": {
            "abbreviatedOid": "4e7a8de"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T07:17:14Z",
          "updatedAt": "2021-05-26T07:25:41Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "`VerifyPSKInputs` raises exceptions instead of errors. I'm not sure if that's on purpose. They should probably become errors as well (maybe `ValidationError`?) and get mentioned here.",
              "createdAt": "2021-05-26T07:17:14Z",
              "updatedAt": "2021-05-26T07:25:41Z"
            },
            {
              "originalPosition": 43,
              "body": "The `DeriveKeyPairError` is missing.",
              "createdAt": "2021-05-26T07:18:02Z",
              "updatedAt": "2021-05-26T07:25:41Z"
            },
            {
              "originalPosition": 53,
              "body": "Sec 7.1.4 actually says \"the sender MUST validate the recipient's public key pkR\"\r\n\r\n```suggestion\r\nthe `Encap()` algorithm must fail when given an invalid recipient public key.\r\n```",
              "createdAt": "2021-05-26T07:23:34Z",
              "updatedAt": "2021-05-26T07:25:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MDgwOTAz",
          "commit": {
            "abbreviatedOid": "4e7a8de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T14:16:47Z",
          "updatedAt": "2021-05-26T14:16:47Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I think those are best kept as exceptions since they're due to programmer error.",
              "createdAt": "2021-05-26T14:16:47Z",
              "updatedAt": "2021-05-26T14:16:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MDgxMTc2",
          "commit": {
            "abbreviatedOid": "4e7a8de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T14:17:00Z",
          "updatedAt": "2021-05-26T14:17:00Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Good catch! I'll add it.",
              "createdAt": "2021-05-26T14:17:00Z",
              "updatedAt": "2021-05-26T14:17:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MDgxNzQy",
          "commit": {
            "abbreviatedOid": "4e7a8de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T14:17:26Z",
          "updatedAt": "2021-05-26T14:17:27Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nthe `Encap()` algorithm fails when given an invalid recipient public key.\r\n```",
              "createdAt": "2021-05-26T14:17:27Z",
              "updatedAt": "2021-05-26T14:17:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MDgzMDg5",
          "commit": {
            "abbreviatedOid": "4e7a8de"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T14:18:27Z",
          "updatedAt": "2021-05-26T14:18:27Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\n- `MessageLimitReachedError`: Context AEAD sequence number overflow; {{base-crypto}} and {{hpke-dem}}.\r\n- `DeriveKeyPairError`: Key pair derivation failure; {{derivekeypair}}.\r\n```",
              "createdAt": "2021-05-26T14:18:27Z",
              "updatedAt": "2021-05-26T14:18:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MDkzODQ5",
          "commit": {
            "abbreviatedOid": "31d900a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T14:26:44Z",
          "updatedAt": "2021-05-26T14:26:45Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "```suggestion\r\n- `DeriveKeyPairError`: Key pair derivation failure; {{derive-key-pair}}.\r\n```",
              "createdAt": "2021-05-26T14:26:45Z",
              "updatedAt": "2021-05-26T14:26:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MTQ3ODA2",
          "commit": {
            "abbreviatedOid": "a589f42"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T15:08:01Z",
          "updatedAt": "2021-05-26T15:08:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MjU2MzE0",
          "commit": {
            "abbreviatedOid": "a589f42"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T16:29:46Z",
          "updatedAt": "2021-05-26T16:29:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 227,
      "id": "MDExOlB1bGxSZXF1ZXN0NjczNTY0ODYx",
      "title": "Address Kirsty's comments.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/227",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @blipp ",
      "createdAt": "2021-06-18T15:27:47Z",
      "updatedAt": "2021-06-28T14:41:55Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0f5f56eaac5584b11bc464f54f47fb1b659ec4db",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/kirsty-comments",
      "headRefOid": "8301fa87942a4470ba8577e4b795350f174749d5",
      "closedAt": "2021-06-28T14:41:55Z",
      "mergedAt": "2021-06-28T14:41:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "760a6c7a7ac7af6575d8afc0173c288b717cf523"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp merging assuming you're OK with the latest changes -- thanks!",
          "createdAt": "2021-06-28T14:41:49Z",
          "updatedAt": "2021-06-28T14:41:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4MzE2ODk2",
          "commit": {
            "abbreviatedOid": "d7044be"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-06-21T11:29:56Z",
          "updatedAt": "2021-06-21T11:41:11Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nand two optional ones which authenticate possession of a KEM private key.\r\n```",
              "createdAt": "2021-06-21T11:29:57Z",
              "updatedAt": "2021-06-21T11:41:11Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThis scheme provides a variant of public-key encryption of arbitrary-sized\r\n```",
              "createdAt": "2021-06-21T11:32:36Z",
              "updatedAt": "2021-06-21T11:41:11Z"
            },
            {
              "originalPosition": 100,
              "body": "```suggestion\r\nSHOULD at least have the security level of the KEM and SHOULD\r\n```",
              "createdAt": "2021-06-21T11:36:40Z",
              "updatedAt": "2021-06-21T11:41:11Z"
            },
            {
              "originalPosition": 105,
              "body": "```suggestion\r\nAll AEADs MUST be IND-CCA2-secure, as is currently true for all AEADs\r\n```",
              "createdAt": "2021-06-21T11:38:47Z",
              "updatedAt": "2021-06-21T11:41:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc0OTI3Nzc5",
      "title": "Addressing comments by Kirsty on Security Limitations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/228",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Draft, open for suggestions and comments. Also on my copywriting, because it is late and hot in Paris.\r\n\r\nThe distinction between forward secrecy with respect to sender or recipient compromise is new. Let me know if you like it. Introduced after re-reading Noise' security levels.\r\n\r\nShould we keep the comparison to Noise? Should we move it somewhere else?\r\n\r\nDo you agree on the plug of PQ-WireGuard's ephemeral randomness technique? The paper cites an older reference on that, too, but I felt like the PQ-WireGuard one is easier to understand, because it is more compact.",
      "createdAt": "2021-06-21T22:11:45Z",
      "updatedAt": "2021-07-06T22:26:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d5ce5f8c88a6a285d5180903863a0dd9b8f37f03",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "kirsty-sec-cons",
      "headRefOid": "7965e244caca1587cc353f483486da2cd75c74b6",
      "closedAt": "2021-07-06T22:26:18Z",
      "mergedAt": "2021-07-06T22:26:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fb362354e3541f0d0ff554ad69715965df490392"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@blipp can you please resolve conflicts here?",
          "createdAt": "2021-06-28T14:42:10Z",
          "updatedAt": "2021-06-28T14:42:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0MDc1OTE4",
          "commit": {
            "abbreviatedOid": "0a491b4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks, @blipp! This LGTM, but I think some further clarifications and updated references would help. ",
          "createdAt": "2021-06-28T15:09:12Z",
          "updatedAt": "2021-06-28T15:25:15Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "```suggestion\r\nBesides forward secrecy and key-compromise impersonation, which are highlighted\r\n```",
              "createdAt": "2021-06-28T15:09:12Z",
              "updatedAt": "2021-06-28T15:25:15Z"
            },
            {
              "originalPosition": 150,
              "body": "I would omit this, as the prior paragraphs seem sufficient. ",
              "createdAt": "2021-06-28T15:14:35Z",
              "updatedAt": "2021-06-28T15:25:15Z"
            },
            {
              "originalPosition": 133,
              "body": "```suggestion\r\nin any mode. This means that compromise of long-term recipient secrets allows\r\nan attacker to decrypt past ciphertexts encrypted under said secret. This is because \r\nonly long-term secrets are used on the side of the recipient.\r\n```",
              "createdAt": "2021-06-28T15:16:22Z",
              "updatedAt": "2021-06-28T15:25:16Z"
            },
            {
              "originalPosition": 162,
              "body": "```suggestion\r\nconfidentiality guarantees can be lost completely; in the other modes, at least forward secrecy with\r\n```",
              "createdAt": "2021-06-28T15:23:09Z",
              "updatedAt": "2021-06-28T15:25:16Z"
            },
            {
              "originalPosition": 169,
              "body": "```suggestion\r\nin case of nonce reuse.\r\n```",
              "createdAt": "2021-06-28T15:23:32Z",
              "updatedAt": "2021-06-28T15:25:16Z"
            },
            {
              "originalPosition": 167,
              "body": "```suggestion\r\nThe AEADs specified in this document are not secure\r\n```",
              "createdAt": "2021-06-28T15:23:44Z",
              "updatedAt": "2021-06-28T15:25:16Z"
            },
            {
              "originalPosition": 173,
              "body": "```suggestion\r\ngenerated securely, as described in {{?RFC8937}}.\r\n```",
              "createdAt": "2021-06-28T15:24:37Z",
              "updatedAt": "2021-06-28T15:25:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NTIyNTQ5",
          "commit": {
            "abbreviatedOid": "f7d1375"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T22:14:48Z",
          "updatedAt": "2021-07-02T22:14:48Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "I tried to rephrase to make clearer what I wanted to express: when nonce reuse is relevant. It's not relevant in Base mode, because there, everything is lost anyway.",
              "createdAt": "2021-07-02T22:14:48Z",
              "updatedAt": "2021-07-02T22:14:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NTIzNDI2",
          "commit": {
            "abbreviatedOid": "f7d1375"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T22:17:50Z",
          "updatedAt": "2021-07-02T22:17:50Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Great thanks! I was not aware of this RFC :)",
              "createdAt": "2021-07-02T22:17:50Z",
              "updatedAt": "2021-07-02T22:17:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDI4MjE3",
          "commit": {
            "abbreviatedOid": "f7d1375"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-06T22:24:40Z",
          "updatedAt": "2021-07-06T22:25:55Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "```suggestion\r\nAs discussed in {{kci}}, HPKE ciphertexts are not forward-secure. In the Base and\r\n```",
              "createdAt": "2021-07-06T22:24:40Z",
              "updatedAt": "2021-07-06T22:25:55Z"
            },
            {
              "originalPosition": 158,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-07-06T22:25:12Z",
              "updatedAt": "2021-07-06T22:25:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 229,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc5MDU2MDk2",
      "title": "Add a Zig HPKE implementation",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/229",
      "state": "MERGED",
      "author": "jedisct1",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An HPKE implementation in Zig, without any dependencies.",
      "createdAt": "2021-06-28T13:36:51Z",
      "updatedAt": "2021-06-28T14:58:00Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0f5f56eaac5584b11bc464f54f47fb1b659ec4db",
      "headRepository": "jedisct1/draft-irtf-cfrg-hpke",
      "headRefName": "patch-5",
      "headRefOid": "d9514e3594cc1a27109a8ef47453049eddd7c33a",
      "closedAt": "2021-06-28T14:40:52Z",
      "mergedAt": "2021-06-28T14:40:52Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "04b6a71f303459d9031ac4ff2689774332116188"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk0MDQxNzI1",
          "commit": {
            "abbreviatedOid": "d9514e3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-28T14:40:46Z",
          "updatedAt": "2021-06-28T14:40:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc5OTUyNzIw",
      "title": "Address Spencer's review.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/230",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @blipp ",
      "createdAt": "2021-06-29T12:57:17Z",
      "updatedAt": "2021-07-06T12:58:59Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "760a6c7a7ac7af6575d8afc0173c288b717cf523",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/spencer",
      "headRefOid": "4e87aab8b1aa602b2c2fa2053b10d07416e4baaf",
      "closedAt": "2021-07-06T12:58:58Z",
      "mergedAt": "2021-07-06T12:58:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "adcb868eadd6b66c65686406968a3d801e1502eb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NTM3NDQy",
          "commit": {
            "abbreviatedOid": "4e87aab"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T23:17:06Z",
          "updatedAt": "2021-07-02T23:17:06Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I thought a bit about this because I remembered we had a discussion about this repetitive formulation already a while ago.\r\n\r\nMy conclusion is that your suggestion is fine, and I am glad we get rid of the repetition. (Reasoning: we explicitly constructed HPKE and DHKEM such that even if Extract and Expand are instantiated by the same function, the properties will hold. We did this by the careful domain separation.)",
              "createdAt": "2021-07-02T23:17:06Z",
              "updatedAt": "2021-07-02T23:17:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NTM3NTU2",
          "commit": {
            "abbreviatedOid": "4e87aab"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-02T23:17:39Z",
          "updatedAt": "2021-07-02T23:17:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 231,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg0NzI1ODQ2",
      "title": "Add guidance for using Setup and Context auxiliary info parameters.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/231",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I hesitate to add any more detail about what might be \"per-context\" and \"per-message,\" but I'm open to suggestions if folks think this can be stated more clearly.\r\n\r\nCloses #226.\r\n\r\ncc @davidben, @cjpatton, @martinthomson, @blipp, @franziskuskiefer ",
      "createdAt": "2021-07-06T22:46:06Z",
      "updatedAt": "2021-07-07T15:49:15Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "fb362354e3541f0d0ff554ad69715965df490392",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/info-guidance",
      "headRefOid": "f46d3a1a8e03383a5a27dde8570f089730b1ef48",
      "closedAt": "2021-07-07T15:49:15Z",
      "mergedAt": "2021-07-07T15:49:15Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c73ccaaaf1329954deec83fcb26bcced798b80ee"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I guess it may be less performant if you've got a lot of AAD bits, where info=label and aad=whatever might be more efficient. But this is probably not worth the fuss.\r\n\r\nI figure it's not worth the fuss since both seem to have the same basic security properties. ",
          "createdAt": "2021-07-06T23:36:35Z",
          "updatedAt": "2021-07-06T23:36:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDQ2MjUw",
          "commit": {
            "abbreviatedOid": "aa2c111"
          },
          "author": "davidben",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This works for me, though our implementation doesn't expose the single-shot APIs in the first place, so I'm not the best judge. I guess it may be less performant if you've got a *lot* of AAD bits, where info=label and aad=whatever might be more efficient. But this is probably not worth the fuss.",
          "createdAt": "2021-07-06T23:03:37Z",
          "updatedAt": "2021-07-06T23:09:24Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\noperations, i.e., with the `aad` parameter for `Open()` and `Seal()`, and the `exporter_context` parameter\r\n```",
              "createdAt": "2021-07-06T23:03:37Z",
              "updatedAt": "2021-07-06T23:09:24Z"
            },
            {
              "originalPosition": 29,
              "body": "In addition to redundancy, domain separation is a bit clearer. In ECH, we only include \"tls ech\" in the `info` parameter. `aad` is a plain ClientHelloOuterAAD. If another protocol decided to put the label in the other fields, injectivity is a little trickier.",
              "createdAt": "2021-07-06T23:06:32Z",
              "updatedAt": "2021-07-06T23:09:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNDU4NjY2",
          "commit": {
            "abbreviatedOid": "cab4619"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T23:35:08Z",
          "updatedAt": "2021-07-06T23:35:08Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Yeah, I don't really have a better way to say \"domain separation via the key schedule\" is preferred without just making this text less clear.",
              "createdAt": "2021-07-06T23:35:08Z",
              "updatedAt": "2021-07-06T23:35:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwNTE2OTc0",
          "commit": {
            "abbreviatedOid": "cab4619"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T02:14:40Z",
          "updatedAt": "2021-07-07T02:14:40Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Don't leave the lead-in empty.\r\n\r\nThis section documents considerations for interfaces to implementations of HPKE.  This includes recommendations that improve interoperability when HPKE is used in applications.\r\n",
              "createdAt": "2021-07-07T02:14:40Z",
              "updatedAt": "2021-07-07T02:14:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwOTMyMTI5",
          "commit": {
            "abbreviatedOid": "cab4619"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-07T12:17:42Z",
          "updatedAt": "2021-07-07T12:18:03Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "In the text, \u201cauxiliary _authenticated_ information\u201d is used twice. We could use that in the title, too.",
              "createdAt": "2021-07-07T12:17:42Z",
              "updatedAt": "2021-07-07T12:18:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxMTY4ODY3",
          "commit": {
            "abbreviatedOid": "cab4619"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-07T15:42:16Z",
          "updatedAt": "2021-07-07T15:42:28Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I would refer to these as `info` and `aad` rather than Setup and Context.  Or \"Setup `info`\" and \"Context `aad`\".",
              "createdAt": "2021-07-07T15:42:16Z",
              "updatedAt": "2021-07-07T15:42:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxMTc2MzY2",
          "commit": {
            "abbreviatedOid": "f46d3a1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T15:48:58Z",
          "updatedAt": "2021-07-07T15:48:58Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "\ud83d\udc4d done",
              "createdAt": "2021-07-07T15:48:58Z",
              "updatedAt": "2021-07-07T15:48:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxMTc2NDc5",
          "commit": {
            "abbreviatedOid": "f46d3a1"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T15:49:04Z",
          "updatedAt": "2021-07-07T15:49:04Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Done.",
              "createdAt": "2021-07-07T15:49:04Z",
              "updatedAt": "2021-07-07T15:49:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 232,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg2MTYxNDQz",
      "title": "Consolidate redundant forward secrecy text",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/232",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @blipp ",
      "createdAt": "2021-07-08T16:26:17Z",
      "updatedAt": "2021-07-08T17:13:12Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c73ccaaaf1329954deec83fcb26bcced798b80ee",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "chris-wood-patch-1",
      "headRefOid": "06aa7b754a027ada05cb54c26efa5df776b1f86c",
      "closedAt": "2021-07-08T17:13:12Z",
      "mergedAt": "2021-07-08T17:13:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4801ee0d6f9884b705a9db5b600417e3762501ad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAyMzEzMDA3",
          "commit": {
            "abbreviatedOid": "52f3832"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T17:11:18Z",
          "updatedAt": "2021-07-08T17:11:33Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\n```\r\n\r\nUh, I am sorry about this, it seems I messed up the merge from master into my last pull request (offending commit: https://github.com/cfrg/draft-irtf-cfrg-hpke/commit/2a1d2da03424d82946775314c0553bf7ab0bf4e9).\r\n\r\nI think we should just delete this paragraph. Almost the same text is already in 9.1, and the two paragraphs here are more precise.\r\n\r\nAdditional suggestion: In 9.1 in the paragraph about forward secrecy, we could link to 9.7.4 directly instead of only to 9.7.",
              "createdAt": "2021-07-08T17:11:18Z",
              "updatedAt": "2021-07-08T17:11:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAyMzE0Mjc2",
          "commit": {
            "abbreviatedOid": "52f3832"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-08T17:12:44Z",
          "updatedAt": "2021-07-08T17:12:45Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Works for me, too!",
              "createdAt": "2021-07-08T17:12:44Z",
              "updatedAt": "2021-07-08T17:12:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 233,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg4ODYxMzcx",
      "title": "Clarify security requirements for future specifications",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/233",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Draft based on feedback from Dan on the CFRG mailinglist.",
      "createdAt": "2021-07-13T11:21:09Z",
      "updatedAt": "2021-07-13T16:42:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "4801ee0d6f9884b705a9db5b600417e3762501ad",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_dan_sec",
      "headRefOid": "18bb75101ba115dbfc55c5777b4c8f2e30d17b7d",
      "closedAt": "2021-07-13T16:42:24Z",
      "mergedAt": "2021-07-13T16:42:24Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "8ba4e25c656df4bc0d56a147a8f6b1d4c8c26ee9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA1NDIwNDQ0",
          "commit": {
            "abbreviatedOid": "18bb751"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-13T16:42:19Z",
          "updatedAt": "2021-07-13T16:42:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 234,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk4MTI3NjQ1",
      "title": "Note that Encap is fallible.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/234",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`DH()` can fail, so `Encap()` can fail as well. This PR makes this explicit, and notes that some implementations may choose to upcast errors if desired.\r\n\r\ncc @rozbb ",
      "createdAt": "2021-07-27T19:19:38Z",
      "updatedAt": "2021-07-29T22:58:25Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "8ba4e25c656df4bc0d56a147a8f6b1d4c8c26ee9",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/encap-error-symmetry",
      "headRefOid": "125d31e37e81837764d0ff4e673e87f448316925",
      "closedAt": "2021-07-29T22:58:25Z",
      "mergedAt": "2021-07-29T22:58:25Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "57c5c4170f9b742f7d216b47429dd8776cbf04f5"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One thing I think is still unclear: when `DH()` raises `ValidationError` when being called by `Decap()` does that get upcasted to  a `DecapError` or not? If so, then is it optional like in `Encap()`? If not, then when is a `DecapError` ever created?",
          "createdAt": "2021-07-27T19:27:18Z",
          "updatedAt": "2021-07-27T19:27:18Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> One thing I think is still unclear: when DH() raises ValidationError when being called by Decap() does that get upcasted to a DecapError or not? If so, then is it optional like in Encap()? If not, then when is a DecapError ever created?\r\n\r\nThis seems to be an implementation-specific decision, so, yes, it's optional. Future KEMs might make EncapError or DecapError more explicit, so I think it's best to leave them as-is for now.",
          "createdAt": "2021-07-27T19:29:13Z",
          "updatedAt": "2021-07-27T19:29:13Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok I made a comment that clarifies that",
          "createdAt": "2021-07-27T19:32:11Z",
          "updatedAt": "2021-07-27T19:32:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzAxNDAy",
          "commit": {
            "abbreviatedOid": "01c5cdb"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T19:31:47Z",
          "updatedAt": "2021-07-27T19:31:47Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "just for symmetry:\r\n\"into an `EncapError` (resp. `DecapError`) from `Encap()` (resp. `Decap()`)\"",
              "createdAt": "2021-07-27T19:31:47Z",
              "updatedAt": "2021-07-27T19:31:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzA2NjI4",
          "commit": {
            "abbreviatedOid": "125d31e"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-27T19:37:29Z",
          "updatedAt": "2021-07-27T19:37:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE2MzE5MzMz",
          "commit": {
            "abbreviatedOid": "125d31e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-27T19:53:13Z",
          "updatedAt": "2021-07-27T19:53:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 235,
      "id": "MDExOlB1bGxSZXF1ZXN0Njk5MDQ5NTQ0",
      "title": "Add note on robustness.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/235",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was inspired by [one of Paul's papers](https://eprint.iacr.org/2021/708). I _believe_ this is correct, but @blipp can certainly confirm. @kennypaterson may also know whether or not this is correct. =)\r\n",
      "createdAt": "2021-07-28T22:15:22Z",
      "updatedAt": "2021-10-30T13:33:01Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "05a3ab80d96ec4bd88b5ad262011fdbc8c53a609",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/robustness",
      "headRefOid": "61c190a44c76ee7f20a49e0bf6e80e7b402c2d8e",
      "closedAt": "2021-10-30T13:33:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's an interesting question, thanks Chris for the pointer to the paper.\r\n\r\nThe analysis of HPKE did not cover robustness so far, and I am unsure if HPKE is indeed robust.\r\n\r\nConsider the following attack draft:\r\n\r\n* The adversary samples an ephemeral key:\r\n\r\n```\r\n  skE, pkE = GenerateKeyPair()\r\n  enc = SerializePublicKey(pkE)\r\n```\r\n\r\n* The adversary computes the shared secret for two recipient keys `pkR1`, `pkR2`. (This is basically calling `Encap` twice with the same entropy):\r\n\r\n```\r\n  dh1 = DH(skE, pkR1)\r\n  pkR1m = SerializePublicKey(pkR1)\r\n  kem_context1 = concat(enc, pkR1m)\r\n  shared_secret1 = ExtractAndExpand(dh1, kem_context1)\r\n\r\n  dh2 = DH(skE, pkR2)\r\n  pkR2m = SerializePublicKey(pkR2)\r\n  kem_context2 = concat(enc, pkR2m)\r\n  shared_secret2 = ExtractAndExpand(dh2, kem_context2)\r\n```\r\n\r\n* The adversary uses `KeySchedule` with `shared_secret1` and `shared_secret2` to compute the `key` and `base_nonce` for the two recipients.\r\n\r\n* Then, the adversary uses the Multi-Collide-GCM algorithm described in [LGR20](https://eprint.iacr.org/2020/1491) to prepare a ciphertext that decrypts under both keys. Open problem: Multi-Collide-GCM takes in a set of keys and a _single_ nonce. Here, we have a different nonce per key. Is there a variant of Multi-Collide-GCM that works for a different nonce per key?\r\n\r\n* Assuming such a Multi-Collide-GCM exists, continue as follows: The adversary returns `(enc, ciphertext), pkR1, pkR2` (or the according identities belonging to the public keys) and wins the robustness game.\r\n\r\n",
          "createdAt": "2021-07-28T23:30:14Z",
          "updatedAt": "2021-07-28T23:30:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 236,
      "id": "MDExOlB1bGxSZXF1ZXN0NzA0NzU5NTA3",
      "title": "Add em-dash for clarity.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/236",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @martinthomson ",
      "createdAt": "2021-08-05T14:28:30Z",
      "updatedAt": "2021-08-06T19:47:04Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "57c5c4170f9b742f7d216b47429dd8776cbf04f5",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/mt-nit",
      "headRefOid": "c2fb9babaf6b97befcf552fbefec6b00360e99b0",
      "closedAt": "2021-08-05T22:10:37Z",
      "mergedAt": "2021-08-05T22:10:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "0c2e2fa57074040ebf630d062810d507e427509b"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Teeniest of nits, but this renders poorly. It shows up as `--` in the doc body and bibliography. Also, at least in LaTeX notation, `--` is an en-dash, and `---` is an em-dash. The simple fix is to just insert the `\u2014` character itself, so long as the markdown file is allowed to contain non-ascii characters",
          "createdAt": "2021-08-06T16:51:53Z",
          "updatedAt": "2021-08-06T16:51:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I fail to see how a dash is better than a comma, but whatever.",
          "createdAt": "2021-08-06T19:47:04Z",
          "updatedAt": "2021-08-06T19:47:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzIzODI4NTc5",
          "commit": {
            "abbreviatedOid": "c2fb9ba"
          },
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-05T21:55:11Z",
          "updatedAt": "2021-08-05T21:55:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 237,
      "id": "MDExOlB1bGxSZXF1ZXN0NzEyOTkzMTIz",
      "title": "Add note on Partitioning Oracle attacks",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/237",
      "state": "MERGED",
      "author": "blipp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks to Julia, it became clear that the multi-collision algorithm from their PO attacks paper can easily be adapted to use a different nonce per key. Thus, PO attacks stay relevant for HPKE.\r\n\r\nI wish IRTF drafts would support footnotes; then, I would just add it as a footnote. Now I am not sure how to best incorporate this note.",
      "createdAt": "2021-08-15T19:58:39Z",
      "updatedAt": "2021-08-23T19:16:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "0c2e2fa57074040ebf630d062810d507e427509b",
      "headRepository": "blipp/draft-irtf-cfrg-hpke",
      "headRefName": "blipp_po",
      "headRefOid": "a5444741c9599e272e4b47989d45eed016644791",
      "closedAt": "2021-08-23T19:16:13Z",
      "mergedAt": "2021-08-23T19:16:13Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b14d403c17661b2b9cce0d0a4e4bd5ae464e9ec8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzMwODY4NjEw",
          "commit": {
            "abbreviatedOid": "6f0e0e5"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-16T15:45:27Z",
          "updatedAt": "2021-08-16T15:45:34Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nk, the maximum message length in blocks. (Applying the multi-collision algorithm from\r\n{{LGR20}} requires a small adaptation to the algorithm wherein the appropriate nonce\r\nis computed for each candidate key. This modification adds one call to HKDF per key.\r\nThe number of partitioning oracle queries remains unchanged.) As a result, the PSK\r\nmust therefore be chosen with sufficient entropy so that m + log k is prohibitive for\r\nattackers (e.g., 2^128). Future specifications can define new AEAD algorithms which\r\nare key-committing.\r\n```",
              "createdAt": "2021-08-16T15:45:27Z",
              "updatedAt": "2021-08-16T15:45:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2Nzc5NDUx",
      "title": "Added Nt authentication tag length",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/239",
      "state": "MERGED",
      "author": "jsalowey",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added Nt as authentication tag length for AEAD ciphers. This should resolve issue #238 ",
      "createdAt": "2021-08-20T14:25:06Z",
      "updatedAt": "2021-08-25T00:24:13Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "b14d403c17661b2b9cce0d0a4e4bd5ae464e9ec8",
      "headRepository": "jsalowey/draft-irtf-cfrg-hpke",
      "headRefName": "jsalowey-authtag",
      "headRefOid": "25ee192a139e7e969b3dd232593d3f69f6cd20a0",
      "closedAt": "2021-08-25T00:24:12Z",
      "mergedAt": "2021-08-25T00:24:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ad4b900163b3d2e508c2aa597fa33857b5cda36c"
      },
      "comments": [
        {
          "author": "manger",
          "authorAssociation": "NONE",
          "body": "The length of any authentication tag (if such an item exists) is an internal detail of an AEAD cipher. In RFC5116 \"Authenticated Encryption\" tag length is deliberately not a separate external parameter to specify along with an AEAD cipher. Any tag is part of the ciphertext.\r\n\r\n   Each AEAD algorithm MUST provide a description relating the length of\r\n   the plaintext to that of the ciphertext.  This relation MUST NOT\r\n   depend on external parameters, such as an authentication strength\r\n   parameter (e.g., authentication tag length).  That sort of dependence\r\n   would complicate the use of the algorithm by creating a situation in\r\n   which the information from the AEAD registry was not sufficient to\r\n   ensure interoperability.\r\n\r\nI suggest using the labels from the [IANA AEAD Algorithms](https://www.iana.org/assignments/aead-parameters/aead-parameters.xhtml) list, eg \"AEAD_AES_128_GCM\" instead of \"AES-128-GCM\", to have a precise reference to the algorithm, which includes all its parameters and details.\r\n\r\nI guess listing Nk, Nn, and even Nt is okay. They are a convenient summary of aspects of the AEAD alg without having to follow the references. But defining Nt (tag length) encourages bad APIs that have separate fields for tag & the rest of the ciphertext, instead of just 1 field for the ciphertext.\r\n\r\nJust drop the sentence saying \"The AEAD cipher is initialized with an authentication tag length\".",
          "createdAt": "2021-08-24T02:17:40Z",
          "updatedAt": "2021-08-24T02:44:13Z"
        },
        {
          "author": "jsalowey",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see your point.  Using the IANA AEAD algorithms list would be ideal, it may have already been discussed.  I think the draft should say something about tag length even if it does fix the reference to point to RFC 5116 for the definition of AES-GCM (it currently points to the NIST doc which parameterizes the tag length).  I fixed the sentence to say:\r\n\r\n> The AEAD cipher produces an authentication tag length, Nt, which is equal to 16 bytes for the AEAD ciphers defined in this document.\r\n",
          "createdAt": "2021-08-24T05:03:28Z",
          "updatedAt": "2021-08-24T05:03:28Z"
        },
        {
          "author": "manger",
          "authorAssociation": "NONE",
          "body": "Even better would be:\r\n\r\n> The AEAD cipher produces ciphertext that is Nt bytes longer than the plaintext, which is 16 bytes longer for the AEAD ciphers defined in this document.",
          "createdAt": "2021-08-24T05:07:56Z",
          "updatedAt": "2021-08-24T05:07:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3NDMyNjI0",
          "commit": {
            "abbreviatedOid": "57c736a"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-24T16:17:19Z",
          "updatedAt": "2021-08-24T16:17:24Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nalgorithm produces ciphertext that is Nt bytes longer than the plaintext.\r\nNt = 16 for AEAD algorithms defined in this document.\r\n```",
              "createdAt": "2021-08-24T16:17:20Z",
              "updatedAt": "2021-08-24T16:17:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3NzcwMDUw",
          "commit": {
            "abbreviatedOid": "25ee192"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-24T23:22:37Z",
          "updatedAt": "2021-08-24T23:22:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 240,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE5MTQ4OTQ4",
      "title": "Ct is tuple",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/240",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "ct is actually (ciphertext, tag). This spec doesn't define how to serialize them, so just call that out.",
      "createdAt": "2021-08-25T00:21:06Z",
      "updatedAt": "2021-08-25T18:39:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "b14d403c17661b2b9cce0d0a4e4bd5ae464e9ec8",
      "headRepository": "ekr/draft-irtf-cfrg-hpke",
      "headRefName": "ct_is_tuple",
      "headRefOid": "86c3c7e1213cd71f187ec118382fcda51fc70752",
      "closedAt": "2021-08-25T00:24:01Z",
      "mergedAt": "2021-08-25T00:24:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cd9f31356538a77ae869bf1c54137675dc85adb5"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I actually disagree with this change.  The AEAD interface in RFC 5116 does **not** provide a separate tag; rather the authentication data is considered part of the ciphertext.  Suggest reverting.",
          "createdAt": "2021-08-25T00:56:40Z",
          "updatedAt": "2021-08-25T00:56:51Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's actually somewhat more complicated than this.\n\nThe 5116 interface doesn't specify things one way or the other.\n\n   An AEAD algorithm MAY structure its ciphertext output in any way; for\n   example, the ciphertext can incorporate an authentication tag.  Each\n   algorithm SHOULD choose a structure that is amenable to efficient\n   processing.\n\nHowever, the actual AEAD_GCM bindings concatenate the ciphertext and\nthe tag. So it wouldn't be unreasonable to revert the change, but then\nyou'll have to make clear that any compatible AEAD algorithms must do\n*something*.\n\n-Ekr\n\n\n\n\nOn Tue, Aug 24, 2021 at 5:56 PM Richard Barnes ***@***.***>\nwrote:\n\n> I actually disagree with this change. The AEAD interface in RFC 5116 does\n> *not* provide a separate tag; rather the authentication data is\n> considered part of the ciphertext. Suggest reverting.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/240#issuecomment-905080750>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIMYETGXLLZ6UOPPEOTT6Q5VHANCNFSM5CX45ZKA>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email>\n> .\n>\n",
          "createdAt": "2021-08-25T01:04:04Z",
          "updatedAt": "2021-08-25T01:04:04Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think that text is actually relevant here; it seems like it's just allowing for algorithms like [AERO](https://datatracker.ietf.org/doc/html/draft-mcgrew-aero-01) that don't have an explicit tag.  What's more important is that the [authenticated decryption interface](https://datatracker.ietf.org/doc/html/rfc5116#section-2.2) only has a ciphertext input, not a separate tag.\r\n\r\nI'll make some more constructive suggestions on #243.",
          "createdAt": "2021-08-25T18:39:17Z",
          "updatedAt": "2021-08-25T18:39:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3Nzk0MjY5",
          "commit": {
            "abbreviatedOid": "86c3c7e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-25T00:23:33Z",
          "updatedAt": "2021-08-25T00:23:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE5MTUxNDYz",
      "title": "This provides a more specific reference for the claim that if the",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/241",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "PSK is compromised, then it no longer protects HPKE against post-quantum\r\nattack.",
      "createdAt": "2021-08-25T00:27:18Z",
      "updatedAt": "2021-08-25T00:28:10Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ad4b900163b3d2e508c2aa597fa33857b5cda36c",
      "headRepository": "ekr/draft-irtf-cfrg-hpke",
      "headRefName": "psk_compromise",
      "headRefOid": "0a172f2ffb179599648b78b8a15acc182218f9bb",
      "closedAt": "2021-08-25T00:28:10Z",
      "mergedAt": "2021-08-25T00:28:10Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "c282cb21eca3ddc18e46f7d6750fe931a11a2f0b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3Nzk1ODk5",
          "commit": {
            "abbreviatedOid": "0a172f2"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-25T00:28:06Z",
          "updatedAt": "2021-08-25T00:28:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 242,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE5MTc0MTU2",
      "title": "Revert \"Ct is tuple\"",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/242",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reverts cfrg/draft-irtf-cfrg-hpke#240",
      "createdAt": "2021-08-25T01:23:15Z",
      "updatedAt": "2021-08-25T01:23:20Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "c282cb21eca3ddc18e46f7d6750fe931a11a2f0b",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "revert-240-ct_is_tuple",
      "headRefOid": "d2bd0e3d4e8be6702430f8fc96da2276e752d1d8",
      "closedAt": "2021-08-25T01:23:20Z",
      "mergedAt": "2021-08-25T01:23:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "704bd7a94340cbe259f3b0a741e00b69a5c2ca18"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 243,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE5MTc3NDgx",
      "title": "Double down on single value AEAD interface.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/243",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @ekr ",
      "createdAt": "2021-08-25T01:34:25Z",
      "updatedAt": "2021-08-26T23:33:44Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "704bd7a94340cbe259f3b0a741e00b69a5c2ca18",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/aead-compat",
      "headRefOid": "791f9cb119044b996b3ea10f09ea897fc737cca7",
      "closedAt": "2021-08-26T23:33:43Z",
      "mergedAt": "2021-08-26T23:33:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "abd170eeb3bdfbd3e925101310bc6f7515df3790"
      },
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think this is a matter of implementation but of AEAD scheme.\n\n\nOn Wed, Aug 25, 2021 at 11:50 AM Richard Barnes ***@***.***>\nwrote:\n\n> ***@***.**** commented on this pull request.\n> ------------------------------\n>\n> In draft-irtf-cfrg-hpke.md\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/243#discussion_r696023997>\n> :\n>\n> > +All AEAD algorithms defined in this specification produce and consume a single\n> +value consisting of the encrypted plaintext and authentication tag. However,\n> +some AEAD algorithms produce multiple outputs consisting of the encrypted\n> +plaintext and an authentication tag of length Nt. When used with this specification,\n> +those algorithms MUST concatenate both values to produce a single output whose length matches that of\n> +the input plaintext plus Nt. Similarly, some AEAD algorithms accept\n> +two inputs, one for the encrypted plaintext and another for the authentication tag.\n> +When used with this specification, the ciphertext MUST first be parsed\n> +into the constituent pieces, with the trailing Nt bytes\n> +being the authentication tag and all preceding bytes being the encrypted plaintext.\n>\n> I would frame this more in terms of \"implementations might think in terms\n> of separate tag\". Suggested text:\n>\n> The AEAD interface used in this document is based on RFC 5116, which\n> produces and consumes a single ciphertext value. As discussed in RFC 5116,\n> this ciphertext value contains the encrypted plaintext as well as any\n> authentication data, encoded in a manner described by the individual AEAD\n> scheme. Some implementations are not structured in this way, instead\n> providing a separate ciphertext and tag. When such implementations are used\n> in HPKE implementations, the HPKE implementation will need to combine these\n> inputs into a single ciphertext value within AEAD.Seal, and parse them\n> out within AEAD.Open (again, with the combination/parsing as defined by\n> the AEAD scheme). For example, with the AES-GCM schemes defined in RFC\n> 5116, the GCM authentication tag is placed in the last Nt bytes of the\n> ciphertext output.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/243#pullrequestreview-738714347>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIIYUOH5AF2WGBYJN3TT6U3PXANCNFSM5CX7VR3A>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email>\n> .\n>\n",
          "createdAt": "2021-08-25T18:58:05Z",
          "updatedAt": "2021-08-25T18:58:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Any AEAD scheme that is compatible with the RFC 5116 interface creates a unitary ciphertext.  Some implementations of those schemes provide the tag separately.",
          "createdAt": "2021-08-25T19:25:52Z",
          "updatedAt": "2021-08-25T19:25:52Z"
        },
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\n\nOn 25/08/2021 20:26, Richard Barnes wrote:\n> Any AEAD scheme that is compatible with the RFC 5116 interface\n> creates a unitary ciphertext.  Some implementations of those schemes\n> provide the tag separately.\n\nI agree with Richard, but...\n\nHow much are we really improving this draft at this point vs.\nmaking teeny tweaks that each carry with them a small but\ncumulative risk that we end up causing significant delay?\n\nI'd say \"ship it\" is more appropriate now than \"tweak it.\"\n\nCheers,\nS.\n",
          "createdAt": "2021-08-25T19:36:03Z",
          "updatedAt": "2021-08-25T19:36:03Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "On Wed, Aug 25, 2021 at 12:26 PM Richard Barnes ***@***.***>\nwrote:\n\n> Any AEAD scheme that is compatible with the RFC 5116 interface creates a\n> unitary ciphertext. Some implementations of those schemes provide the tag\n> separately.\n>\n\nCan you please show me the text that leads you to believe this? I believe S\n4. explicitly contradicts this claim:\n\n   An AEAD algorithm MAY structure its ciphertext output in any way; for\n   example, the ciphertext can incorporate an authentication tag.  Each\n   algorithm SHOULD choose a structure that is amenable to efficient\n   processing.\n\n-Ekr\n\n\u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/243#issuecomment-905811424>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLIM5JVIA7IRNG46AAJTT6U7UXANCNFSM5CX7VR3A>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email>\n> .\n>\n",
          "createdAt": "2021-08-25T19:45:14Z",
          "updatedAt": "2021-08-25T19:45:14Z"
        },
        {
          "author": "tgeoghegan",
          "authorAssociation": "NONE",
          "body": "> On Wed, Aug 25, 2021 at 12:26 PM Richard Barnes ***@***.***> wrote: Any AEAD scheme that is compatible with the RFC 5116 interface creates a unitary ciphertext. Some implementations of those schemes provide the tag separately.\r\n> Can you please show me the text that leads you to believe this? I believe S 4. explicitly contradicts this claim: An AEAD algorithm MAY structure its ciphertext output in any way; for example, the ciphertext can incorporate an authentication tag. Each algorithm SHOULD choose a structure that is amenable to efficient processing.\r\n> [\u2026](#)\r\n> -Ekr \u2014\r\n> You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#243 (comment)](https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/243#issuecomment-905811424)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAIPLIM5JVIA7IRNG46AAJTT6U7UXANCNFSM5CX7VR3A> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email> .\r\n\r\nThat's how I interpreted that paragraph, too, when I raised this question to ekr and Chris Wood yesterday, but if you dig a little, the ciphertext is specified for all the AEADs enumerated in HPKE. [RFC8439 section 2.8](https://datatracker.ietf.org/doc/html/rfc8439#section-2.8) describes \"[t]he output from the AEAD\" for ChaCha20Poly1305, and RFC51116 [section 5.1](https://datatracker.ietf.org/doc/html/rfc5116#section-5.1) and 5.2 specify that \"[t]he AEAD_AES_128_GCM ciphertext is formed by appending the authentication tag provided as an output to the GCM encryption operation to the ciphertext that is output by that operation.\" So I think this whole confusion is on me for having focused in on section 4 of RFC5116, but not reading the very next page!",
          "createdAt": "2021-08-25T20:32:01Z",
          "updatedAt": "2021-08-25T20:32:26Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I absolutely agree, but what if I defined some new AEAD (conformant with\n5116) that had a separate auth tag.\n\nOn Wed, Aug 25, 2021 at 1:32 PM Tim Geoghegan ***@***.***>\nwrote:\n\n> On Wed, Aug 25, 2021 at 12:26 PM Richard Barnes *@*.***> wrote: Any AEAD\n> scheme that is compatible with the RFC 5116 interface creates a unitary\n> ciphertext. Some implementations of those schemes provide the tag\n> separately.\n> Can you please show me the text that leads you to believe this? I believe\n> S 4. explicitly contradicts this claim: An AEAD algorithm MAY structure its\n> ciphertext output in any way; for example, the ciphertext can incorporate\n> an authentication tag. Each algorithm SHOULD choose a structure that is\n> amenable to efficient processing.\n> \u2026 <#m_-7164561431358695577_>\n> -Ekr \u2014\n> You are receiving this because you were mentioned. Reply to this email\n> directly, view it on GitHub <#243 (comment)\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/243#issuecomment-905811424>>,\n> or unsubscribe\n> https://github.com/notifications/unsubscribe-auth/AAIPLIM5JVIA7IRNG46AAJTT6U7UXANCNFSM5CX7VR3A\n> . Triage notifications on the go with GitHub Mobile for iOS\n> https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675\n> or Android\n> https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email\n> .\n>\n> That's how I interpreted that paragraph, too, when I raised this question\n> yesterday, but if you dig a little, the ciphertext is specified for all the\n> AEADs enumerated in HPKE. RFC8439 section 2.8\n> <https://datatracker.ietf.org/doc/html/rfc8439#section-2.8> describes\n> \"[t]he output from the AEAD\" for ChaCha20Poly1305, and RFC51116 section\n> 5.1 <https://datatracker.ietf.org/doc/html/rfc5116#section-5.1> and 5.2\n> specify that \"[t]he AEAD_AES_128_GCM ciphertext is formed by appending the\n> authentication tag provided as an output to the GCM encryption operation to\n> the ciphertext that is output by that operation.\" So I think this whole\n> confusion is on me for having focused in on section 4 of RFC5116, but not\n> reading the very next page!\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/243#issuecomment-905853055>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAIPLINCIUTRIPLBR4XWIYLT6VHMZANCNFSM5CX7VR3A>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email>\n> .\n>\n",
          "createdAt": "2021-08-25T20:33:33Z",
          "updatedAt": "2021-08-25T20:33:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "What I'm saying is that you can't both (a) be conformant with RFC 5116 and (b) have a tag that is not somehow encoded in the ciphertext.  Because the authenticated decryption interface has no way to provide a tag except for the ciphertext.",
          "createdAt": "2021-08-26T20:16:04Z",
          "updatedAt": "2021-08-26T20:16:04Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I'm persuaded, though I think that the text in 5116 could use some work.",
          "createdAt": "2021-08-26T20:23:35Z",
          "updatedAt": "2021-08-26T20:23:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Feel free to fire up 5116bis :)",
          "createdAt": "2021-08-26T22:44:27Z",
          "updatedAt": "2021-08-26T22:44:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM3ODIxNzE1",
          "commit": {
            "abbreviatedOid": "dbf84cd"
          },
          "author": "ekr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-25T01:40:24Z",
          "updatedAt": "2021-08-25T01:40:25Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nAll AEAD algorithms defined in this specification produce and consume a single\r\nvalue consisting of the ciphertext and authentication tag. However,\r\nsome AEAD algorithms produce multiple outputs consisting of the encrypted\r\nplaintext and an authentication tag of length Nt. When used with this specification,\r\nthose algorithms MUST concatenate both values to produce a single output whose length matches that of\r\nthe input plaintext plus Nt. Similarly, some AEAD algorithms accept\r\ntwo inputs, one for the encrypted plaintext and another for the authentication tag.\r\nWhen used with this specification, the ciphertext MUST first be parsed \r\ninto the constituent pieces, with the trailing Nt bytes\r\nbeing the authentication tag and all preceding bytes being the encrypted plaintext.\r\n```\r\n\r\nSeal and Open are actually not part of the 5116 interface.\r\n",
              "createdAt": "2021-08-25T01:40:24Z",
              "updatedAt": "2021-08-25T01:40:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM4NjI0MzE2",
          "commit": {
            "abbreviatedOid": "0101f97"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-08-25T17:15:48Z",
          "updatedAt": "2021-08-25T17:16:23Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nvalue consisting of the encrypted plaintext and authentication tag. However,\r\n```\r\nTo avoid ambiguity about if \u201cciphertext\u201d is the entire thing or just the encrypted plaintext, as it has already been done in the remainder of the new text.",
              "createdAt": "2021-08-25T17:15:48Z",
              "updatedAt": "2021-08-25T17:16:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM4NjUwNTA1",
          "commit": {
            "abbreviatedOid": "3649e50"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-25T17:36:06Z",
          "updatedAt": "2021-08-25T17:36:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM4NzE0MzQ3",
          "commit": {
            "abbreviatedOid": "3649e50"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-25T18:46:44Z",
          "updatedAt": "2021-08-25T18:50:23Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I would frame this more in terms of \"implementations might think in terms of separate tag\".  Suggested text:\r\n\r\n> The AEAD interface used in this document is based on RFC 5116, which produces and consumes a single ciphertext value.  As discussed in RFC 5116, this ciphertext value contains the encrypted plaintext as well as any authentication data, encoded in a manner described by the individual AEAD scheme.  Some implementations are not structured in this way, instead providing a separate ciphertext and tag.  When such implementations are used in HPKE implementations, the HPKE implementation will need to combine these inputs into a single ciphertext value within `AEAD.Seal`, and parse them out within `AEAD.Open` (again, with the combination/parsing as defined by the AEAD scheme).  For example, with the AES-GCM schemes defined in RFC 5116, the GCM authentication tag is placed in the last `Nt` bytes of the ciphertext output.",
              "createdAt": "2021-08-25T18:46:45Z",
              "updatedAt": "2021-08-25T18:50:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 246,
      "id": "PR_kwDOC3hbXs4uaRZn",
      "title": "Update LGR20 reference",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/246",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-11T14:44:17Z",
      "updatedAt": "2021-11-11T14:58:17Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "abd170eeb3bdfbd3e925101310bc6f7515df3790",
      "headRepository": "franziskuskiefer/draft-irtf-cfrg-hpke",
      "headRefName": "patch-4",
      "headRefOid": "668dab613e6ec5ab7bb9549678a7d6f1dbc069dd",
      "closedAt": "2021-11-11T14:58:17Z",
      "mergedAt": "2021-11-11T14:58:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "1b3e563933010db2cd04bdfd64cc2fb4821e3071"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOC3hbXs4v6mnO",
          "commit": {
            "abbreviatedOid": "668dab6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-11T14:58:13Z",
          "updatedAt": "2021-11-11T14:58:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 247,
      "id": "PR_kwDOC3hbXs4wvs6K",
      "title": "Truncate test vectors to fit in column format",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/247",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Per the RPC's request.",
      "createdAt": "2022-01-10T16:46:40Z",
      "updatedAt": "2022-01-10T16:47:06Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "1b3e563933010db2cd04bdfd64cc2fb4821e3071",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "caw/truncate-vectors",
      "headRefOid": "e05d8bc938babef98900bf74c9af57adff315d6d",
      "closedAt": "2022-01-10T16:47:06Z",
      "mergedAt": "2022-01-10T16:47:06Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "d0fae32205c3140bf15759d80c83991bd7dd015d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 248,
      "id": "PR_kwDOC3hbXs4wwwk9",
      "title": "RFC Editor proposed edits in AUTH48",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/248",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is for AUTH48 processing.  At the end, we should have a Markdown file that represents the substance of what will go in RFC 9180.   The first commit imports the RFC editor's changes.  Subsequent commits will reflect the authors' changes on top of those changes.",
      "createdAt": "2022-01-10T22:14:40Z",
      "updatedAt": "2022-02-23T23:06:54Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "d0fae32205c3140bf15759d80c83991bd7dd015d",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "auth48",
      "headRefOid": "8976574957cdccc58755bdbda6d3f3c1ffeece21",
      "closedAt": "2022-02-23T23:06:54Z",
      "mergedAt": "2022-02-23T23:06:54Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f58301403223380449ecbfc15c6aeb427aa4a1a4"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Summary of my edits:\r\n* A bunch of commas that were added or removed unnecessarily, including some that made the text non-grammatical (!)\r\n* Re-added hyphens in:\r\n  * non-negative\r\n  * IND-CCA2-secure\r\n  * key-compromise impersonation (this is a term of art, see DOI.10.1007/BFb0024447)\r\n  * non-interactive\r\n* Re-capitalized some SECG algorithms\r\n* Cleared RFC editor comments that have been addressed\r\n* \"implementer\" to \"implementor\"\r\n* Moved Acknowledgements to be the first section in the back matter\r\n* Changed all \"Secret Export\" to \"secret export\"\r\n* Changed all \"public-key\" to \"public key\"\r\n",
          "createdAt": "2022-01-10T23:23:42Z",
          "updatedAt": "2022-01-10T23:23:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation pending resolution of @blipp's comments above, I think we can merge this and cut a new XML file for the RPC.",
          "createdAt": "2022-01-14T00:33:29Z",
          "updatedAt": "2022-01-14T00:33:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood @blipp This looks good to me, and I verified against the RPC's latest XML.  I would propose we merge this once we're all signed off with the RPC.",
          "createdAt": "2022-02-19T16:46:50Z",
          "updatedAt": "2022-02-19T16:46:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOC3hbXs4ykgzn",
          "commit": {
            "abbreviatedOid": "92ae219"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T22:42:58Z",
          "updatedAt": "2022-01-10T23:22:38Z",
          "comments": [
            {
              "originalPosition": 509,
              "body": "I'm not sure why the RPC saw fit to change this to a definition list.  It renders more clearly as artwork.",
              "createdAt": "2022-01-10T22:42:58Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 509,
              "body": "The positions of the line breaks are also deliberate. P-384 is broken after 32 bytes to align with P-256 above.  P-521 is broken at 33 bytes to avoid a dangling one-byte line.",
              "createdAt": "2022-01-10T22:45:35Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 631,
              "body": "Yes, those rows should reference this document.  I assume the current values are a typo.",
              "createdAt": "2022-01-10T22:47:11Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 1289,
              "body": "\"Traditional\" here is not in terms of a human tradition (say, Thanksgiving).  Rather, it describes what is in the literature.",
              "createdAt": "2022-01-10T23:05:22Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 1240,
              "body": "It is important that the Acknowledgements come before the test vectors.  They shouldn't be buried after dozens of pages of random-looking data!",
              "createdAt": "2022-01-10T23:06:18Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 1229,
              "body": "They exceed the 69-character limit because you modified them to do so!\r\n\r\nI don't have an opinion on `<sourcecode>` vs. `artwork`; if you use the already-wrapped values provided, they should fit within the 69-character limit.",
              "createdAt": "2022-01-10T23:08:03Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 1274,
              "body": "I have changed all of these to lower case.",
              "createdAt": "2022-01-10T23:10:01Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 1277,
              "body": "I have reviewed the various uses and think they're correct as-is.",
              "createdAt": "2022-01-10T23:13:00Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 71,
              "body": "Personally, I generally prefer \"public-key\" in this position, but don't feel strongly.  And the terms document seems pretty clear.  So I have normalized on \"public key\" throughout.",
              "createdAt": "2022-01-10T23:17:56Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 182,
              "body": "I don't think there's any artwork in this document.  For the most part, the `type` attribute should be `pseudocode`, except for the test vectors, which should be `test-vectors`.",
              "createdAt": "2022-01-10T23:21:07Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            },
            {
              "originalPosition": 1213,
              "body": "I'm OK with this rendering in the fixed-width version, as long as the HTML/PDF versions yield fixed-width.  @chris-wood @blipp ?",
              "createdAt": "2022-01-10T23:22:08Z",
              "updatedAt": "2022-01-10T23:22:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOC3hbXs4ykwHS",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T00:40:05Z",
          "updatedAt": "2022-01-11T00:40:06Z",
          "comments": [
            {
              "originalPosition": 1213,
              "body": "Yep, that works for me.",
              "createdAt": "2022-01-11T00:40:05Z",
              "updatedAt": "2022-01-11T00:40:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOC3hbXs4ykwH9",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-11T00:40:11Z",
          "updatedAt": "2022-01-11T00:40:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOC3hbXs4ysHt2",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T12:38:39Z",
          "updatedAt": "2022-01-12T12:38:39Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Looking at the [HTML](https://www.rfc-editor.org/authors/rfc9180.html) and the [PDF](https://www.rfc-editor.org/authors/rfc9180.pdf), the lists here got changed into definition lists. Semantically, that's probably what they should be. However, the rendering has no bullet points, which makes it kind of hard to read to me. Or maybe it is not the bullet points but the fact that `<code>` elements do _not_ have a slightly different color like in the rest of the document. What do you think?\r\n\r\nEdited to add: Looking at it again. In Section 3 \u201cNotation\u201d, I think it looks alright without bullet points. I guess it is the indentation in Section 4 that is confusing me. It makes it look a bit cluttered.\r\nI understand that the indentation was added to separate KEM, KDF, and AEAD. Is there another way? Making them subsections (that would make DHKEM as last subsection look a bit weird)? Or some kind of \u201cparagraph title\u201d, is that a thing?\r\n\r\nI see that the definition list below \u201cBeyond the above, a KEM MAY also expose the following functions\u201d is not indented. Should it be, to be consistent?",
              "createdAt": "2022-01-12T12:38:39Z",
              "updatedAt": "2022-01-12T13:03:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOC3hbXs4ysIhQ",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T12:41:54Z",
          "updatedAt": "2022-01-12T12:41:55Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nagreement, the HMAC-based key derivation function (HKDF), and SHA2.\r\n```\r\nI feel like when using the non-abbreviated form of HKDF, this needs a \u201cthe\u201d? (because it is a \u201cfunction\u201d)",
              "createdAt": "2022-01-12T12:41:54Z",
              "updatedAt": "2022-01-12T12:41:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOC3hbXs4ysJjV",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T12:46:05Z",
          "updatedAt": "2022-01-12T12:46:05Z",
          "comments": [
            {
              "originalPosition": 639,
              "body": "The oracle itself does not distinguish between good and wrong PSKs, it is the adversary that uses the oracle to do that.",
              "createdAt": "2022-01-12T12:46:05Z",
              "updatedAt": "2022-01-12T12:46:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOC3hbXs4ysLST",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T12:53:00Z",
          "updatedAt": "2022-01-12T12:53:00Z",
          "comments": [
            {
              "originalPosition": 1213,
              "body": "Works for me. Please see my related comment on the definition lists in \u201cCryptographic Dependencies\u201d.",
              "createdAt": "2022-01-12T12:53:00Z",
              "updatedAt": "2022-01-12T12:53:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOC3hbXs4yudFL",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "blipp",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-12T21:47:31Z",
          "updatedAt": "2022-01-12T21:47:32Z",
          "comments": [
            {
              "originalPosition": 639,
              "body": "Coming back to it, I think the change done by the editors is good. Please excuse the noise.",
              "createdAt": "2022-01-12T21:47:32Z",
              "updatedAt": "2022-01-12T21:47:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOC3hbXs4yzkvC",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-14T00:32:04Z",
          "updatedAt": "2022-01-14T00:32:04Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I don't think so -- this reads fine without \"the\".",
              "createdAt": "2022-01-14T00:32:04Z",
              "updatedAt": "2022-01-14T00:32:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOC3hbXs4yzk1i",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-14T00:33:03Z",
          "updatedAt": "2022-01-14T00:33:03Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Possibly, but indentation like that is an xml2rfc oddity. @bifurcation?",
              "createdAt": "2022-01-14T00:33:03Z",
              "updatedAt": "2022-01-14T00:33:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOC3hbXs4zAWe8",
          "commit": {
            "abbreviatedOid": "bd97b99"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-18T17:08:15Z",
          "updatedAt": "2022-01-18T17:08:15Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "I think the indentation is just due to things being at different levels.  In the main list, the first level is KEM/KDF/AEAD, and the functions are at the second level; the indentation is only at the second level.  The private key functions are at the first level, so they are not indented.\r\n\r\nNonetheless, I agree that this is more readable as a bulleted list.  Which is nice because I didn't reflect the definition list in this set of edits.  So I think we can leave this as it is, and negotiate with the RFC editor about reverting it to bullets.",
              "createdAt": "2022-01-18T17:08:15Z",
              "updatedAt": "2022-01-18T17:08:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 249,
      "id": "PR_kwDOC3hbXs4yOLtB",
      "title": "Use section references",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/249",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-08T09:19:20Z",
      "updatedAt": "2022-02-19T16:44:42Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "auth48",
      "baseRefOid": "8d20f5a35b8c98aea57a55a885ab08a1d8d33a0e",
      "headRepository": "cabo/draft-irtf-cfrg-hpke",
      "headRefName": "section-ref",
      "headRefOid": "f9844e59034e7ac68af589bb41108a7b601c1811",
      "closedAt": "2022-02-19T16:44:42Z",
      "mergedAt": "2022-02-19T16:44:42Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8976574957cdccc58755bdbda6d3f3c1ffeece21"
      },
      "comments": [
        {
          "author": "sftcd",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\nFWIW, I don't think changes like these are worth\r\nfurther extending an already month-long AUTH-48.\r\n(It was Jan 7 when this draft moved to AUTH-48.)\r\n\r\nS.\r\n\r\nOn 08/02/2022 09:19, cabo wrote:\r\n> \r\n> You can view, comment on, or merge this pull request online at:\r\n> \r\n>    https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/249\r\n> \r\n> -- Commit Summary --\r\n> \r\n>    * Use section references\r\n> \r\n> -- File Changes --\r\n> \r\n>      M draft-irtf-cfrg-hpke.md (12)\r\n> \r\n> -- Patch Links --\r\n> \r\n> https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/249.patch\r\n> https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/249.diff\r\n> \r\n",
          "createdAt": "2022-02-08T11:21:34Z",
          "updatedAt": "2022-02-08T11:21:34Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "Of course not.\r\nI was just trying to show how to get the markdown-generated XML closer to the XML manually edited by the RFC editor.\r\n",
          "createdAt": "2022-02-08T11:56:39Z",
          "updatedAt": "2022-02-08T11:56:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo out of curiosity, if this is what the RFC editor's expect in the XML, then why isn't this style of reference the default?",
          "createdAt": "2022-02-08T13:29:46Z",
          "updatedAt": "2022-02-08T13:29:46Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "Well, kramdown-rfc does what you tell it to do.  v2 did not have section references, so the \"default\" (= meaning of a simple reference) is to reference the bibliography entry.  v3 added section references.  The XML for that is arcane, so Martin Thomson and I added markdown support for essentially typing what you want, and with luck, kramdown-rfc knows what XML needs to be generated for that.  But that is only done if you put the \"Section ... of\" etc. into the {{..}}, to maintain  backward compatibility with existing documents.\r\n\r\n(I don't know, and didn't check here, if the RFC editor actually transforms old style references into section references; I just saw that at least one existing reference generates incorrect output so I fixed all of them -- triggered by the word \"section\" in the mail exchange :-)",
          "createdAt": "2022-02-08T13:39:36Z",
          "updatedAt": "2022-02-08T13:39:36Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 250,
      "id": "PR_kwDOC3hbXs418RlL",
      "title": "Add hpke-py",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/250",
      "state": "MERGED",
      "author": "ctz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-09T16:03:39Z",
      "updatedAt": "2022-08-12T11:54:38Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ae58ca548b5cd8dc082033a698290ed2ca5ad4ac",
      "headRepository": "ctz/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "a135553dfd98bf65b9add39d4432e076ca25b258",
      "closedAt": "2022-08-12T11:54:37Z",
      "mergedAt": "2022-08-12T11:54:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "f992ae86c67ab3a241697235ffdaf8e87ac9a50e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 251,
      "id": "PR_kwDOC3hbXs44nuAg",
      "title": "Add TypeScript hpke implementation.",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/251",
      "state": "CLOSED",
      "author": "dajiaji",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi @chris-wood and all, \r\n\r\nI have implemented HPKE on top of Web Cryptography API, which works both on web browsers and Node.js.\r\n\r\nhttps://github.com/dajiaji/hpke-js\r\n\r\nCould you please add this implementation to the list?\r\n\r\nThank you in advance for your consideration.",
      "createdAt": "2022-05-28T05:45:38Z",
      "updatedAt": "2022-07-22T22:42:32Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "f58301403223380449ecbfc15c6aeb427aa4a1a4",
      "headRepository": "dajiaji/draft-irtf-cfrg-hpke",
      "headRefName": "add-hpke-js",
      "headRefOid": "0ccc3b8683abe2b3a555759ca13a8e31072d8212",
      "closedAt": "2022-07-22T22:42:32Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dajiaji",
          "authorAssociation": "NONE",
          "body": "Thanks for adding hpke-js to the list!",
          "createdAt": "2022-07-22T22:42:32Z",
          "updatedAt": "2022-07-22T22:42:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 252,
      "id": "PR_kwDOC3hbXs48pE8z",
      "title": "Add Tink to implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/252",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@fernandolobato can you please confirm that this is correct?",
      "createdAt": "2022-08-04T11:22:07Z",
      "updatedAt": "2022-08-12T11:55:18Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "ae58ca548b5cd8dc082033a698290ed2ca5ad4ac",
      "headRepository": "cfrg/draft-irtf-cfrg-hpke",
      "headRefName": "chris-wood-patch-2",
      "headRefOid": "902da7c734cc0c8b05ede65f2b3bd01f77517347",
      "closedAt": "2022-08-12T11:55:18Z",
      "mergedAt": "2022-08-12T11:55:18Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "fa197012fafd190d1a0b3bdc9b6baa0c7bad9c9a"
      },
      "comments": [
        {
          "author": "fernandolobato",
          "authorAssociation": "NONE",
          "body": "Hey! Thanks for adding us, this is correct expect for Obj-C. We currently support Java, Python, Go, and C++. ",
          "createdAt": "2022-08-09T21:55:51Z",
          "updatedAt": "2022-08-09T21:55:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 253,
      "id": "PR_kwDOC3hbXs5VlZ7K",
      "title": "Add hpke-rb to Existing HPKE implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/253",
      "state": "MERGED",
      "author": "sylph01",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nI implemented HPKE in Ruby and released it as a gem:\r\n\r\n- https://github.com/sylph01/hpke-rb\r\n- https://rubygems.org/gems/hpke",
      "createdAt": "2023-07-15T13:38:53Z",
      "updatedAt": "2023-07-23T19:21:09Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "91d5d69a5aa9beeb3b2527c80448f77b982c84a9",
      "headRepository": "sylph01/draft-irtf-cfrg-hpke",
      "headRefName": "add-hpke-rb",
      "headRefOid": "08147ae02df879fd61ad5ad919f87b45c369a529",
      "closedAt": "2023-07-23T19:21:08Z",
      "mergedAt": "2023-07-23T19:21:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "3b96bb246c89d1b787ab548d6a1ca015977b9223"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you!",
          "createdAt": "2023-07-23T19:21:06Z",
          "updatedAt": "2023-07-23T19:21:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOC3hbXs5b7uxL",
          "commit": {
            "abbreviatedOid": "08147ae"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-23T19:20:08Z",
          "updatedAt": "2023-07-23T19:20:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 254,
      "id": "PR_kwDOC3hbXs5WTpEn",
      "title": "Adding Apple CryptoKit to the list of HPKE Implementations",
      "url": "https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/254",
      "state": "MERGED",
      "author": "FredericJacobs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Starting in the fall releases, Apple platforms will be supporting HPKE in the SDK directly.",
      "createdAt": "2023-07-25T08:43:02Z",
      "updatedAt": "2023-07-25T11:40:58Z",
      "baseRepository": "cfrg/draft-irtf-cfrg-hpke",
      "baseRefName": "master",
      "baseRefOid": "3b96bb246c89d1b787ab548d6a1ca015977b9223",
      "headRepository": "FredericJacobs/draft-irtf-cfrg-hpke",
      "headRefName": "patch-1",
      "headRefOid": "af54979d24b84886d8926ddf79d2db4fb37f6f82",
      "closedAt": "2023-07-25T11:40:58Z",
      "mergedAt": "2023-07-25T11:40:58Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "73bcc810885ac72dac16212f419764965454e0d8"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "\ud83c\udf89 \u2764\ufe0f ",
          "createdAt": "2023-07-25T11:40:51Z",
          "updatedAt": "2023-07-25T11:40:51Z"
        }
      ],
      "reviews": []
    }
  ]
}